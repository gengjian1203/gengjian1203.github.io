<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>13.在循环中key值的作用是什么</title>
    <url>/2020/08/21/13-%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%ADkey%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在日常开发过程中，<br>当使用循环渲染的时候就一定要为循环项设置 key 属性，<br>那么为什么循环项就一定要有 key 呢？<br>如果 key 直接用 index 或者 random 赋值会有什么问题呢？</p>
<a id="more"></a>

<h3 id="究其根本"><a href="#究其根本" class="headerlink" title="究其根本"></a>究其根本</h3><p>无论是 Vue 还是 React 在每次触发渲染重绘的时候，<br>都会执行 diff 算法。<br>来判断新旧节点是否相同 sameVnode 的方法。</p>
<ol>
<li>如果认为节点相同</li>
</ol>
<p>递归 patchVnode 方法，<br>去处理新旧节点的 children，<br>根据新旧节点的 children 情况，<br>来对应 updateChildren、removeChildren 处理。</p>
<ol start="2">
<li>如果认为节点不同。</li>
</ol>
<p>则直接销毁旧节点，创建新节点。</p>
<h3 id="如果判断节点相同"><a href="#如果判断节点相同" class="headerlink" title="如果判断节点相同"></a>如果判断节点相同</h3><blockquote>
<p>源码位置：src/core/vdom/patch.js</p>
</blockquote>
<p>那么是如何判断节点相同的。<br>如果排列组合去对比两套节点，<br>那么时间复杂度将会是 O(n^3)。<br>这种情况是没办法应用于生产环境的。<br>所以无奈之下，<br>想到了一个巧妙且折中的办法：</p>
<ol>
<li>只会做同级的判断</li>
<li>只判断两个节点的 tag 和 key (还会判断 input 的 type)</li>
</ol>
<p>这样虽然可能还是会有一些误判的可能性，<br>不过这样就可以将时间复杂度降低为 O(n)，<br>且误判的造成资源浪费的情况是在我们可接受的范围内的，<br>所以这种方法还是可以应用生产环境的。</p>
<h3 id="key-如何赋值"><a href="#key-如何赋值" class="headerlink" title="key 如何赋值"></a>key 如何赋值</h3><p>那么回到我们最初的问题，应该如何科学的对 key 赋值？<br>最正确的方法就是在设计数据结构的时候，<br>给数组的每一项都设置唯一的 ID（UUID）。<br>将这个 id 赋值给 key。</p>
<p>那么如果给 key 赋值 index 或者 random 会有什么问题呢？</p>
<ol>
<li>如果给 key 赋值 index</li>
</ol>
<p>那么在列表数据没有改变的时候，是没有问题的。<br>可是如果对数据有插入操作，问题将会出现。<br>比如在数组的 3 位置上插入新的数据。<br>那么再次触发渲染。3 位置上的新旧两个节点 tag 和 key 都相同。<br>sameVnode 会返回是 true 认为是相同节点。<br>接下来开始判断这个“相同节点”内部的 children。<br>结果就会发现内部是完全不一样的。<br>那么每个子节点都需要销毁再全部新建。<br>不仅如此，在 3 位置以后的节点也都会出现如此问题。<br>这样销毁再重建，<br>失去了优化 DOM 操作的初衷。</p>
<ol start="2">
<li>如果给 key 赋值 random</li>
</ol>
<p>那么每次触发渲染刷新的时候，<br>sameVnode 永远都会返回是 false。<br>新旧节点都会认为是不同的节点。<br>所以每次渲染都会全部销毁，<br>再全部新建，<br>也同样失去了优化 DOM 操作的初衷。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>key 值的作用主要就是为了优化 diff 算法，<br>进而高效的更新虚拟 DOM。<br>其原理就是通过 key 值来精准判断新旧节点是否为相同节点。<br>从而避免去频繁更新 DOM 元素，<br>使得整个 patch 过程更加高效，减少 DOM 操作，提升性能。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>10.关于小程序中安卓与iOS的兼容适配坑</title>
    <url>/2020/07/10/10-%E5%85%B3%E4%BA%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%AE%89%E5%8D%93%E4%B8%8EiOS%E7%9A%84%E5%85%BC%E5%AE%B9%E5%9D%91/</url>
    <content><![CDATA[<h3 id="小程序兼容适配"><a href="#小程序兼容适配" class="headerlink" title="小程序兼容适配"></a>小程序兼容适配</h3><p>机型适配，安卓与 iOS 系统的兼容，<br>是做前端永恒不变的话题。<br>现在随着终端设备的五花八门，<br>系统繁杂，尺寸比各式各样，<br>导致前端的适配工作就是一个永远也填不完的神坑。<br>随即新建了这个文章，<br>用来记录一下自己踩过的兼容适配坑。</p>
<a id="more"></a>

<h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><h4 id="小程序中右滑返回"><a href="#小程序中右滑返回" class="headerlink" title="小程序中右滑返回"></a>小程序中右滑返回</h4><p>可能由于随着手机屏幕过大，<br>在返回交互上，手指够不到左上角的返回键，<br>新增了右滑返回的交互。<br>设计的初衷是好的，不过坑惨了前端开发人员。<br><a href="https://developers.weixin.qq.com/community/develop/doc/000868190489286620a8b27f156c01?highLine=disableSwipeBack" target="_blank" rel="noopener">“右滑手势返回”能力调整</a><br>微信 7.0.5 客户端版本之后，页面配置中的 <strong>disableSwipeBack</strong> 属性将不再生效。<br>同时也没有 api 能获取到右划返回的回调。</p>
<p>目前能够想到的办法：</p>
<ul>
<li>通过产品交互来回避这个返回坑。</li>
<li>通过检测点击屏幕左边边缘，向右滑动这个动作来捕捉这个事件。（但是无法阻止返回上一页面的交互）</li>
</ul>
<h4 id="Textarea-标签"><a href="#Textarea-标签" class="headerlink" title="Textarea 标签"></a>Textarea 标签</h4><p>关于输入表单，多行文本一般会使用 Textarea 组件。<br>这个时候在样式上，就有文本对齐的坑。<br>安卓机型：没有默认内边距，可以正常显示。<br>iOS 机型：会有默认的 padding 偏移，且无法置 0。<br>虽然在微信小程序官方文档中提到了，<br>基础库版本 2.10.0 以上，<br>新增 disable-default-padding 属性可以去掉 iOS 下的默认内边距。<br>不过实测之后，发现并没有用。</p>
<p>像是 vant 这样的 ui 组件库，<br>对 Textarea 封装的 Field 组件，<br>在源码上是对 ios 机型上增加 margin-top: -9rpx;样式<br>只能说是尽量抹除机型的差距。</p>
<h4 id="长机型的底部安全距离预留"><a href="#长机型的底部安全距离预留" class="headerlink" title="长机型的底部安全距离预留"></a>长机型的底部安全距离预留</h4><p>类似 iphoneX 长机型将样式填满屏幕的时候会有：</p>
<ul>
<li>底部圆边被裁掉样式</li>
<li>底部黑色长条遮挡样式</li>
<li>误触发 Home Indicator 事件</li>
</ul>
<p>这个时候就需要给底部留出安全的距离。<br>可以使用该样式来处理。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.safe-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom); <span class="comment">/*兼容 IOS&lt;11.2*/</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom); <span class="comment">/*兼容 IOS&gt;11.2*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这个变量是 iOS 系统内核提供的，<br>安卓和开发者工具上用的 chromium 内核没有这个变量，<br>导致这个样式只支持 iOS 系统，对安卓系统还需要单独处理。</p>
<p>后补js判断逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算安全区域信息</span></span><br><span class="line"><span class="keyword">const</span> calcSafeAreaInfo = <span class="function">(<span class="params">env, isScreenFringe, systemInfo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; safeArea = &#123;&#125;, windowHeight = <span class="number">0</span>, statusBarHeight = <span class="number">0</span> &#125; = systemInfo || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; top = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">0</span>, bottom = <span class="number">0</span>, width = <span class="number">0</span>, height = <span class="number">0</span> &#125; = safeArea || &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> safeAreaInfoTmp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (env) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"WEB"</span>: &#123;</span><br><span class="line">      safeAreaInfoTmp.safeTop = <span class="number">0</span></span><br><span class="line">      safeAreaInfoTmp.safeBottom = <span class="number">0</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"RN"</span>: &#123;</span><br><span class="line">      safeAreaInfoTmp.safeTop = isScreenFringe ? <span class="number">44</span> : <span class="number">22</span></span><br><span class="line">      safeAreaInfoTmp.safeBottom = <span class="number">0</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> safeTopTmp = <span class="built_in">Math</span>.max(top, statusBarHeight)</span><br><span class="line">      <span class="keyword">const</span> safeBottomTmp = windowHeight - bottom</span><br><span class="line"></span><br><span class="line">      safeAreaInfoTmp.safeTop = safeTopTmp</span><br><span class="line">      safeAreaInfoTmp.safeBottom = safeBottomTmp</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> safeAreaInfoTmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="replaceAll-方法个别机型报错"><a href="#replaceAll-方法个别机型报错" class="headerlink" title="replaceAll 方法个别机型报错"></a>replaceAll 方法个别机型报错</h4><p>android 8.0.1 的 vivo 手机，android 系统内微信版本 7.0.22 里面直接报错。<br>建议改为通过正则实现替换。</p>
<h4 id="渐变色为透明场景iOS真机情况不满足预期"><a href="#渐变色为透明场景iOS真机情况不满足预期" class="headerlink" title="渐变色为透明场景iOS真机情况不满足预期"></a>渐变色为透明场景iOS真机情况不满足预期</h4><p>当有需求要做到一个渐变效果，上方填充红色，下方填充透明颜色，实现渐变效果。<br>样式如下书写时，透明色在iOS真机情况下，透明色会被渲染成黑色</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: linear-gradient(to bottom, red, transparent);</span><br></pre></td></tr></table></figure>

<p>主要的原因应该是渐变样式对<code>transparent</code>属性的不兼容，改为<code>#fff0</code>或者<code>rgba(255, 255, 255, 0)</code>即可。<br>正确的写法如下：  </p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: linear-gradient(to bottom, red, rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>未完待续，随时新坑。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>机型兼容适配</tag>
      </tags>
  </entry>
  <entry>
    <title>1.欢迎来到我的博客</title>
    <url>/2020/06/15/1-%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><p>时光如梭，感觉随着岁数增大，就开始想要回忆。<br>从大学最开始学习的 turbo C，<br>到后来用的 VC 6.0，再到后来 visio studio。<br>从课程设计写的 MFC，用过 cocos 引擎，玩过原生 APP 开发，<br>到后来进了公司去做脚本开发，寻基址，读内存，模拟交互。<br>再到后来被正规军收编在 Ubuntu 的 Qt 上做起了 C++服务器开发。<br>直到现在做起来主攻微信小程序的前端开发。<br>这一路感觉又坎坷，又曲折。<br>有时候真的很迷惑，自己东一下西一下，<br>最后到底收获了什么。<br>都说没有目标的努力，都是在耍流氓。<br>没想到接近而立之年，竟然一直都是在耍流氓。<br>都说，<br>“种一棵树最好的时间，是十年前，其次就是现在。”<br>恩，买房也是。<br>好吧，古人云，知耻而后勇，<br>既然十年前不曾努力，那就从现在开始。<br>更新频率不用太快，不过我希望我能一直坚持下去！</p>
<a id="more"></a>

<h3 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h3><p>在很久之前，在同学小虎的安利下，<br>曾经布置过一次博客，不过那个博客基本都用来秀美食了。<br>最近心血来潮，觉得应该每隔一段时间，<br>应该复盘一下自身的技术栈，<br>不仅是技术的积累，<br>也能在以后遇到同样问题的时候，也能及时找到解决方法。<br>所以，轻车熟路之下，<br>重新有搭建了个纯技术的博客。<br>这次还是用熟悉的 hexo 来搭建，<br>不过新尝试了 Travis CI 来做持续集成，<br>以及使用了好评超高的 Next 来做主题。</p>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>因为 hexo 的源码，和发布代码是不一样的。<br>而建立两个项目，每次 push 两次，又显得特别的别扭。<br>所以为了想要同时保留两份代码，在网上找到了解决方案。<br>使用 <a href="https://www.travis-ci.com/" target="_blank" rel="noopener">Travis CI</a> 持续集成。<br>大致的思路是这样。<br>github 的 page 功能，之能应用在 master 主分支上。<br>那么 master 就用来存放发布后的代码。<br>我们在项目中另外建立个 hexo-source 分支，去存放我们编写时候的源码。<br>而我们每次只需要 push 到 hexo-source 分支上去，<br>然后通过持续集成，项目编译之后，在把发布代码 push 到 master 上去，<br>这样就完成了提交一次代码，github 能存放两套代码的功能。</p>
<p>而 Travis CI 直接通过 github 账号登录即可，<br>然后再 github 中授权 Travis CI 访问自己的项目。<br>不知道是不是自身网速的原因，<br>感觉每次访问 Travis CI 和 github 都会很卡。<br>耐着性子一点点登录，授权之后，<br>在项目中新增允许操作的 Key，然后再 Travis CI 配置好 Key 值即可。</p>
<p>具体的操作可以参考相关成熟的<a href="https://www.jianshu.com/p/5691815b81b6" target="_blank" rel="noopener">技术文章</a>。</p>
<p>2021-06-25 补注：<br>travis 右上角头像 =&gt; SETTING =&gt; Plan =&gt; SelectFree<br>第一次需要手动设置为免费持续集成计划，才有权限进行托管持续集成，否则会报错。<br>Could not authorize build request for gengjian1203/gengjian1203.github.io.</p>
<p>.travis.yml 配置文件可参照如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># S: Build Lifecycle</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># before_script:</span></span><br><span class="line"><span class="comment">#  - npm install -g gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">  <span class="comment"># - gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"gengjian1203"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"gengjian1203@foxmail.com"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">"Update docs"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="string">master:master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># E: Build LifeCycle</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo-source</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/gengjian1203/gengjian1203.github.io</span></span><br></pre></td></tr></table></figure>

<h3 id="关于主题"><a href="#关于主题" class="headerlink" title="关于主题"></a>关于主题</h3><p>主题也是前后折腾了好多次。<br>从自带的 landscape，到之前用过的 yilia、cards，<br>直到现在用的<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a>。<br>确实不愧是 Star 最多的主题，也一直更新了下来。<br>虽然配置项比较多，不过用起来确实很舒爽。<br>比如几个常用的配置：</p>
<ol>
<li>Next 的子主题</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span> <span class="comment"># Muse Mist Pisces</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>菜单设置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span> <span class="comment"># 首页</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span> <span class="comment"># 标签页</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/projects</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span> <span class="comment"># 套用分类的功能，直接跳转到分类的子文件夹</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span> <span class="comment"># 关于</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>菜单标识</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span> <span class="comment"># 菜单现实图标</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span> <span class="comment"># 显示内容的数量</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>头像配置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/head.jpg</span> <span class="comment"># 头像url</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span> <span class="comment"># 头像圆角</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span> <span class="comment"># 鼠标略过头像旋转</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>外链配置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span> <span class="comment"># Github链接</span></span><br><span class="line"><span class="attr">E-Mail:</span> <span class="string">mailto:yourname@qq.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span> <span class="comment"># 邮箱链接</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>标签字号设置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tagcloud:</span></span><br><span class="line">  <span class="attr">min:</span> <span class="number">18</span> <span class="comment"># 标签最小字号</span></span><br><span class="line">  <span class="attr">max:</span> <span class="number">18</span> <span class="comment"># 标签最大字号</span></span><br><span class="line">  <span class="comment"># 话说Next主题没有抽出来颜色的变量，如果想要修改，就要改Next的源码，直接搜索tagcloud就能找得到对应CSS样式。</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>评论配置<br>使用的是 Valine，需要注册国内后端云服务提供商 LeanCloud 的账号。</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开启</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">xxxxxxxxxx</span> <span class="comment"># LeanCloud 应用 appid</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">xxxxxxxxxx</span> <span class="comment"># LeanCloud 应用 appkey</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">随便说点什么吧~</span> <span class="comment"># 评论栏默认文字</span></span><br><span class="line">  <span class="attr">meta:</span> <span class="string">[nick,</span> <span class="string">mail,</span> <span class="string">link]</span> <span class="comment"># 客户提交的抬头信息</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># 评论每页条数</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-cn</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>本地搜索<br>采用的是 hexo-generator-search。通过 npm 安装。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>

<p>将主题的配置项置为 true。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实首页加载还是个问题，<br>第一次打开的时候会很慢，非常不好的体验。<br>不知道是不是受限于 github 的带宽限制，<br>有时候打开 github 都会很卡。<br>准备研究一下 Travis CI 如何搭配 gulp 去使用，<br>看看压缩代码之后，能不能让首屏加载速度有所提升。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Travis CI</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>15.flex布局下文字超出宽度后省略号不起作用解决方法</title>
    <url>/2020/08/21/15-flex%E5%B8%83%E5%B1%80%E4%B8%8B%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E5%AE%BD%E5%BA%A6%E5%90%8E%E7%9C%81%E7%95%A5%E5%8F%B7%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="需求情况"><a href="#需求情况" class="headerlink" title="需求情况"></a>需求情况</h3><p>在项目开发过程中，<br>曾经遇到过这样一个样式需求。<br>在一行中，分为三个部分。<br>左右部分固定宽度，<br>中间部分适配机型宽度，<br>如果中间的文字超出宽度则以省略号显示。</p>
<p>当时没有觉得很复杂，<br>结果在实现的时候，兜兜转转踩了好多坑，<br>其实这个应该算是比较常见的样式吧，<br>决定把他记录下来，防止以后忘记。</p>
<a id="more"></a>

<h3 id="关于省略号"><a href="#关于省略号" class="headerlink" title="关于省略号"></a>关于省略号</h3><p>其实，文本超出范围以省略号显示，这个样式还是很常见的。<br>一行文本超出宽度以省略号显示。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-ellipsis</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 固定宽度 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">/* 超出部分隐藏 */</span></span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis; <span class="comment">/* 超出部分文本以省略号显示 */</span></span><br><span class="line">  <span class="attribute">white-space</span>: nowrap; <span class="comment">/* 文本禁止换行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多行文本超出宽度以省略号显示。（只能适配 webkit 浏览器和移动端）</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.textarea-ellipsis</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box; <span class="comment">/* 对象作为弹性伸缩盒子模型显示 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical; <span class="comment">/* 设置或检索伸缩盒对象的子元素的排列方式 */</span></span><br><span class="line">  <span class="attribute">-webkit-line-clamp</span>: <span class="number">3</span>; <span class="comment">/* 展示行数 */</span></span><br><span class="line">  <span class="comment">/* 如果多行文本内有可能存在长单词英文，那么需要对长单词英文进行打断 */</span></span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word; <span class="comment">/* 是否允许在单词内进行断句 */</span></span><br><span class="line">  <span class="attribute">word-break</span>: break-all; <span class="comment">/* 可以在任何位置断句 */</span></span><br><span class="line">  <span class="comment">/* 让多行文字两端对齐 */</span></span><br><span class="line">  <span class="attribute">text-align</span>: justify; <span class="comment">/* 多行文本样式最好加上：文本两端对齐 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚刚上述的需求里面。<br>通过 flex 布局，左右宽度固定，中间宽度自适应。<br>那么在中间的模块里面，<br>直接使用 text-ellipsis 的样式是不生效的。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"module-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"module-left"</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"module-mid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid-text text-ellipsis"</span>&gt;</span>abcabcabcabcabcabcabcabcabc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"module-right"</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.module-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.module-left</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">120px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.module-mid</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>; <span class="comment">/* 此处的宽度为关键 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.text-ellipsis</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: block;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">      <span class="attribute">overflow</span>: hidden;</span><br><span class="line">      <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">      <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.module-right</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">120px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实这个问题之前遇到过一次，<br>当时为了解决线上问题，<br>就那么默默的划过去了。</p>
<p>不过前几天正巧又遇到了这个样式的需求，<br>只记得当初是这么做过，<br>不记得具体怎么实现的了。<br>结果又是重复的踩了一轮坑。</p>
<p>吸取教训，及时复盘，<br>将这个 CSS 样式整理出来，引以为戒。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>11.在项目中适配模式的使用</title>
    <url>/2020/07/13/11-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%80%82%E9%85%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h3><p>项目最近在用Taro重构，<br>在书写代码方面要求比较严格，<br>正好在跟老大调侃，<br>他偶尔看到我一筐switch…case…<br>给我指了指，<br>让我改用适配模式做一做。<br>本来项目任务都已经很紧了，<br>突然代码实现业务方式的改变，<br>让我有点猝不及防。<br>说实话本来是有点抗拒的，毕竟已经写了很多了，<br>不过后来琢磨了一下，产品的逻辑着实是乱的一批，<br>现在多写点代码，为了以后增改逻辑的时候，能少点坑，<br>看样子用上适配模式，也不失为一个好办法。  </p>
<a id="more"></a>

<h3 id="试用场景"><a href="#试用场景" class="headerlink" title="试用场景"></a>试用场景</h3><p>“适配模式”是比较常用的设计模式之一，<br>核心的概念是，<br>将若干个互不兼容的类，使他们能放到一起去工作。<br>目前的业务场景是这样的：<br>在设置权限模块中，根据设置不同权限类型，<br>对页面有不同的渲染，同时请求不同的数据。  </p>
<p>按照我平时的做法，都是会把几个权限，<br>每种权限分别抽象成一个标志字符，<br>另外将处理方式封成一个函数，<br>通过传入这个标志字符，来得出渲染结果以及所需的数据。  </p>
<p>如果是比较规规矩矩的交互，我的方法还是比较快捷的。<br>可是这次实在是每种权限的渲染差异很大，<br>有的是点一项勾选一个，<br>有的是点一项勾选两个，<br>有的是点一项收起/展示另外两项，<br>很难用一个通用的逻辑去解析这种交互。  </p>
<p>所以干脆写的透彻些，<br>用一个适配器，大大方方的去解决这个问题。<br>把每种权限，用一个类去清清爽爽的处理，<br>这样可以通过类实现物理隔离，不会有牵一发动全身的情况。<br>而且在以后维护的时候，只针对对应的类去修改就好。<br>代码量虽然会多，不过减少了维护成本。  </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象出来的父类</span></span><br><span class="line"><span class="keyword">interface</span> IPermissionAdaptor &#123;</span><br><span class="line">  support: <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">Boolean</span>;     <span class="comment">// 判断是否用该适配器</span></span><br><span class="line">  resolve: <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;;  <span class="comment">// 使用该适配器的逻辑处理方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  IPermissionAdaptor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AAAAA 类型权限</span></span><br><span class="line"><span class="keyword">class</span> NoticeAAAAAdaptor <span class="keyword">implements</span> IPermissionAdaptor&#123;</span><br><span class="line">  support = <span class="function">(<span class="params">objModuleItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> objModuleItem.type === <span class="string">'AAAA'</span></span><br><span class="line">  &#125;</span><br><span class="line">  resolve = <span class="function">(<span class="params">objModuleItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arrResult = []</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> arrResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BBBBB 类型权限</span></span><br><span class="line"><span class="keyword">class</span> NoticeBBBBBdaptor <span class="keyword">implements</span> IPermissionAdaptor&#123;</span><br><span class="line">  support = <span class="function">(<span class="params">objModuleItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> objModuleItem.type === <span class="string">'BBBBBB'</span></span><br><span class="line">  &#125;</span><br><span class="line">  resolve = <span class="function">(<span class="params">objModuleItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arrResult = []</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> arrResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 待遍历类的数组，如果以后权限多了，可以再次拓展</span></span><br><span class="line"><span class="keyword">const</span> ModulePermissionAdaptors = [</span><br><span class="line">  <span class="keyword">new</span> NoticeAAAAAdaptor(),</span><br><span class="line">  <span class="keyword">new</span> NoticeBBBBBdaptor(),</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AdaptorInvoker = &#123;</span><br><span class="line">  apply: <span class="function">(<span class="params">objModuleItem: PermissionResult</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arrResult = [];</span><br><span class="line">    <span class="comment">// 循环遍历，符合条件的适配器</span></span><br><span class="line">    <span class="comment">// 找到合适的就调用该适配器的逻辑实现方法，得到结果后，终止循环</span></span><br><span class="line">    ModulePermissionAdaptors.every(<span class="function">(<span class="params">adaptor</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (adaptor.support(objModuleItem)) &#123;</span><br><span class="line">        arrResult = adaptor.resolve(objModuleItem)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arrResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AdaptorInvoker;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="keyword">const</span> arrResult = PermissionViewAdaptor.apply(objModuleItem)</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>草草看来，<br>如果使用适配器模式的话，<br>代码量绝对是暴增，<br>但是这种写法很适合复杂的逻辑。  </p>
<p>面向过程的写法确实很快，<br>而且代码量也不会看起来这么多。<br>可是，思路无法做到这么清晰，  </p>
<p>以维护的角度来说，<br>如果两个月后找人再来维护这段代码。<br>面向过程那个面条式的逻辑，绝对会让你捋上半天。<br>说不定增加个功能，还得波及到其他的东西。<br>而这个适配器模式，让人很清除要在哪里修改，<br>也不会有该一处，波及其他逻辑的风险。  </p>
<p>另外，我想说的是，有时候设计模式该用就得大胆去用，<br>多用才能对这个模式能有更深的理解。<br>多多利用公司重构代码的机会，<br>锻炼一下自身的架构思想。  </p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>16.关于setState、setData后数值不及时更新的问题</title>
    <url>/2020/11/22/16-%E5%85%B3%E4%BA%8EsetState%E3%80%81setData%E5%90%8E%E6%95%B0%E5%80%BC%E4%B8%8D%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在开始写 setState 的时候，<br>都会有这个疑问。<br>为什么我已经对 state 的数值赋值了，<br>可是我接下来去用这个值的时候，却不是刚刚赋值过的数据。<br>其实原因很简单。</p>
<blockquote>
<p>Because, setState is asynchronously.</p>
</blockquote>
<a id="more"></a>

<h3 id="为什么要异步赋值"><a href="#为什么要异步赋值" class="headerlink" title="为什么要异步赋值"></a>为什么要异步赋值</h3><p>那么为什么要把赋值功能设置成异步，<br>做成同步难道不香么？<br>如果做成了同步的功能，<br>我们的每次 set 操作，<br>就去触发一次页面的渲染也是一件很可怕的事情。<br>更多时候我们只是要一个结果，<br>而不是把每次数据变化精准的展示给用户。<br>而异步赋值的好处就是可以整合我们的操作。<br>这样在主线程之内无论我们一个数组 push 多少次，<br>那么实际上只是会渲染一次。</p>
<h3 id="关于-nexttick"><a href="#关于-nexttick" class="headerlink" title="关于 nexttick"></a>关于 nexttick</h3><p>所谓 nexttick 就是当 DOM 渲染结束之后的一个回调函数。<br>我们可以在 nexttick 的回调函数中获得最新的数值。</p>
<p>要知道我们所有同步任务都是在主线程上执行的。<br>所有异步任务有了运行结果就会在任务队列中放置一个事件。<br>直到主线程的任务结束完毕，<br>就会去查看任务队列，将已完成的异步事件处理完毕。</p>
<p>而 nexttick 就是一个这样的异步任务。<br>在主线程的任务完成后，<br>就会开始执行更新渲染 DOM。<br>直到 DOM 渲染完毕，<br>这样 nexttick 就获取到了改变后的 DOM。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>之所以异步赋值也是为了优化性能，尽量减少 DOM 操作而考虑的。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>18.浅尝VSCode插件开发(Code Maker)</title>
    <url>/2020/12/17/18-%E6%B5%85%E5%B0%9DVSCode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91(Code%20Maker)/</url>
    <content><![CDATA[<h3 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h3><p>工作中写前端的业务代码，说白了也就是写好“页面”和“组件”。（也可以说就是只有“组件”）<br>而在项目结构上，每个组件就是一个文件或者文件夹。<br>每次新写组件的时候，都需要新建文件，<br>然后开始依次写好 import、template、style、data、methods、生命周期、render 等等……<br>为了应对这样重复的工作，<br>我甚至单独建立一套空的模板，每次都是复制一下改个名字，并窃喜于自己的机智。<br>直到遇到了 VSCode 插件，才给我打开一扇新世界的大门。<br>且 VSCode 插件给我带来的惊喜不仅仅于此。</p>
<a id="more"></a>

<h3 id="需求痛点"><a href="#需求痛点" class="headerlink" title="需求痛点"></a>需求痛点</h3><ol>
<li>每次新建页面，新建组件都需要复制一套空模板，可以一键生成空页面、空组件。(可用命令实现)</li>
<li>常用组件、常用 API 、可以通过简短命令自动实现引用。（可用代码片段实现）</li>
<li>页面 import、template、style、data、methods、生命周期、render 有固定顺序。</li>
<li>通过插件配置页面<code>settings.json</code>，可支持自定义开关支持框架（如：Vue、React、Wepy、Taro 等）。(可用配置自定义变量实现)</li>
<li>发布 VSCode 插件市场，可供大家使用。</li>
</ol>
<h3 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h3><p>项目结构如下所示（带*文件为实现重要功能）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGELOG.md &#x2F;&#x2F; 版本更新日志</span><br><span class="line">├── README.md &#x2F;&#x2F; 插件说明</span><br><span class="line">├── cli.js &#x2F;&#x2F; 自动化生成 VSCode 插件命令的 CLI 工具</span><br><span class="line">├── code-maker-1.0.7.vsix &#x2F;&#x2F; VSCode 打包后文件，通过该文件可本地安装或发布线上插件</span><br><span class="line">├── images</span><br><span class="line">│   └── icon.png &#x2F;&#x2F; 插件 icon</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json &#x2F;&#x2F; 核心配置文件*</span><br><span class="line">├── snippets &#x2F;&#x2F; 代码片段*</span><br><span class="line">│   └── mapx.json</span><br><span class="line">├── src &#x2F;&#x2F; 代码实现*</span><br><span class="line">│   ├── command &#x2F;&#x2F; 命令*</span><br><span class="line">│   │   ├── index.ts &#x2F;&#x2F; 命令索引</span><br><span class="line">│   │   ├── taroqmCreateComponent.ts</span><br><span class="line">│   │   ├── taroqmCreatePage.ts</span><br><span class="line">│   │   ├── taroqmEditComponent.ts</span><br><span class="line">│   │   └── taroqmEditPage.ts</span><br><span class="line">│   ├── extension.ts &#x2F;&#x2F; 程序入口*</span><br><span class="line">│   ├── test</span><br><span class="line">│   │   ├── runTest.ts</span><br><span class="line">│   │   └── suite</span><br><span class="line">│   └── utils &#x2F;&#x2F; 公共方法</span><br><span class="line">│       ├── copyFile.ts</span><br><span class="line">│       ├── index.ts &#x2F;&#x2F; 方法索引</span><br><span class="line">│       └── openFile.ts</span><br><span class="line">├── template &#x2F;&#x2F; 模板文件*</span><br><span class="line">│   ├── TaroQmComponent</span><br><span class="line">│   │   ├── less.tmp</span><br><span class="line">│   │   └── tsx.tmp</span><br><span class="line">│   ├── TaroQmPage</span><br><span class="line">│   │   ├── less.tmp</span><br><span class="line">│   │   └── tsx.tmp</span><br><span class="line">│   └── VSCodeCommand</span><br><span class="line">│       └── ts.tmp</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── vsc-extension-quickstart.md</span><br></pre></td></tr></table></figure>

<p>通过<code>package.json</code>文件配置字段：</p>
<ol>
<li>activationEvents - 注册命令</li>
<li>contributes.snippets - 代码片段</li>
<li>contributes.commands - 命令名称</li>
<li>contributes.menus - 配置菜单</li>
<li>contributes.configuration - 配置自定义变量</li>
</ol>
<p>根据<code>开闭原则</code>，为方便以后拓展命令：<br>将每个命令单独建立文件，<br>在插件入口文件 extension.ts 逻辑内，<br>循环遍历由./src/command/index.ts 引用来的命令对象，进行命令注册。<br>这样好处在于，<br>再新增命令的时候，只需要新增加文件对其引用，而无需去修改注册逻辑。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>每次新建页面，新建组件都需要复制一套空模板，可以一键生成空页面、空组件。(可用命令实现)</p>
<p>首先，封装<code>拷贝文件</code>、<code>打开文件</code>的公共方法。<br>其次，通过<code>注册命令</code>、<code>修改命令名称</code>、<code>配置菜单</code>，生成一个命令文件。<br>然后，通过文档以及其他参考资料，找到<code>应用项目文件路径</code>和<code>模板文件路径</code>的字段。<br>最后，将模板文件复制过去，并将自动将模板名字改成所需的页面、组件名字。</p>
</li>
<li><p>常用组件、常用 API 、可以通过简短命令自动实现引用。（可用代码片段实现）<br>通过<code>代码片段</code>、生成一个代码片段文件。<br>即可再对应语言的文件内使用。</p>
</li>
<li><p>页面 import、template、style、data、methods、生命周期、render 有固定顺序。<br>待实现。</p>
</li>
<li><p>通过插件配置页面<code>settings.json</code>，可支持自定义开关支持框架（如：Vue、React、Wepy、Taro 等）。(可用配置自定义变量实现)<br>通过<code>配置自定义变量</code>，定义对应自定义变量。<br>在<code>package.json</code>文件内，可通过<code>when</code>字段对该字段进行使用。<br>在 js 文件内，可通过<code>vscode.workspace.getConfiguration(&#39;myExtension&#39;)</code>API 方法，取到对应自定义变量。</p>
</li>
<li><p>发布 VSCode 插件市场，可供大家使用。<br>全局安装<code>vsce</code>工具，并将 VSCode 插件打包成 vsix 文件。<br>另需要<code>Microsoft账号</code>、<code>Azure账号</code>。<br>在网页版<a href="https://marketplace.visualstudio.com/manage" target="_blank" rel="noopener">https://marketplace.visualstudio.com/manage</a>，将打包好的插件发布出去。</p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>成熟的开发工作应该如同流水线一般。<br>拥有完成的工具体系，而不是遇到需求都是一个人一个想法的自由发挥。<br>无论遇到什么需求都能够有一套对应的技术方案去应对。</p>
<p>以前端常见的业务场景来说：<br>比如：分页加载、分享溯源、详情页面加载、授权鉴权等等……<br>这些业务场景都是有迹可循，都可以套用模板去实现。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/gengjian1203/code-maker" target="_blank" rel="noopener">1. Code Maker</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window" target="_blank" rel="noopener">2. VSCode 插件英文文档</a></li>
<li><a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/api/README" target="_blank" rel="noopener">3. VSCode 插件中文文档（残卷）</a></li>
<li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html" target="_blank" rel="noopener">4. 小茗同学的博客园-VSCode 插件开发全攻略</a></li>
<li><a href="https://segmentfault.com/a/1190000016641617" target="_blank" rel="noopener">5. 有赞美业前端团队-VS Code 插件开发介绍</a></li>
<li><a href="https://github.com/microsoft/vscode-extension-samples" target="_blank" rel="noopener">6. VSCode 插件示例</a></li>
<li><a href="https://blog.csdn.net/Viccj/article/details/125404437" target="_blank" rel="noopener">7. 关于 VSCODE 的插件</a></li>
<li><a href="https://vimsky.com/examples/detail/typescript-ex-vscode-window-showInputBox-method.html" target="_blank" rel="noopener">8. TypeScript window.showInputBox 方法代码示例</a></li>
</ul>
]]></content>
      <categories>
        <category>projects</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>17.关于虚拟节点VNode</title>
    <url>/2020/11/25/17-%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9VNode/</url>
    <content><![CDATA[<h3 id="何为-VNode"><a href="#何为-VNode" class="headerlink" title="何为 VNode"></a>何为 VNode</h3><p>在开发过程中，或许总会听到有人提到过虚拟节点，<br>那么这个究竟是个什么东西？<br>首先我们要有一个认知，<br>那就是 js 的操作的执行速度是远远高于 DOM 的操作的。<br>基于这个认知，为了提升页面的性能，<br>我们宁可多执行一些 js 操作，也要减少对 DOM 的操作（重绘、回流）次数。<br>所以需要用 js 以对象的形式来模拟 DOM 节点，<br>那么经过 js 的计算，只照着最后的结果去操作 DOM 渲染到页面即可。<br>而这个数据结构就是虚拟节点 VNode。</p>
<a id="more"></a>

<h3 id="VNode-的数据结构"><a href="#VNode-的数据结构" class="headerlink" title="VNode 的数据结构"></a>VNode 的数据结构</h3><p>正常的 html 标签一共可以分为三部分：</p>
<ol>
<li>标签名</li>
<li>标签属性</li>
<li>子元素标签</li>
</ol>
<p>那么 VNode 同样可以用一个对象的结构模拟这样的结构：</p>
<ol>
<li>tag</li>
<li>props</li>
<li>children</li>
</ol>
<p>具体可以用这个例子来展示将这个 html 转换成 VNode：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">"ul"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">"list-wrap"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      className: <span class="string">'list-item'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: <span class="string">'AAA'</span></span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      className: <span class="string">'list-item'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: <span class="string">'BBB'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VNode-的作用"><a href="#VNode-的作用" class="headerlink" title="VNode 的作用"></a>VNode 的作用</h3><p>那么我们将 html 转换成一个对象之后对我们的性能优化能起到什么帮助呢？</p>
<ol>
<li>数据驱动视图</li>
</ol>
<p>不用自己手动操作 DOM。<br>只要写好 VM 的代码逻辑，<br>即可通过响应式，来实现数据-视图的绑定。<br>让我们将关注点更多的放在数据上，<br>从而能够实现更复杂的开发业务。</p>
<ol start="2">
<li>精准更新节点</li>
</ol>
<p>可以通过 diff 算法，<br>将有改变的节点进行处理（销毁、新建、更新），<br>而不变的节点则可以不去处理。<br>比起手动粗暴的操作 DOM ，性能方面会更有优势。</p>
<ol start="3">
<li>可以整理合并我们的操作</li>
</ol>
<p>比如我们多次增加节点，<br>如果每次增加一个节点都渲染一次页面做很多无用功，<br>实际上我们想要的就是在多次增加节点后，<br>把最后的一个结果在页面上渲染出来即可。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>VNode 拥有这么多优势，<br>但是还是有几个问题需要我们去想通的。</p>
<ol>
<li>如何将 html 转换为 VNode，然后再将 VNode 转换为 html？</li>
<li>当我们 useData 之后，Vue 是如何知道数值改变了呢？</li>
<li>当页面需要重新渲染的时候，新旧节点是如何去对比的？（13 中有提到部分）</li>
</ol>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>14.关于useState的函数式更新</title>
    <url>/2020/08/21/14-%E5%85%B3%E4%BA%8EuseState%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h3 id="关于-useState"><a href="#关于-useState" class="headerlink" title="关于 useState"></a>关于 useState</h3><p>useState 可谓是在 Taro 的开发过程中最常用的一个 hook。<br>由于函数式组件每次渲染都会执行一次函数，<br>他的作用就是在函数内保存一个变量，并且这个变量能够保存的住。<br>可以通过对应 setXXX 函数来对这个变量进行修改。<br>那么如果变量是一个对象或者一个数组，<br>我只想修改其中一个元素的时候，很容易因为闭包的情况误伤其他元素。<br>这个时候我们可以用到 useState 函数式更新。</p>
<a id="more"></a>

<h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>比如我再页面中声明了这样一个变量。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IImageType &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  isUpload: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [arrImageList, setImageList] = useState&lt;<span class="built_in">Array</span>&lt;IImageType&gt;&gt;([]);</span><br></pre></td></tr></table></figure>

<p>这是一个图片列表，而每个图片上传成功后，我会把每个元素的标志位置 isUpload 再置为 true。<br>如果用普通最直接的方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">onUploadSuccess: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arrImageListTmp = deepClone(arrImageList);</span><br><span class="line">  <span class="keyword">const</span> nIndex = arrImageListTmp.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.id === res.id;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (nIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    arrImageListTmp[nIndex].isUpload = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  setImageList(arrImageListTmp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个时候，由于闭包的存在，导致每个异步回调函数都是闭塞的。<br>不知道 arrImageList 的即时状态。<br>在图片上传成功回调的时候，<br>其 arrImageList 的状态还是执行上传图片时候的状态。<br>效果是，每一个新的图片状态被改变，他同时也会将其他图片状态还原。<br>最后的结果是，只有最后上传成功的图片 isUpload 标志位为 true，<br>其他已经上传成功的图片 isUpload 标志位又被改回了 false。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>这个问题究其根本就是闭包的原因。<br>并且因为这个可爱可憎闭包，<br>也将会在未来 Taro 的开发过程中，不小心就会留下很多坑。<br>那么，面对刚刚的问题，<br>使用 useState 的函数式更新就能很优雅的解决这个问题。<br>只需要在上传成功回调函数中改为以下方法实现：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">onUploadSuccess: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  setImageList(<span class="function">(<span class="params">pervImageList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arrImageListTmp = deepClone(pervImageList);</span><br><span class="line">    <span class="keyword">const</span> nIndex = arrImageListTmp.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.id === res.id;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (nIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arrImageListTmp[nIndex].isUpload = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrImageListTmp;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样一来，<br>每次被深拷贝的 ImageList，<br>都会是当前最新状态的 ImageList。<br>所以，也就不会有之前的问题了。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>解决这个问题的时候，<br>真的是抓心挠肝，想了很多奇葩的方法。<br>尝试 useCallback， useRef，<br>不仅绕路，而且会让代码逻辑导致混乱不堪，没有使用。<br>也想到一种方式是利用 Redux 来存储状态，这样也是可以实现的。<br>不过折腾了一圈，最后从官方文档处发现了解决方法。<br>真是，<br>众里寻他千百度，<br>蓦然回首，<br>那人却在灯火阑珊处。</p>
<p><a href="https://taro-docs.jd.com/taro/docs/hooks#usestate" target="_blank" rel="noopener">官方文档</a>原文是这么写的：<br><strong>函数式更新</strong><br>如果新的 state 需要通过使用先前的 state 计算得出，<br>那么可以将函数传递给 setState。<br>该函数将接收先前的 state，并返回一个更新后的值。<br>下面的计数器组件示例展示了 setState 的两种用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter(&#123; initialCount &#125;) &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(initialCount);</span><br><span class="line">  return (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount(initialCount)&#125;&gt;Reset&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount((prevCount) &#x3D;&gt; prevCount + 1)&#125;&gt;+&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount((prevCount) &#x3D;&gt; prevCount - 1)&#125;&gt;-&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后也说明了</p>
<blockquote>
<p><code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p>
</blockquote>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>19.Node脚本之inquirer库的使用</title>
    <url>/2020/12/19/19-Node%E8%84%9A%E6%9C%AC%E4%B9%8Binquirer%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="inquirer-库是什么"><a href="#inquirer-库是什么" class="headerlink" title="inquirer 库是什么"></a>inquirer 库是什么</h3><p>这是一个可以实现用户与命令行交互的工具。<br>他封装了<code>一问一答</code>式更友好的输入、单选、多选的交互，<br>比如常见的 npm init、 Vue-cli 等脚手架工具都可以通过他来实现。<br>像是我在<code>18.浅尝VSCode插件开发(Code Maker)</code>一文中，提到的<code>自动化生成 VSCode 插件命令的 CLI 工具</code>也就是用他来实现的。</p>
<a id="more"></a>

<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>创建一个<code>index.js</code>搭建好脚本基本框架</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">"inquirer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体交互内容</span></span><br><span class="line"><span class="keyword">const</span> promptList = [</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">"input"</span>, <span class="comment">// input - 输入文本, confirm - (Y/N), list - 列表单选, rawlist - 输入数字单选列表, expand - key值快速选择列表, checkbox - 多选, password - 密文, editor - 编译器长文本</span></span><br><span class="line">    message: <span class="string">"请输入11位数字:"</span>, <span class="comment">// 提示文本</span></span><br><span class="line">    name: <span class="string">"number"</span>, <span class="comment">// 变量命名</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="string">"默认文本"</span>, <span class="comment">// 默认值</span></span><br><span class="line">    when: <span class="function">(<span class="params">answers</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 可通过answers获取刚刚回答的答案</span></span><br><span class="line">      <span class="comment">// 返回值为true的时候才会提问当前问题</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    validate: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 校验规则字段</span></span><br><span class="line">      <span class="keyword">if</span> (val.match(<span class="regexp">/\d&#123;11&#125;/g</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"请输入11位数字"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    filter: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用filter将答案字符串进行处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"tel:"</span> + val;</span><br><span class="line">    &#125;,</span><br><span class="line">    prefix: <span class="string">"前缀"</span>,</span><br><span class="line">    suffix: <span class="string">"后缀"</span>,</span><br><span class="line">    <span class="comment">// choices: [] // list 、rawlist、expand、checkbox会用到</span></span><br><span class="line">    <span class="comment">// pageSize: 2, //修改某些type类型下的渲染行数；</span></span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">inquirer.prompt(promptList).then(<span class="function">(<span class="params">answers</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(answers); <span class="comment">// 返回刚刚输入的结果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接下来只需要拓展 promptList 的元素即可实现自己想要的功能。<br>如果功能逻辑过于复杂的话，建议还是将功能实现通过文件拆分开来。</p>
<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node ./index.js</span><br></pre></td></tr></table></figure>

<p>即可看到刚刚自己所设计的交互了。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实，搭建 inquirer 以及使用还是很简单的。<br>真正复杂的部分应该是在得到刚刚交互结果之后，<br>所需要操作的功能实现。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_26733915/article/details/80461257" target="_blank" rel="noopener">1. inquirer.js —— 一个用户与命令行交互的工具</a></li>
<li><a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">2. inquirer - npm</a></li>
</ul>
]]></content>
      <tags>
        <tag>Node脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>12.关于小程序开发的一些杂谈</title>
    <url>/2020/08/01/12-%E5%85%B3%E4%BA%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<h3 id="书写背景"><a href="#书写背景" class="headerlink" title="书写背景"></a>书写背景</h3><p>从接触到开发小程序，<br>也有一段时间了。<br>想新建一个帖子，<br>借此总结复盘一下自己踩过的坑，<br>和含泪背锅的经历。</p>
<a id="more"></a>

<h3 id="背锅标签"><a href="#背锅标签" class="headerlink" title="背锅标签"></a>背锅标签</h3><ol>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/0006648cb5cd98d8efa9f2be15b000" target="_blank" rel="noopener">wx.previewImage 不能禁用用户保存图片</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000e2af7f08bc81a3a4738b0d59400?highLine=10003" target="_blank" rel="noopener">ios 播放音频偶尔会出现错误</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000e06415e8080732868e776f56000" target="_blank" rel="noopener">UploadTask.onProgressUpdate 进度回调不准确</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000868190489286620a8b27f156c01?highLine=disableSwipeBack" target="_blank" rel="noopener">“右滑手势返回”能力调整</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000402c311c1308f661aeed1d51800" target="_blank" rel="noopener">微信 7.0.12 调用 wx.scanCode 后无 path 返回</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/0006aee1f84e20731f7acc3425a400" target="_blank" rel="noopener">video 在 scrollView 中使用的俩个 bug</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000686116084080eb7cac8f3051c00" target="_blank" rel="noopener">video 退出全屏播放后，安卓会回到顶部？</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/00048854cb87385e373b2675756c00?_at=1637496268044" target="_blank" rel="noopener">canvasContext.draw 回调 ios 第二次不执行</a></li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><p>每个页面尽量重新调用接口<br>这样做的好处是降低耦合，<br>页面与页面之间是一个非常脆弱的关联。<br>因为谁也说不准未来的需求，<br>会不会一时兴起要“空降”这个页面。<br>那么如果这个页面依赖于之前的缓存或者其他处获取 Redux 等全局的数据，<br>最后的结果肯定是惨痛的修修补补。</p>
</li>
<li><p>onLoad/ onShow 生命周期<br>onLoad 的声明周期只用来处理页面传参。<br>onShow 的声明周期用来调用接口初始化数据。<br>如果二者混用，那么绝逼会由于接口异步的调用，<br>导致某些数据依赖数据没获取到就执行下一步，<br>从而使程序出现一堆偶现且莫名其妙的错误。</p>
</li>
<li><p>自定义封装的顶部导航<br>关于自定义的导航有两点想说一下：<br>一是，fixed 样式兼容。<br>当处于 fixed 样式的时候，<br>最好能实现个空格高度来占位文档流。<br>这样可以兼容用 fixed 的页面和不用 fixed 的页面。<br>有了占位之后，可以保证 fixed 的页面不会被搞垮掉。<br>另外也没必要让每个页面都要特意做个 padding-top。<br>这个 padding-top 还需要根据机型来判断高度。<br>所以最好还是都封装在顶部导航组件里来处理这个脏活是最好了。<br>二是，返回按钮劫持事件。<br>由于微信版本的更新，<br>在真机使用小程序时候，<br>可以通过右划左屏幕边缘，来完成快捷返回上一页的交互。<br>这个交互且无法关闭。<br>（可能为了照顾大屏手机 or 最小化小程序交互？）<br>这样相当于跨过了点返回按钮才返回的交互。<br>如果再点击返回按钮时候做了逻辑处理，<br>那么就很容易给未来的自己挖坑。<br>所以，最好还是通过 <strong>重定向</strong> 的跳转方式，<br>稳定的来维护我们的路由堆栈。</p>
</li>
<li><p>关于接口参数的传递<br>比如封装接口，需要传值的时候，<br>需要多少参数，就给封装函数参数设置多少个变量。<br>举个例子。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queryAppInfo = <span class="keyword">async</span> (</span><br><span class="line">  memberId?: <span class="built_in">string</span>,</span><br><span class="line">  appId?: <span class="built_in">string</span>,</span><br><span class="line">  timestamp?: <span class="built_in">string</span></span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> params = &#123;</span><br><span class="line">    memberId,</span><br><span class="line">    appId,</span><br><span class="line">    timestamp,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> CloudFetch.callFunction(<span class="string">"fetchAppInfo"</span>, params);</span><br><span class="line">  <span class="keyword">return</span> res.data.data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而有些参数是可选传参。比如我们不需要传递 appId 的时候，<br>外部调用的时候就会很难看</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">queryAppInfo(<span class="string">"007"</span>, , <span class="string">'123'</span>);</span><br></pre></td></tr></table></figure>

<p>那么，个人认为还是在调用接口的地方处理好参数对象，<br>直接将参数对象传入封装的函数中，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> param = &#123;</span><br><span class="line">  memberId: <span class="string">"007"</span>,</span><br><span class="line">  timestamp: <span class="string">"123"</span>,</span><br><span class="line">&#125;;</span><br><span class="line">queryAppInfo(param);</span><br></pre></td></tr></table></figure>

<p>这样看起来比较规范，数据也会比较安全。</p>
</li>
<li><p>弹出弹窗效果的实现<br>无论是模态对话框，还是弹出提示性的对话框。<br>虽然看起来只是弹出个对话框。<br>不过最好底部加一层蒙板，</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mask</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是透明或者有颜色。<br>这样不仅可以在蒙板上完成，阻止事件冒泡。<br>也可以在蒙板上完成，点击其他部分关闭提示对话框。</p>
</li>
<li><p>应用系的组件，要清晰回调函数<br>比如：登录、授权组件，回传事件需要明确。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">&#125;;</span><br><span class="line">fail: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证性能，谨慎接口调用<br>如果说前端都可以判断到，条件是不符合的，<br>那么无需做无用功，去再调用接口。</p>
</li>
<li><p>公共组件内的数据建议还是通过组件传值来取<br>如果过度依赖 Redux 中的数据，<br>就会导致该模块只能适用当前模块。<br>以至于后期其他模块无法复用。</p>
</li>
<li><p>Html 模板内尽可能的使用自闭合标签<br>在多方因素的作用下：<br>面条型的代码量的增加，<br>个别情况下的书写习惯，<br>线上 bug 临时写一笔赶工，<br>代码过长，缩进捋不清除。<br>在这种情况下，是很容易将一些代码混进标签内，<br>进而引发一些莫名其妙的错误，而且很难定位具体问题。<br>所以尽量使用自闭合标签来避免这些问题。</p>
</li>
<li><p>JSON.parse 的坑<br>JSOM.stringify 和 JSON.parse 是对序列化很有效的方法。<br>可供使用的场景也非常频繁。<br>JSOM.stringify 还好说，转换为字符串问题都不是很大。<br>JSON.parse 相对而言就要谨慎使用。<br>将一个 JSON 字符串转换为对象，<br>可是如果参数传入一个非 JSON 字符串的话，就会导致报错。<br>所以在使用 JSON.parse 的时候，一定要有一层保护。<br>即使传入的参数不是个正经值的时候，<br>传入个’{}’默认字符串以保证程序不至于报错。</p>
</li>
<li><p>wx.scanCode() 返回结果的坑。<br>调用微信小程序官方 API<br>wx.scanCode() 返回值的 path 字段，<br>竟然有时候存在，有时候就没有。<br>对照官方文档之后，看到官方给出的说法是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当所扫的码为当前小程序二维码时，会返回此字段，内容为二维码携带的 path</span><br></pre></td></tr></table></figure>

<p>不过有的时候也没有，只能通过 result 字段存储两份数据。<br>在扫码成功后，能读取成功哪个字段就取哪个字段的数据。</p>
</li>
<li><p>微信小程序 scroll-view 组件实现横向滚动的坑<br>经过测试，<br>发现要想实现横向滚动，不仅在组件设置对应属性字段，<br>还需要 CSS 中满足两个条件：</p>
<ol>
<li>外部 scroll-view 容器设置</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>每个滚动子项需要设置</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 ScrollView 中使用 Canvas 组件<br>会有很多异常的情况出现，比如真机情况下，渲染出来的图片需要屏幕左上角闪一次才会回到期望渲染位置。<br>解决方案，尽量不要将 Canvas 放到 ScrollView 里。生成出来的图片，尽量通过 Canvas 转为 Base64，然后再通过 Base64 渲染到 Image 标签上。</p>
</li>
<li><p>模拟器 canvas 绘制海报的时候 canvasContext.draw 回调第二次不执行。<br>如下代码所示，<br>第一次执行的时候该段函数 1、2、3 都可以执行，<br>不过第二次则只会执行 1、2，<br>3 则不会再进入。</p>
<p>真机暂未发现该问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"updateCanvasShare1"</span>, srcQRCode, strShareContentUrlTmp);</span><br><span class="line"><span class="keyword">await</span> drawCanvasShare(</span><br><span class="line">  canvasShare,</span><br><span class="line">  strShareContentUrlTmp,</span><br><span class="line">  srcQRCode,</span><br><span class="line">  strSharePosterText || sharePosterText,</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"updateCanvasShare2"</span>, srcQRCode, strShareContentUrlTmp);</span><br><span class="line">canvasShare.draw(<span class="literal">false</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"updateCanvasShare3"</span>, srcQRCode, strShareContentUrlTmp);</span><br><span class="line">  <span class="comment">// Taro.hideToast();</span></span><br><span class="line">  Taro.canvasToTempFilePath(&#123;</span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span>,</span><br><span class="line">    width: PANEL_SHARE_WIDTH * <span class="number">2</span>,</span><br><span class="line">    height: PANEL_SHARE_HEIGHT * <span class="number">2</span>,</span><br><span class="line">    destWidth: PANEL_SHARE_WIDTH * <span class="number">2</span>,</span><br><span class="line">    destHeight: PANEL_SHARE_HEIGHT * <span class="number">2</span>,</span><br><span class="line">    fileType: <span class="string">"jpg"</span>,</span><br><span class="line">    canvasId: <span class="string">"canvas-share"</span>,</span><br><span class="line">    success: <span class="function">(<span class="params">resToCanvas</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"canvasToTempFilePath success."</span>, resToCanvas);</span><br><span class="line">      setSharePhotoUrl(resToCanvas.tempFilePath);</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function">(<span class="params">errToCanvas</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"canvasToTempFilePath fail."</span>, errToCanvas);</span><br><span class="line">      setShowBtnRefresh(<span class="literal">true</span>);</span><br><span class="line">      Taro.showToast(&#123; <span class="attr">title</span>: <span class="string">"生成海报失败"</span>, <span class="attr">icon</span>: <span class="string">"none"</span> &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>小程序检测版本更新 wx.getUpdateManager 的一些坑。<br>如下为官方的示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> updateManager = wx.getUpdateManager();</span><br><span class="line">updateManager.onCheckForUpdate(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 请求完新版本信息的回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(res.hasUpdate);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">updateManager.onUpdateReady(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  wx.showModal(&#123;</span><br><span class="line">    title: <span class="string">"更新提示"</span>,</span><br><span class="line">    content: <span class="string">"新版本已经准备好，是否重启应用？"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (res.confirm) &#123;</span><br><span class="line">        <span class="comment">// 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span></span><br><span class="line">        updateManager.applyUpdate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">updateManager.onUpdateFailed(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新版本下载失败</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果在触发<code>更新提示</code>弹窗后，点击确认，<br>此时，会弹出<code>小程序需要重启以使用最新功能</code>弹窗，点击<code>知道了</code>即可重启小程序。</p>
<p>可如果不点确认，而业务逻辑异步出现跳转页面的逻辑，更新逻辑就会被冲掉。<br>而第二次进入小程序的时候，在触发<code>更新提示</code>弹窗后，点击确认，也不会出现<code>小程序需要重启以使用最新功能</code>弹窗，<br>只能默默等待小程序自动更新，或者手动杀掉小程序，清除缓存。</p>
</li>
<li><p>实机 css 动画超出圆角 overflow:hidden 范围<br>真机的情况，css animation 动画，在圆角 overflow:hidden 标签内，显示的内容会超出范围。<br>解决方法：<br>调整父级元素的层级即可。<br><a href="https://developers.weixin.qq.com/community/develop/doc/000ce0ce6bcb80c6465765fdd5bc00" target="_blank" rel="noopener">实机 css 动画超出圆角 overflow:hidden 范围</a></p>
</li>
<li><p>iOS 上 video 位于 scrollView 内部时，全屏后返回，scrollView 自动滚动到顶部<br>微信小程序当前版本的表现即是如此，<br>目前解决方式即是 video 的标签，不要放到 scrollView 内部。（scrollview 的坑太多）<br><a href="https://developers.weixin.qq.com/community/develop/doc/000640cc3882b01928fc9ed295b414" target="_blank" rel="noopener">iOS 上 video 位于 scrollView 内部时，全屏后返回，scrollView 自动滚动到顶部</a></p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>如果后续有想到的会随时更新。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>21.自定义Hook分页加载的实现</title>
    <url>/2021/01/03/21-%E8%87%AA%E5%AE%9A%E4%B9%89Hook%E5%88%86%E9%A1%B5%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="痛点分析"><a href="#痛点分析" class="headerlink" title="痛点分析"></a>痛点分析</h3><p>在实际业务开发的过程中，<br>有很多关于长列表分页加载的场景。<br>比如 feed 信息流，数据统计，成员设置等等。<br>那么如果每个页面都单独写一套长列表分页加载的逻辑，<br>代码重复臃肿，且每个页面实现方式不一样。<br>很难统一管理。</p>
<p>而 Hook 的概念，可以使你在无需修改组件结构的情况下复用状态逻辑。<br>所以才有了封装分页加载 useQueryPageList 的想法。</p>
<a id="more"></a>

<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>那么封装一个功能，<code>入参</code>与<code>返回值</code>都是必要的。<br><code>入参</code>就是：<br>需要调用的接口函数、以及对应的传入参数。<br><code>返回值</code>就是：<br>用以展示的列表数据，以及总条数。</p>
<p>所以在 useQueryPageList 里面同时需要使用生命周期：<br><code>useEffect</code>监听 funFetchApi、param 其中之一发生变化：重新请求一次第一分页（第一次进入页面通过此处获取数据）<br><code>useEffect</code>监听 isUpdateList 变化：用于主动触发刷新的需求<br><code>useDidShow</code>onShow 生命周期：重新获取数据（注：第一次进入页面虽触发 onShow 不过不去执行获取数据操作）<br><code>useReachBottom</code>触底生命周期：加载下一分页数据<br><code>usePullDownRefresh</code>下拉刷新生命周期：重新加载第一分页数据</p>
<p>同时我们需要绑定变量保存当前加载情况：<br><code>nPageNum</code>当前加载的分页编号<br><code>nPageSize</code>每组分页加载多少条数据<br><code>arrPageList</code>目前已经加载的数据</p>
<p><code>isInitComplate</code>是否初始化完毕<br><code>funFetchApiTmp</code>接口 API 的备份，用以判断是否有变化<br><code>paramTmp</code>接口入参的备份，用以判断是否有变化</p>
<p>最后在之前的三个声明周期分别触发回调函数，将获取到的分页数据返回即可。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>useQueryPageList.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123;</span><br><span class="line">  useDidShow,</span><br><span class="line">  useReachBottom,</span><br><span class="line">  usePullDownRefresh,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"@tarojs/taro"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> useDebounce <span class="keyword">from</span> <span class="string">"@/hooks/useDebounce"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PAGE_NUM_LOCK = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> PAGE_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param callback 获取到的列表数据回调函数</span></span><br><span class="line"><span class="comment"> * @param funFetchApi 请求数据的接口函数</span></span><br><span class="line"><span class="comment"> * @param param 请求数据的必要参数</span></span><br><span class="line"><span class="comment"> * @param isUpdateList 修改则主动触发onShow刷新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useQueryPageList = (</span><br><span class="line">  callback: <span class="built_in">any</span>,</span><br><span class="line">  funFetchApi: <span class="built_in">any</span> = <span class="literal">null</span>,</span><br><span class="line">  param: <span class="built_in">any</span> = &#123;&#125;,</span><br><span class="line">  isUpdateList: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> nPageNum = useRef&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> nTotalCount = useRef&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> arrPageList = useRef&lt;<span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;&gt;([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isInitComplate = useRef&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> funFetchApiTmp = useRef(<span class="literal">undefined</span>);</span><br><span class="line">  <span class="keyword">const</span> paramTmp = useRef(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nPageSize = param.nPageSize ? param.nPageSize : PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 统一处理接口返回数据</span></span><br><span class="line"><span class="comment">   * @param res</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> dealFetchResult = <span class="function">(<span class="params">res: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> list = res?.data ? res.data : [];</span><br><span class="line">    <span class="keyword">const</span> totalCount =</span><br><span class="line">      res?.totalCount === <span class="literal">undefined</span></span><br><span class="line">        ? <span class="number">9999</span></span><br><span class="line">        : res?.totalCount</span><br><span class="line">        ? res?.totalCount</span><br><span class="line">        : <span class="number">0</span>;</span><br><span class="line">    nTotalCount.current = totalCount;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      list,</span><br><span class="line">      totalCount,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 统一返回结果数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> returnCallBack = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback &amp;&amp;</span><br><span class="line">      callback(&#123;</span><br><span class="line">        state: <span class="string">"RESULT"</span>,</span><br><span class="line">        list: arrPageList.current,</span><br><span class="line">        totalCount: nTotalCount.current,</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听funFetchApi、param其中之一发生变化：重新请求一次第一分页</span></span><br><span class="line"><span class="comment">   * 新增防抖操作，只取短时间内最后一次的请求结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useEffect(</span><br><span class="line">    useDebounce(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isNotUndefined =</span><br><span class="line">        !(funFetchApi === <span class="literal">undefined</span>) &amp;&amp; !(param === <span class="literal">undefined</span>);</span><br><span class="line">      <span class="keyword">const</span> isDiff =</span><br><span class="line">        funFetchApiTmp.current !== funFetchApi ||</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(paramTmp.current) !== <span class="built_in">JSON</span>.stringify(param);</span><br><span class="line">      <span class="keyword">if</span> (isNotUndefined &amp;&amp; isDiff) &#123;</span><br><span class="line">        funFetchApiTmp.current = funFetchApi;</span><br><span class="line">        paramTmp.current = param;</span><br><span class="line">        nPageNum.current = <span class="number">0</span>;</span><br><span class="line">        callback &amp;&amp; callback(&#123; state: <span class="string">"LOADING"</span> &#125;);</span><br><span class="line">        <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">          ...param,</span><br><span class="line">          nPageNum: nPageNum.current,</span><br><span class="line">          nPageSize: nPageSize,</span><br><span class="line">        &#125;;</span><br><span class="line">        funFetchApi &amp;&amp;</span><br><span class="line">          funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"useQueryPageList useUpdateApiOrParam"</span>, res);</span><br><span class="line">            <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">            arrPageList.current = list;</span><br><span class="line">            isInitComplate.current = <span class="literal">true</span>;</span><br><span class="line">            returnCallBack();</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    [funFetchApi, param]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听isUpdateList变化：用于主动触发刷新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback || !funFetchApi) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInitComplate.current) &#123;</span><br><span class="line">      callback(&#123; state: <span class="string">"LOADING"</span> &#125;);</span><br><span class="line">      <span class="comment">// 一次最多加载(PAGE_NUM_LOCK + 1) * PAGE_SIZE条数据</span></span><br><span class="line">      nPageNum.current =</span><br><span class="line">        nPageNum.current &gt;= PAGE_NUM_LOCK ? PAGE_NUM_LOCK : nPageNum.current;</span><br><span class="line">      <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">        ...param,</span><br><span class="line">        nPageNum: <span class="number">0</span>,</span><br><span class="line">        nPageSize: (nPageNum.current + <span class="number">1</span>) * nPageSize,</span><br><span class="line">      &#125;;</span><br><span class="line">      funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"useQueryPageList useUpdateList"</span>, res);</span><br><span class="line">        <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">        arrPageList.current = list;</span><br><span class="line">        returnCallBack();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [isUpdateList]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * onShow声明周期：重新获取数据（注：第一次进入页面虽触发onShow不过不执行获取数据操作）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useDidShow(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback || !funFetchApi) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInitComplate.current) &#123;</span><br><span class="line">      callback(&#123; state: <span class="string">"LOADING"</span> &#125;);</span><br><span class="line">      <span class="comment">// 一次最多加载PAGE_NUM_LOCK * PAGE_SIZE条数据</span></span><br><span class="line">      nPageNum.current =</span><br><span class="line">        nPageNum.current &gt;= PAGE_NUM_LOCK ? PAGE_NUM_LOCK : nPageNum.current;</span><br><span class="line">      <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">        ...param,</span><br><span class="line">        nPageNum: <span class="number">0</span>,</span><br><span class="line">        nPageSize: (nPageNum.current + <span class="number">1</span>) * nPageSize,</span><br><span class="line">      &#125;;</span><br><span class="line">      funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"useQueryPageList useDidShow"</span>, res);</span><br><span class="line">        <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">        arrPageList.current = list;</span><br><span class="line">        returnCallBack();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 触底生命周期：加载下一分页数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useReachBottom(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback || !funFetchApi) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nPageNum.current * nPageSize &gt; nTotalCount.current) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    callback(&#123; state: <span class="string">"REACH_BOTTOM"</span> &#125;);</span><br><span class="line">    nPageNum.current++;</span><br><span class="line">    <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">      ...param,</span><br><span class="line">      nPageNum: nPageNum.current,</span><br><span class="line">      nPageSize: nPageSize,</span><br><span class="line">    &#125;;</span><br><span class="line">    funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"useQueryPageList useReachBottom"</span>, res);</span><br><span class="line">      <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">      arrPageList.current = arrPageList.current.concat(list);</span><br><span class="line">      returnCallBack();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下拉刷新生命周期：重新加载第一分页数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  usePullDownRefresh(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback || !funFetchApi) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"useQueryPageList usePullDownRefresh"</span>);</span><br><span class="line">    callback(&#123; state: <span class="string">"LOADING"</span> &#125;);</span><br><span class="line">    nPageNum.current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">      ...param,</span><br><span class="line">      nPageNum: nPageNum.current,</span><br><span class="line">      nPageSize: nPageSize,</span><br><span class="line">    &#125;;</span><br><span class="line">    funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"useQueryPageList usePullDownRefresh"</span>, res);</span><br><span class="line">      <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">      arrPageList.current = list;</span><br><span class="line">      returnCallBack();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useQueryPageList;</span><br></pre></td></tr></table></figure>

<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>基本功能是已经实现了。<br>不过实际还有一些隐藏问题。</p>
<ol>
<li><p>不能在组件内使用。<br>因为如果该组件涉及到多次注册和销毁的逻辑。会导致组件内声明的<code>useReachBottom</code>等 Hook 不会销毁。就会多次注册这些 hook。<br>意味着组件销毁、创建 N 次，那么在下拉刷新或者触底的时候就会触发 N 次这些 Hook。</p>
</li>
<li><p>关于页面刷新的交互<br>比如有以下业务场景：列表中有点赞数，当通过列表进入详情，点赞后返回，列表中点赞数要+1。</p>
<p><code>方案 1</code>：列表页面 onShow 生命周期再次加载一次。<br>优点：onShow 操作简单，再次调取接口即可。<br>缺点：比如刚刚点赞的是第 1000 条。页面只会再次加载一次第一组分页数据，页面就会被强制拉上去。要是页面再次加载是将刚刚加载的数据再次请求一次，那么一次请求数据过于庞大也会有问题。且接口请求需要时间，点赞数更新需要等待。<br><code>方案 2</code>：本地数据管理，精准刷新。<br>列表页面 onShow 声明周期的时候，不做任何处理。<br>点赞评论等操作的时候，除了接口调用，同时也要将本地数据同步进行修改。<br>优点：减少接口调用，提升性能，优化体验。<br>缺点：需要跨组件甚至跨页面，精确管理本地数据，给点赞、评论等操作增加副作用冗余操作，逻辑复杂。后期维护增加困难。且如果是帖子取消置顶等交互操作无法判定帖子原来的位置，同样需要接口支持。<br><code>方案 3</code>：即为方案 1 的优化版本。<br>onShow 生命周期再次加载一次。不过设定一次加载最多条数。以防一次性加载数量过于庞大。</p>
<p>根据项目来决定使用哪种方案。相比之下，个人比较倾向于方案 3 的使用。</p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>Hook 是一个非常好用的功能。<br>他类似于一种纬度，横向切片式的操作。<br>可以封装一些无需依赖状态的公共方法。</p>
<p>同样 Hook 也要时刻注意他的触发时机，<br>很容易就造成莫名其妙的多触发了很多次。<br>埋下了性能的深坑。</p>
]]></content>
      <tags>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>20.前端开发规范</title>
    <url>/2021/01/03/20-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="规范背景"><a href="#规范背景" class="headerlink" title="规范背景"></a>规范背景</h3><p>随着市面上的需求越来越复杂.<br>个人开发者已无法满足项目版本的开发速度.<br>那么团队开发是复杂项目的必然选择.<br>不过如何管理研发团队的开发风格,<br>确保每一行代码都像是<code>同一个人</code>编写的.<br>从而减少团队中代码的沟通成本.<br>这是团队开发中重要的一环.</p>
<a id="more"></a>

<h3 id="目录结构规范"><a href="#目录结构规范" class="headerlink" title="目录结构规范"></a>目录结构规范</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── src</span><br><span class="line">    ├── api                   <span class="comment">// 调用接口api</span></span><br><span class="line">    ├── components            <span class="comment">// 公共组件</span></span><br><span class="line">    ├── config                <span class="comment">// 配置环境等</span></span><br><span class="line">    ├── hooks                 <span class="comment">// 公共Hooks</span></span><br><span class="line">    ├── images                <span class="comment">// 本地资源</span></span><br><span class="line">    ├── less                  <span class="comment">// 公共样式</span></span><br><span class="line">    ├── pages                 <span class="comment">// 页面文件夹</span></span><br><span class="line">    │   └── Home              <span class="comment">// 首页</span></span><br><span class="line">    │       ├── components    <span class="comment">// 首页用局部组件</span></span><br><span class="line">    │       ├── data          <span class="comment">// 首页用局部数据</span></span><br><span class="line">    │       └── utils         <span class="comment">// 首页用局部方法</span></span><br><span class="line">    ├── redux                 <span class="comment">// Redux</span></span><br><span class="line">    │       ├── actions       <span class="comment">// 业务代码可调用的方法</span></span><br><span class="line">    │       ├── constants     <span class="comment">// 消息枚举</span></span><br><span class="line">    │       ├── reducers      <span class="comment">// 对redux操作的实现</span></span><br><span class="line">    │       └── store         <span class="comment">// 唯一仓库</span></span><br><span class="line">    ├── service               <span class="comment">// 封装管理器（接口请求管理器、缓存管理器等）</span></span><br><span class="line">    └── utils                 <span class="comment">// 公共方法（计算时间、格式化文本等）</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>组件设计</p>
<p>每个组件都是一个文件夹. 组件名即为文件夹名.<br>文件夹内包括 index.tsx(.js) 、 index.less 以及 README.md(如组件内部业务过于复杂需要书写 README, 功能清晰的组件只需在代码上方注释书写组件功能、传参含义即可).<br>组件内尽量不要使用 redux.<br>所有依赖数据尽量使用 props 传值.<br>内部逻辑实现尽量抽象, 不要依赖业务元素.<br>这样以保证其复用性.<br>组建内部尽量不要使用页面级生命周期. （待实践）</p>
<p>组件传入的每个参数都要注释其意义, 以及是否必传.<br><code>公共组件</code>放到./src/components<br><code>局部组件</code>放到对应页面下的 components 文件夹内</p>
</li>
<li><p>页面设计</p>
<p>每个页面都是一个文件夹. 页面名即为文件夹名.<br>文件夹内包括 components、index.tsx(.js) 、 index.less、 index.config.ts</p>
<p>页面传入的每个参数都要注释其意义, 以及是否必传.</p>
</li>
</ol>
<h3 id="git-管理规范"><a href="#git-管理规范" class="headerlink" title="git 管理规范"></a>git 管理规范</h3><ol>
<li>保证 master 分支代码, 是没有风险的, 随时可以打包上线. 禁止直接在 master 分支修改代码.</li>
<li>dev 分支为预发环境, 保证该分支代码是健康的, 也为即将可以合并 master 分支状态.</li>
<li>stage 分支为测试环境, 大杂烩分支, 想要部署到测试环境上的代码都可以往里放, 该分支可能随时会删除重新从 dev 开辟出来.</li>
<li>dev-something 即为对应需求的开发分支, 从 dev 分支开辟出来. 功能开发完毕后, 需要合并到 dev 分支, 同步书写该版本的文档. 在回归测试没问题后, 通过提交 PR 请求, 经过其他人代码 review 之后, 合并到 master 提单发版.</li>
<li>可通过 gitlab runner 搭建 CI 持续集成.</li>
<li>提交代码时候, 尽量按照功能的原子性提交, 不要多个事情放到一个 commit 里面去.</li>
<li>请按照一定语法去 commit, 每一条 commit 由以下几部分构成.</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">修改类型+(影响模块)+:+[bug单号]+问题描述</span></span><br><span class="line"><span class="section">如: fix(会员购买页面):[7405-7405]会员等级购买ios购买规避政策</span></span><br><span class="line"><span class="section">修改类型分为以下几种:</span></span><br><span class="line"><span class="section">feat: 开发新功能</span></span><br><span class="line"><span class="section">style: 调整样式</span></span><br><span class="line"><span class="section">fix: bug修复</span></span><br><span class="line"><span class="section">refactor: 代码重构</span></span><br><span class="line"><span class="section">merge: 代码合并</span></span><br><span class="line"><span class="section">doc: 书写文档</span></span><br><span class="line"><span class="section">config: 调整配置</span></span><br></pre></td></tr></table></figure>

<p>PS:<br> 定制版本过多的话, 不建议以分支去隔离.<br> 随着业务分叉严重, 版本更迭时间过长.<br> 合代码的时候, 任务重, 风险大.<br> 可考虑通过 webpack 打包不同文件后缀名, 进行文件隔离. （待实践）</p>
<h3 id="代码编写规范"><a href="#代码编写规范" class="headerlink" title="代码编写规范"></a>代码编写规范</h3><ol>
<li>统一开发环境</li>
</ol>
<p>建议 <code>VSCode</code> + <code>Prettier</code> + <code>ESLint</code> + <code>Stylelint</code> + <code>Tailwind</code></p>
<p><code>.vscode/setting.json</code> (仅针对该项目)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"files.autoSave"</span>: <span class="string">"onFocusChange"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.editorconfig</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># http://editorconfig.org</span><br><span class="line">root = true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 2</span><br><span class="line">charset = utf-8</span><br><span class="line">trim_trailing_whitespace = true</span><br><span class="line">insert_final_newline = true</span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace = false</span><br></pre></td></tr></table></figure>

<p><code>.prettierrc.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  tailwindConfig: <span class="string">"./tailwind.config.js"</span>,</span><br><span class="line">  tailwindAttributes: [<span class="string">"customClass"</span>, <span class="string">"className"</span>],</span><br><span class="line">  jsxSingleQuote: <span class="literal">false</span>,</span><br><span class="line">  singleQuote: <span class="literal">false</span>,</span><br><span class="line">  printWidth: <span class="number">140</span>,</span><br><span class="line">  tabWidth: <span class="number">2</span>,</span><br><span class="line">  useTabs: <span class="literal">false</span>,</span><br><span class="line">  semi: <span class="literal">true</span>,</span><br><span class="line">  trailingComma: <span class="string">"es5"</span>,</span><br><span class="line">  jsxBracketSameLine: <span class="literal">false</span>,</span><br><span class="line">  bracketSpacing: <span class="literal">true</span>,</span><br><span class="line">  arrowParens: <span class="string">"always"</span>,</span><br><span class="line">  quoteProps: <span class="string">"preserve"</span>,</span><br><span class="line">  proseWrap: <span class="string">"preserve"</span>,</span><br><span class="line">  htmlWhitespaceSensitivity: <span class="string">"css"</span>,</span><br><span class="line">  organizeImportsSkipDestructiveCodeActions: <span class="literal">false</span>,</span><br><span class="line">  stylelintIntegration: <span class="literal">true</span>,</span><br><span class="line">  importOrder: [</span><br><span class="line">    <span class="string">"&lt;THIRD_PARTY_MODULES&gt;"</span>,</span><br><span class="line">    <span class="string">"^@/(.*)$"</span>,</span><br><span class="line">    <span class="string">"^../(.*)"</span>,</span><br><span class="line">    <span class="string">"^./((?!less).)*$"</span>,</span><br><span class="line">    <span class="string">"^./(.*)"</span>,</span><br><span class="line">  ],</span><br><span class="line">  importOrderSeparation: <span class="literal">false</span>,</span><br><span class="line">  importOrderSortSpecifiers: <span class="literal">true</span>,</span><br><span class="line">  plugins: [<span class="string">"prettier-plugin-organize-imports"</span>, <span class="string">"prettier-plugin-tailwindcss"</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>.eslintrc.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">"taro/react"</span>],</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      jsx: <span class="literal">true</span>,</span><br><span class="line">      tsx: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    useJSXTextNode: <span class="literal">true</span>,</span><br><span class="line">    useTSXTextNode: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">"react/jsx-uses-react"</span>: <span class="string">"off"</span>,</span><br><span class="line">    <span class="string">"react/react-in-jsx-scope"</span>: <span class="string">"off"</span>,</span><br><span class="line">    <span class="string">"react/jsx-key"</span>: <span class="string">"error"</span>,</span><br><span class="line">    <span class="string">"jsx-quotes"</span>: [<span class="string">"error"</span>, <span class="string">"prefer-double"</span>], <span class="comment">// 强制在JSX属性（jsx-quotes）中一致使用双引号</span></span><br><span class="line">    <span class="string">"no-const-assign"</span>: <span class="number">2</span>, <span class="comment">// 禁止修改const声明的变量</span></span><br><span class="line">    <span class="string">"no-fallthrough"</span>: <span class="number">1</span>, <span class="comment">// 禁止switch穿透</span></span><br><span class="line">    <span class="string">"no-func-assign"</span>: <span class="number">2</span>, <span class="comment">// 禁止重复的函数声明</span></span><br><span class="line">    <span class="string">"no-multiple-empty-lines"</span>: [<span class="number">1</span>, &#123; <span class="attr">max</span>: <span class="number">2</span> &#125;], <span class="comment">// 空行最多不能超过2行</span></span><br><span class="line">    <span class="string">"no-param-reassign"</span>: <span class="number">2</span>, <span class="comment">// 禁止给参数重新赋值</span></span><br><span class="line">    <span class="string">"no-mixed-spaces-and-tabs"</span>: [<span class="number">2</span>, <span class="literal">false</span>], <span class="comment">// 禁止混用tab和空格</span></span><br><span class="line">    <span class="string">"no-sequences"</span>: <span class="number">0</span>, <span class="comment">//禁止使用逗号运算符</span></span><br><span class="line">    <span class="string">"no-unneeded-ternary"</span>: <span class="number">2</span>, <span class="comment">// 禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span></span><br><span class="line">    <span class="string">"no-unused-vars"</span>: [<span class="number">1</span>, &#123; <span class="attr">vars</span>: <span class="string">"all"</span>, <span class="attr">args</span>: <span class="string">"after-used"</span> &#125;], <span class="comment">// 不能有声明后未被使用的变量或参数</span></span><br><span class="line">    <span class="string">"no-undef"</span>: <span class="string">"error"</span>,</span><br><span class="line">    <span class="string">"no-var"</span>: <span class="number">0</span>, <span class="comment">// 禁用var，用let和const代替</span></span><br><span class="line">    <span class="string">"arrow-parens"</span>: <span class="number">0</span>, <span class="comment">// 箭头函数用小括号括起来</span></span><br><span class="line">    <span class="string">"arrow-spacing"</span>: <span class="number">0</span>, <span class="comment">// =&gt;的前/后括号</span></span><br><span class="line">    curly: [<span class="number">2</span>, <span class="string">"all"</span>], <span class="comment">// 必须使用 if()&#123;&#125; 中的&#123;&#125;</span></span><br><span class="line">    <span class="string">"default-case"</span>: <span class="number">2</span>, <span class="comment">// switch语句最后必须有default</span></span><br><span class="line">    eqeqeq: <span class="number">2</span>, <span class="comment">// 必须使用全等</span></span><br><span class="line">    <span class="string">"init-declarations"</span>: <span class="number">0</span>, <span class="comment">// 声明时必须赋初值</span></span><br><span class="line">    <span class="string">"import/order"</span>: <span class="number">0</span>, <span class="comment">// import顺序有误</span></span><br><span class="line">    <span class="string">"import/no-commonjs"</span>: <span class="number">0</span>, <span class="comment">// 忽略require使用告警</span></span><br><span class="line">    <span class="string">"import/no-named-as-default"</span>: <span class="number">0</span>, <span class="comment">// 忽略默认导出方法的名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>.stylelintrc.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  processors: [],</span><br><span class="line">  plugins: [<span class="string">"stylelint-order"</span>],</span><br><span class="line">  extends: [<span class="string">"stylelint-config-standard"</span>, <span class="string">"stylelint-config-css-modules"</span>],</span><br><span class="line">  globals: &#123;</span><br><span class="line">    wx: <span class="literal">true</span>,</span><br><span class="line">    App: <span class="literal">true</span>,</span><br><span class="line">    Page: <span class="literal">true</span>,</span><br><span class="line">    getApp: <span class="literal">true</span>,</span><br><span class="line">    Component: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">"selector-class-pattern"</span>: [</span><br><span class="line">      <span class="comment">// 命名规范 -</span></span><br><span class="line">      <span class="string">"^([a-z][a-z0-9]*)(-[a-z0-9]*_?[a-z0-9]+)*$"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        message: <span class="string">"Expected class selector to be kebab-case"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"no-invalid-double-slash-comments"</span>: <span class="literal">null</span>, <span class="comment">// 禁止双斜杠注释</span></span><br><span class="line">    <span class="string">"block-no-empty"</span>: <span class="literal">null</span>, <span class="comment">// 禁止空块</span></span><br><span class="line">    <span class="string">"at-rule-empty-line-before"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">"at-rule-no-unknown"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">"length-zero-no-unit"</span>: <span class="literal">true</span>, <span class="comment">// 禁止零长度的单位（可自动修复）</span></span><br><span class="line">    <span class="string">"shorthand-property-no-redundant-values"</span>: <span class="literal">true</span>, <span class="comment">// 简写属性</span></span><br><span class="line">    <span class="string">"declaration-block-no-duplicate-properties"</span>: <span class="literal">true</span>, <span class="comment">// 禁止声明快重复属性</span></span><br><span class="line">    <span class="string">"declaration-block-no-redundant-longhand-properties"</span>: <span class="literal">null</span>, <span class="comment">// 禁止在声明块中使用缩写属性</span></span><br><span class="line">    <span class="string">"no-descending-specificity"</span>: <span class="literal">true</span>, <span class="comment">// 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器。</span></span><br><span class="line">    <span class="string">"selector-max-id"</span>: <span class="number">0</span>, <span class="comment">// 限制一个选择器中 ID 选择器的数量</span></span><br><span class="line">    <span class="string">"max-nesting-depth"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"order/properties-order"</span>: [</span><br><span class="line">      <span class="comment">// 规则顺序</span></span><br><span class="line">      <span class="string">"box-sizing"</span>,</span><br><span class="line">      <span class="string">"position"</span>,</span><br><span class="line">      <span class="string">"top"</span>,</span><br><span class="line">      <span class="string">"left"</span>,</span><br><span class="line">      <span class="string">"right"</span>,</span><br><span class="line">      <span class="string">"bottom"</span>,</span><br><span class="line">      <span class="string">"z-index"</span>,</span><br><span class="line">      <span class="string">"flex"</span>,</span><br><span class="line">      <span class="string">"display"</span>,</span><br><span class="line">      <span class="string">"flex-direction"</span>,</span><br><span class="line">      <span class="string">"flex-wrap"</span>,</span><br><span class="line">      <span class="string">"justify-content"</span>,</span><br><span class="line">      <span class="string">"align-items"</span>,</span><br><span class="line">      <span class="string">"grid-template-columns"</span>,</span><br><span class="line">      <span class="string">"grid-gap"</span>,</span><br><span class="line">      <span class="string">"float"</span>,</span><br><span class="line">      <span class="string">"width"</span>,</span><br><span class="line">      <span class="string">"height"</span>,</span><br><span class="line">      <span class="string">"max-width"</span>,</span><br><span class="line">      <span class="string">"max-height"</span>,</span><br><span class="line">      <span class="string">"min-width"</span>,</span><br><span class="line">      <span class="string">"min-height"</span>,</span><br><span class="line">      <span class="string">"padding"</span>,</span><br><span class="line">      <span class="string">"padding-top"</span>,</span><br><span class="line">      <span class="string">"padding-right"</span>,</span><br><span class="line">      <span class="string">"padding-bottom"</span>,</span><br><span class="line">      <span class="string">"padding-left"</span>,</span><br><span class="line">      <span class="string">"margin"</span>,</span><br><span class="line">      <span class="string">"margin-top"</span>,</span><br><span class="line">      <span class="string">"margin-right"</span>,</span><br><span class="line">      <span class="string">"margin-bottom"</span>,</span><br><span class="line">      <span class="string">"margin-left"</span>,</span><br><span class="line">      <span class="string">"margin-collapse"</span>,</span><br><span class="line">      <span class="string">"margin-top-collapse"</span>,</span><br><span class="line">      <span class="string">"margin-right-collapse"</span>,</span><br><span class="line">      <span class="string">"margin-bottom-collapse"</span>,</span><br><span class="line">      <span class="string">"margin-left-collapse"</span>,</span><br><span class="line">      <span class="string">"transform"</span>,</span><br><span class="line">      <span class="string">"overflow"</span>,</span><br><span class="line">      <span class="string">"overflow-x"</span>,</span><br><span class="line">      <span class="string">"overflow-y"</span>,</span><br><span class="line">      <span class="string">"clip"</span>,</span><br><span class="line">      <span class="string">"clear"</span>,</span><br><span class="line">      <span class="string">"font"</span>,</span><br><span class="line">      <span class="string">"font-family"</span>,</span><br><span class="line">      <span class="string">"font-size"</span>,</span><br><span class="line">      <span class="string">"font-smoothing"</span>,</span><br><span class="line">      <span class="string">"osx-font-smoothing"</span>,</span><br><span class="line">      <span class="string">"font-style"</span>,</span><br><span class="line">      <span class="string">"font-weight"</span>,</span><br><span class="line">      <span class="string">"line-height"</span>,</span><br><span class="line">      <span class="string">"letter-spacing"</span>,</span><br><span class="line">      <span class="string">"word-spacing"</span>,</span><br><span class="line">      <span class="string">"color"</span>,</span><br><span class="line">      <span class="string">"text-align"</span>,</span><br><span class="line">      <span class="string">"text-decoration"</span>,</span><br><span class="line">      <span class="string">"text-indent"</span>,</span><br><span class="line">      <span class="string">"text-overflow"</span>,</span><br><span class="line">      <span class="string">"text-rendering"</span>,</span><br><span class="line">      <span class="string">"text-size-adjust"</span>,</span><br><span class="line">      <span class="string">"text-shadow"</span>,</span><br><span class="line">      <span class="string">"text-transform"</span>,</span><br><span class="line">      <span class="string">"word-break"</span>,</span><br><span class="line">      <span class="string">"word-wrap"</span>,</span><br><span class="line">      <span class="string">"white-space"</span>,</span><br><span class="line">      <span class="string">"vertical-align"</span>,</span><br><span class="line">      <span class="string">"list-style"</span>,</span><br><span class="line">      <span class="string">"list-style-type"</span>,</span><br><span class="line">      <span class="string">"list-style-position"</span>,</span><br><span class="line">      <span class="string">"list-style-image"</span>,</span><br><span class="line">      <span class="string">"pointer-events"</span>,</span><br><span class="line">      <span class="string">"cursor"</span>,</span><br><span class="line">      <span class="string">"background"</span>,</span><br><span class="line">      <span class="string">"background-color"</span>,</span><br><span class="line">      <span class="string">"border"</span>,</span><br><span class="line">      <span class="string">"border-color"</span>,</span><br><span class="line">      <span class="string">"border-radius"</span>,</span><br><span class="line">      <span class="string">"box-shadow"</span>,</span><br><span class="line">      <span class="string">"content"</span>,</span><br><span class="line">      <span class="string">"outline"</span>,</span><br><span class="line">      <span class="string">"outline-offset"</span>,</span><br><span class="line">      <span class="string">"opacity"</span>,</span><br><span class="line">      <span class="string">"filter"</span>,</span><br><span class="line">      <span class="string">"visibility"</span>,</span><br><span class="line">      <span class="string">"size"</span>,</span><br><span class="line">      <span class="string">"transition"</span>,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>事件绑定函数命名规范</li>
</ol>
<p>采用小驼峰命名法.</p>
<ul>
<li>开头: 自身实现前缀 handle, 组件暴露出来的前缀 on</li>
<li>中间模块名称: 如: Cell、Item、Title 等</li>
<li>尾部事件名称: 如: Click、TouchMove、Change 等</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleCellClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"handleCellClick"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">   &lt;ListCell onCellClick=&#123;handleCellClick&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自定义函数命名规范</li>
</ol>
<p>采用小驼峰命名法, 见名知意, 通过函数名来知道意义.</p>
<ul>
<li>校验类: check 开头</li>
<li>处理类: deal 开头</li>
<li>方法类: process 开头</li>
<li>格式化类: format 开头</li>
<li>渲染类: render 开头</li>
</ul>
<ol start="4">
<li>组件命名规范</li>
</ol>
<p>采用大驼峰命名法. 使用名词开头, 后接形容词. 如:</p>
<ul>
<li>ListSelect（实现可选择的列表）</li>
<li>ModuleTitle（拥有标题的模块）</li>
<li>PanelBottom（位于底部的面板）</li>
</ul>
<ol start="5">
<li>css 样式命名规范</li>
</ol>
<p>采用小驼峰命名法. 每个 class 中间要空一行,且注释不要使用双斜杠,而应使用 <code>/**/</code>如:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.pageWrap</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pageContent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.page-wrap</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.page-content</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>路由传值</li>
</ol>
<p>由于路由传值都被转为 string 类型. 传值 undefined, false, true 等歧义变量, 很容易引发隐蔽性 bug.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`/pages/Index/index?isAdmin=false&amp;isOwner=true`</span> <span class="comment">// bad</span></span><br><span class="line"><span class="string">`/pages/Index/index?role=owner`</span>; <span class="comment">// good</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>封装方法传入的参数尽量是对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">dealDateInfo(data, show, tip, success);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">  data: <span class="string">"1"</span>,</span><br><span class="line">  show: <span class="literal">true</span>,</span><br><span class="line">  tip: <span class="number">99</span>,</span><br><span class="line">  success: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">dealDateInfo(params);</span><br></pre></td></tr></table></figure>

<p>如果一个函数需要多个参数实现其逻辑, 尽量将这些参数组成一个对象.<br>这样的好处在于:</p>
<p>a) 方便定义类型.<br>b) 如果部分参数是非必传的情况, 方便处理.<br>c) 对于编译器减少 push 函数参数的操作</p>
<p>不过要注意, 通过对象入参, 会让参数变为引用传参,<br>在函数内切记不要直接修改入参的值, 否则会改变入参的原数据, 以免引发其他问题.</p>
<h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><ol>
<li>import 书写顺序</li>
</ol>
<p>a) 首先引入第三方库<br>b) 次之引入设置别名的绝对路径<br>c) 最后引入相对路径</p>
<p>而同级则以引入库的字母顺序排列.</p>
<p>引用公共组件/公共方法应当使用<code>别名路径</code>或者<code>绝对路径</code>,<br>专属于自己组件的引用文件可考虑使用相对路径.</p>
<p>严禁如: <code>../../../../../../../xxx.js</code></p>
<ol start="2">
<li><p>类开发内书写顺序</p>
<ol>
<li><p>优先书写变量相关</p>
<ol>
<li>优先书写 构造函数: 自定义变量</li>
<li>其次书写 state、data 的定义</li>
<li>次之书写 computed</li>
<li>最后书写 watch</li>
</ol>
</li>
<li><p>次之书写函数相关</p>
<ol>
<li>优先书写 methods</li>
<li>其次书写 events 等自定义事件</li>
<li>次之书写 生命周期</li>
<li>最后书写自定义函数</li>
</ol>
</li>
<li><p>如为 tsx 文件</p>
<ol>
<li>自定义 render 函数</li>
<li>返回的 render 函数</li>
</ol>
</li>
</ol>
</li>
<li><p>TSX 文件书写顺序（待实践）</p>
<ol>
<li>自定义变量</li>
<li>自定义函数</li>
<li>生命周期</li>
<li>绑定事件函数</li>
<li>渲染函数</li>
<li>主渲染函数</li>
</ol>
<p>详细:</p>
<ol>
<li>useRouter</li>
<li>useRef</li>
<li>useState</li>
<li>useMemo</li>
<li>自定义变量</li>
<li>自定义方法</li>
<li>useDidShow</li>
<li>useEffect</li>
<li>usePullDownRefresh</li>
<li>useReachBottom</li>
<li>handleXXX 绑定事件</li>
<li>renderXXX 渲染函数</li>
<li>render return() 主渲染函数</li>
</ol>
</li>
<li><p>善用 CSS 变量 / CSS 原子化</p>
<p>颜色、字号、边距、边角已经有规定尺寸, 常规情况下, 不要直接去写数值. 会造成 UI 风格不一致.</p>
</li>
<li><p>数据管理</p>
<p>前端要有自己的数据管理能力.<br>由于组件设计过程中, 组件内的变量命名应该是抽象的.<br>那么在接口获取数据之后,<br>都需要将得到的数据, 转换为组件内对应的变量位置装好.<br>这样, 数据处理位置比较居中, 同时也能倒逼设计组件更加抽象化.</p>
</li>
<li><p>生命周期的运用(仅参考, 根据具体业务来运用)</p>
<ol>
<li><code>useEffect</code>, 只用来处理变量</li>
<li><code>useDidShow</code>, 用来请求接口数据</li>
</ol>
</li>
<li><p>组件抽象化<br>在组件的设计过程中, 组件内的变量命名应该是抽象的. 不要把轻易业务变量丢到组件内部. （除非放弃该组件的复用性）</p>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务需求: 处于某某身份则展示编辑按钮</span></span><br><span class="line"><span class="comment">// 组件内的展示逻辑: 纯粹跟他是否应当展示有关, 而不是在组件内部还去关注他是什么身份.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">&lt;Header isGM=&#123;<span class="literal">true</span>&#125; isAM=&#123;<span class="literal">false</span>&#125; isBM=&#123;<span class="literal">false</span>&#125; isCM=&#123;<span class="literal">true</span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">&lt;Header isShowEdit=&#123;<span class="literal">true</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>可自闭合标签, 采取自闭合方式书写</li>
</ol>
<p>为防止标签内的内容过多时, 闭合标签匹配混乱的问题.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">&lt;Video&gt;&lt;<span class="regexp">/Video&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ good</span></span><br><span class="line"><span class="regexp">&lt;Video /</span>&gt;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>标签属性书写顺序</li>
</ol>
<p>应当按照以下给出的顺序依次排列, 确保代码的易读性<br>a) class<br>b) id, name<br>c) data-_<br>d) src, for, type, href, value<br>e) title, alt<br>f) role, aria-_</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">  className=<span class="string">"imgContent"</span></span><br><span class="line">  id=<span class="string">"img_apple"</span></span><br><span class="line">  data-info=<span class="string">"aaa"</span></span><br><span class="line">  src=<span class="string">"../aa/bb/cc/dd.jpg"</span></span><br><span class="line">  title=<span class="string">"图片"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>switch 的相关操作</li>
</ol>
<p>一定要有 default 的情况作为兜底,<br>每个 case 的作用域应当一定要被大括号包裹, 以免变量声明提前导致一些隐形 bug.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> test1 = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">999</span>;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"case 1: a = "</span>, a); <span class="comment">// 直接飘红报错, 暂时性死区</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">const</span> a = <span class="number">8</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"case 2: a ="</span>, a); <span class="comment">// 可以正常输出 case 2: a = 8</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> test2 = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">999</span>;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"case 1: a = "</span>, a); <span class="comment">// 可以正常输出 case 1: a = 999</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> a = <span class="number">8</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"case 2: a ="</span>, a); <span class="comment">// 可以正常输出 case 2: a = 8</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="套路场景"><a href="#套路场景" class="headerlink" title="套路场景"></a>套路场景</h3><ol>
<li>多条件判断可配置化</li>
</ol>
<p>简单判断可如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  strMySelfRole === <span class="string">"GM"</span> ||</span><br><span class="line">  strMySelfRole === <span class="string">"DM"</span> ||</span><br><span class="line">  strMySelfRole === <span class="string">"AM"</span></span><br><span class="line">) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="string">"GM"</span>, <span class="string">"DM"</span>, <span class="string">"AM"</span>].includes(strMySelfRole)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂判断可如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TAB_LIST = [</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">"APPLE"</span>, <span class="comment">// 业务所需字段</span></span><br><span class="line">    title: <span class="string">"Apple"</span>, <span class="comment">// 业务所需字段</span></span><br><span class="line">    <span class="comment">// APPLE 展示规则: 不存在 supportRules 字段, 默认就会展示</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">"BANANA"</span>,</span><br><span class="line">    title: <span class="string">"Banana"</span>,</span><br><span class="line">    <span class="comment">// BANANA 展示规则: 如果 isAM 是 true 则展示; 或者 nBM 是 100 或 200 则展示; 或者 isAM 是 false 并且 strCM 是 ok 或 sure 则展示;</span></span><br><span class="line">    supportRules: [</span><br><span class="line">      &#123;</span><br><span class="line">        isAM: [<span class="literal">true</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        nBM: [<span class="number">100</span>, <span class="number">200</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        isAM: [<span class="literal">false</span>],</span><br><span class="line">        strCM: [<span class="string">"ok"</span>, <span class="string">"sure"</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   type: <span class="string">"CHERRY"</span>,</span><br><span class="line">   title: <span class="string">"Cherry"</span>,</span><br><span class="line">   <span class="comment">// CHERRY 展示规则: 即为自定义函数的返回值</span></span><br><span class="line">    supportRules: <span class="function">(<span class="params">matchRules</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; isAM, nBM, strCM, arrDM, objEM &#125; = matchRules || &#123;&#125;;</span><br><span class="line">      <span class="keyword">return</span> !!objEM?.a &amp;&amp; nBM &gt; <span class="number">1.23</span> &amp;&amp; nBM &lt; <span class="number">12.34</span> &amp;&amp; arrDM.includes(<span class="string">"happy"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">"ORANGE"</span>,</span><br><span class="line">    title: <span class="string">"Orange"</span>,</span><br><span class="line">    <span class="comment">// ORANGE 的展示规则: 不符合合法规则, 不予展示</span></span><br><span class="line">    supportRules: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> updateTabList = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; aDetail, bDetail, cDetail, dDetail &#125; = params || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> &#123; am &#125; = aDetail || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> &#123; bm &#125; = bDetail || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> &#123; cm &#125; = cDetail || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> &#123; dm &#125; = dDetail || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> &#123; em &#125; = eDetail || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> matchRules = &#123;</span><br><span class="line">    isAM: am, <span class="comment">// boolean</span></span><br><span class="line">    nBM: bm, <span class="comment">// number</span></span><br><span class="line">    strCM: cm, <span class="comment">// string</span></span><br><span class="line">    arrDM: dm, <span class="comment">// array</span></span><br><span class="line">    objEM: em, <span class="comment">// object</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tabList = TAB_LIST.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如不存在 supportRules 字段, 默认就会展示</span></span><br><span class="line">    <span class="keyword">if</span> (item.supportRules === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如 supportRules 字段是函数, 则按照规则(数组为`或`逻辑, 对象为`与`逻辑)展示</span></span><br><span class="line">    <span class="keyword">if</span> (item.supportRules) &#123;</span><br><span class="line">      <span class="keyword">return</span> item.supportRules.some(<span class="function">(<span class="params">rule: any</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(rule).every(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> rule[key].includes(nowRule[key]);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如 supportRules 字段是函数, 则按照该函数返回值展示</span></span><br><span class="line">    <span class="keyword">if</span> (item.supportRules) &#123;</span><br><span class="line">      <span class="keyword">return</span> item.supportRules.some(<span class="function">(<span class="params">rule: any</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(rule).every(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> rule[key].includes(nowRule[key]);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 兜底情况, 则不展示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tabList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后期只需要维护 TAB_LIST 常量数组的配置,<br>不再需要调整 updateTabList 方法,<br>即可清晰应对每一项的调整需求.</p>
<p>另外, 一般不要在带代码中直接去使用常量,<br>建议将所有的常量抽出来, 统一整理到一个 config.js 文件中,</p>
<p>同时遵循<code>开闭原则</code>, 即对于功能的扩展是开放的, 对功能的修改是关闭的.<br>即使新增需求, 也不需要去改动老代码.<br>以提高其拓展性和可维护性.<br>方便后续需求变动的时候, 能够快捷找到对应的位置.</p>
<ol start="2">
<li>复杂条件渲染场景</li>
</ol>
<p>通过抽象枚举值, 善用表驱动法, 实现条件渲染.<br>不过要注意的是, key 值要保证是已有字段, 不然无法渲染.<br>例如:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderPageContent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    VPEmpty: <span class="xml"><span class="tag">&lt;<span class="name">VPEmpty</span> <span class="attr">pageInfo</span>=<span class="string">&#123;objTabBarCurrent&#125;</span> /&gt;</span></span>,</span><br><span class="line">    VPHome: <span class="xml"><span class="tag">&lt;<span class="name">VPHome</span> <span class="attr">pageInfo</span>=<span class="string">&#123;objTabBarCurrent&#125;</span> /&gt;</span></span>,</span><br><span class="line">    VPHomeCarbon: <span class="xml"><span class="tag">&lt;<span class="name">VPHomeCarbon</span> <span class="attr">pageInfo</span>=<span class="string">&#123;objTabBarCurrent&#125;</span> /&gt;</span></span>,</span><br><span class="line">    VPMine: (</span><br><span class="line">      &lt;VPMine</span><br><span class="line">        pageInfo=&#123;objTabBarCurrent&#125;</span><br><span class="line">        mineMemberEditRefresh=&#123;mineMemberEditRefresh&#125;</span><br><span class="line">        onMineMemberEditClick=&#123;handleMineMemberEditClick&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    ),</span><br><span class="line">    VPNew: <span class="xml"><span class="tag">&lt;<span class="name">VPNew</span> <span class="attr">pageInfo</span>=<span class="string">&#123;objTabBarCurrent&#125;</span> /&gt;</span></span>,</span><br><span class="line">    VPNull: <span class="xml"><span class="tag">&lt;<span class="name">VPNull</span> <span class="attr">pageInfo</span>=<span class="string">&#123;objTabBarCurrent&#125;</span> /&gt;</span></span>,</span><br><span class="line">  &#125;[code || <span class="string">"VPNull"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>复杂场景权限校验</li>
</ol>
<p>简单逻辑情况, 可以通过“与”运算符实现.<br>复杂逻辑的情况, 可通过装饰器模式、自定义指令、高阶函数或者 hook, 对业务逻辑进行装饰.<br>达成目的是, 降低耦合, 校验逻辑、业务逻辑互相不会污染.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Permission strCheckPosition=&#123;<span class="string">"LEADER"</span>&#125;&gt;</span><br><span class="line">  &lt;View&gt;Leader Content&lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Permission&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>减少冗余的变量声明</li>
</ol>
<p>对变量的声明尽量精简.<br>不要多个变量去控制一个事物的状态,<br>声明越多的变量, 需要维护的成本就会越大.</p>
<p>比如新建 / 编辑等场景:</p>
<p>组件传参只需要传递 id 即可,<br>是新增还是编辑通过判断 id 是否传值即可.<br>如果有 id 则说明是编辑场景, 没有则说明是新建场景。</p>
<p>这样即可少维护一个冗余字段</p>
<ol start="5">
<li>组件的抽象实现</li>
</ol>
<p>为保证组件的复用性, 对暴露出来的方法要遵循<code>单一职责原则</code><br>保证方法的高内聚, 不要携带其他副作用.<br>比如, tab 切换组件返回的事件, 应当只是纯粹的告诉调用者（父组件）, tab 的哪一项被点击,<br>至于被点击之后的处理逻辑, 应由调用者（父组件）去实现.<br>业务逻辑不在组件内实现的好处, 在于方便在其他位置复用该组件样式.</p>
<p>同时, 这也是遵循单向数据流, 数据由上向下，事件由下向上.<br>有助于简化数据的管理和状态的维护, 提高代码的可维护性和可预测性.</p>
<p>PS: 只有数据的拥有者，才能有资格修改这个数据（唯一责任人）</p>
<ol start="6">
<li>内聚业务逻辑</li>
</ol>
<p>把校验逻辑、限制逻辑其他杂七杂八的逻辑，尽量剥离在业务逻辑之外。让开发同学更专注于业务逻辑实现。</p>
<p>如：指令、装饰器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Debounce &#125; <span class="keyword">from</span> <span class="string">'@/utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">@Debounce(<span class="number">200</span>, &#123; <span class="attr">leading</span>: <span class="literal">false</span>, <span class="attr">trailing</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">handleBtnClick() &#123;</span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  <span class="comment">// if (role === 'MEMBER') &#123;</span></span><br><span class="line">  <span class="comment">//   return;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>判断以字符串开头/结尾</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否某字符串开头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">source</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">start</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> startsWith = <span class="function">(<span class="params">source, start</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> source.slice(<span class="number">0</span>, start.length) === start;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否某字符串结尾</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">source</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">end</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> endsWith = <span class="function">(<span class="params">source, end</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> source.indexOf(end, source.length - end.length) !== <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>返回跳转问题</li>
</ol>
<p><code>Close</code> 按钮是 back 还是 navigateTo ?</p>
<p>个人倾向于是使用 back,<br>优势在于: 因为这样操作的路由栈是纯粹的, 不会因为魔改而污染路由栈.<br>比如点击左上角返回, 或者移动端手势操作返回的时候, 都不会有影响.</p>
<p>缺点在于: 如果是通过外链, 直接跳转到该页面, 那么就需要判断.<br>此时的关闭是返回外链来源页面, 还是返回自身应用的首页.<br>需要单独用代码来处理. (或者通过携带参数, 来做判断处理)</p>
<ol start="8">
<li>Dropdown 下拉菜单实现</li>
</ol>
<p>下拉菜单的触发区, 尽量采用 listPopup.length &gt; 0 来判断.<br>这样方便后续某些场景没有下拉菜单项的时候, 就自动不会展示下拉菜单触发区(如…),<br>这样也省心省力.</p>
<ol start="9">
<li>Select 的组件操作</li>
</ol>
<p>如果有条件的话, 在从接口拿到 value 对其进行初始化的时候,<br>可以考虑根据 options list 的数据(如不是分页加载)做一下筛选.</p>
<p>这样可以避免后端给出一些可能已经不存在于 options 的 value,<br>从而影响到前端的空值表单校验.</p>
<ol start="10">
<li>分页列表刷新场景</li>
</ol>
<p>下方加载中状态展示逻辑:<br>只要<code>当前数据数量</code>小于<code>数据数量总数</code>, 那就会一直展示(屏幕外也是如此)</p>
<p>如果滚动到底部, 触发请求分页操作.<br>请求分页操作做 请求锁 + 防抖处理.</p>
<p>如果当前请求页数不是第一页, 那么就拼接老列表数据.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MemberScoreList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoading = useRef(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> pageNum = useRef(<span class="number">0</span>); <span class="comment">// 页数</span></span><br><span class="line">  <span class="keyword">const</span> pageSize = useRef(<span class="number">15</span>); <span class="comment">// 分页数</span></span><br><span class="line">  <span class="keyword">const</span> pageTotalCount = useRef(<span class="number">999999</span>); <span class="comment">// 数据总数</span></span><br><span class="line">  <span class="keyword">const</span> [listScore, setListScore] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getList = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    isLoading.current = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> Api.Score.getList(&#123;</span><br><span class="line">      pageNum: pageNum.current,</span><br><span class="line">      pageSize: pageSize.current,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res?.body) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; totalCount = <span class="number">0</span>, list = [] &#125; = res?.body || &#123;&#125;;</span><br><span class="line">      pageTotalCount.current = totalCount;</span><br><span class="line">      <span class="keyword">const</span> listNew = <span class="function">(<span class="params">list || []</span>).<span class="params">map</span>(<span class="params">(item</span>) =&gt;</span> (&#123;</span><br><span class="line">        ...item,</span><br><span class="line">        createTimeStr: dayjs(item.sys_createTime).format(<span class="string">"YYYY-MM-DD HH:mm:ss"</span>),</span><br><span class="line">      &#125;));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> listOld = pageNum.current === <span class="number">0</span> ? [] : listScore;</span><br><span class="line"></span><br><span class="line">      setListScore(listOld.concat(listNew));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      isLoading.current = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="number">600</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> init = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    getQueryScoreList();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleRefreshScore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hanldePageScrollToLower = useDebounce(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (isLoading.current) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (listScore.length &gt;= pageTotalCount.current) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pageNum.current += <span class="number">1</span>;</span><br><span class="line">      getQueryScoreList();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">500</span>,</span><br><span class="line">    &#123; <span class="attr">leading</span>: <span class="literal">false</span>, <span class="attr">trailing</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;SAPageCore</span><br><span class="line">      isShowLoadingBottom=&#123;listScore.length &lt; pageTotalCount.current&#125;</span><br><span class="line">      renderPageHeader=&#123;() =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;View className=<span class="string">"flex flex-col"</span>&gt;</span><br><span class="line">            &lt;SANavHeader isShowBtnLeft title=<span class="string">"积分记录"</span> /&gt;</span><br><span class="line">          &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">      &#125;&#125;</span></span><br><span class="line"><span class="regexp">      onScrollToLower=&#123;hanldePageScrollToLower&#125;</span></span><br><span class="line"><span class="regexp">    &gt;</span></span><br><span class="line"><span class="regexp">      &lt;View className="relative box-border px-2 pb-2"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ListScore list=&#123;listScore&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>SAPageCore&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>善用 Promise.all 并行请求接口</li>
</ol>
<p>Promise.all 兼容性更好, Promise.allSettled 更安全.(注意返回值结构不一样)<br>另注意, Promise.all 如果其中一个异步操作抛出错误, 那么会全部直接返回.<br>如果为了避免该情况,<br>可以在每个异步处理中, 使用 try catch 进行包裹, 如果报错异常, 也去手动正常返回一个值, 即可避免该问题.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用接口 A，返回列表中每个数据的 name 字段全转换为大写，然后渲染到页面的 listA 上。</span></span><br><span class="line"><span class="comment">// 返回列表元素大于 1，则同时调用接口 B、接口 C，并将二者返回数据数组拼接成一个数组，赋值给 listResult 。</span></span><br><span class="line"><span class="comment">// 返回列表元素不大于 1，则只调用接口 D，并将返回数据赋值给 listResult 。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> queryList() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resA = <span class="keyword">await</span> queryA();</span><br><span class="line">    <span class="keyword">this</span>.listA = resA</span><br><span class="line">      ?.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item?.total &gt; <span class="number">80</span>)</span><br><span class="line">      .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...item,</span><br><span class="line">          label: item.name.toUpperCase(),</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.listA?.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> [resB = [], resC = []] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([queryB(), queryC()]);</span><br><span class="line">      <span class="keyword">this</span>.listResult = [...resB, ...resC];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.listResult = <span class="keyword">await</span> queryD();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> init() &#123;</span><br><span class="line">  <span class="keyword">await</span> queryList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>常见风险操作注意</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 obj 不是对象类型, 即会报错</span></span><br><span class="line"><span class="keyword">const</span> &#123; a, b, c &#125; = obj;</span><br><span class="line"><span class="comment">// 如果 obj 不是数组类型, 即会报错</span></span><br><span class="line"><span class="keyword">const</span> [x, y, z] = arr;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果接口返回的格式不是固定格式, 或者接口非200异常情况, 很可能就会解析报错</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  data: &#123; status, body, message &#125;,</span><br><span class="line">&#125; = <span class="keyword">await</span> queryList();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj如果存在循环引用, 即会报错</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str为非法可反序列化字符串, 即会报错</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(str);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr 可能是 undefined , 那么调用不存在的数组方法即会报错</span></span><br><span class="line">arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  item.a = <span class="number">1</span>; <span class="comment">// 内部偷偷把 arr 数据源修改了, 也可能会埋坑</span></span><br><span class="line">  <span class="keyword">return</span> item;</span><br><span class="line">&#125;);</span><br><span class="line">arr.filter(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">  <span class="comment">// 如果父组件异步获取 id, 传值给子组件,</span></span><br><span class="line">  <span class="comment">// 子组件在加载初始化的时候就使用 id , 那么有概率会因为 id 为空而导致报错</span></span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = <span class="keyword">this</span>.props || &#123;&#125;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ol>
<li><p>慎用 redux. 由于每次变化会触发全局刷新. 建议只存储唯一性的值.<br>a) redux 是响应式, 每次更新都会触发 diff 算法, 全局刷新渲染 DOM, 影响性能.<br>b) redux 是全局纬度, 其生命周期很难把握.<br>如果不做处理, 只是一味的存储, 不去主动销毁, 最终就会内存泄漏.<br>建议只存储全局唯一状态性的值. 如: 品牌、菜单列表等.</p>
<p>搞清楚数据纬度: 组件纬度、页面纬度、全局纬度.<br>各自纬度的数据, 存储到各自纬度中, 方便代码维护.</p>
</li>
<li><p>与渲染无关的数据尽量不要放在 state 中, 可以放在 useRef 中.<br>与渲染无关的数据尽量不要放在 state 中, 可以考虑放在 useRef 或 this 中.<br>每次渲染会对 state 对象进行遍历 diff 算法. 减少 state 的内容, 可提升渲染效率.<br>且对 useRef 和 this 的修改是同步的, 能处理一些需要属性及时生效的业务场景.</p>
</li>
<li><p>善用节流、防抖.<br>可对 usePageScroll 等场景装饰节流、对 input 的 value 变化场景装饰防抖.</p>
</li>
<li><p>封装组件的时候, 留意不要套多余无意义 View . 以免页面 DOM 层级太深, 影响渲染性能.<br>可适当用<code>&lt;Block&gt;</code>或者<code>&lt;Fragment&gt;</code>代替</p>
</li>
<li><p>Input 输入框跳位问题. 尽量不要对 Input 的 value 二次 setState.</p>
</li>
<li><p>尽量减少页面的跳转交互.<br>页面跳转体验奇差. 会有白屏闪现.<br>在业务能满足的情况下, 尽量单页去实现功能.<br>可提出建议反馈产品设计.</p>
</li>
<li><p>尝试页面处于 loading 状态时候使用骨架屏.</p>
</li>
<li><p>Input 的输入内容要进行 trim()处理.</p>
</li>
<li><p>点击等用户操作, 一定要有反馈效果.<br>比如: 适当的 loading / toast,<br>按钮灰度大小变化, 弹窗动画, 展开收起动画等.<br>这样不仅对用户友好, 也方便后续自身定位问题.</p>
</li>
<li><p>移动端点击区域要舒适.<br>不要太老实直接把事件绑定到 span / text 上面. 点击区域应适当放大一些, 以方便用户的操作.</p>
</li>
<li><p>sss</p>
</li>
</ol>
<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><ol>
<li>通过 jsDoc 完善 api 文档</li>
<li>通过 jscpd 判断代码重复率</li>
<li>工具化代码 review 平台</li>
<li>项目管理系统平台</li>
<li>自动化测试</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本篇部分内容为实际项目已经用到且取得相应成效的方法.<br>部分内容为个人见解尚在理论部分, 待实践.<br>项目规范是一个不断优化、不断完善的长期过程.<br>要做到因地制宜, 慢慢尝试, 找到最适合自己团队的方式,<br>这样才能真正提升团队开发效率.<br>我也会不断更新该篇文章.</p>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>22.公司产品同学的运营实践分享有感</title>
    <url>/2021/01/15/22-%E5%85%AC%E5%8F%B8%E4%BA%A7%E5%93%81%E5%90%8C%E5%AD%A6%E7%9A%84%E8%BF%90%E8%90%A5%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<h3 id="书写背景"><a href="#书写背景" class="headerlink" title="书写背景"></a>书写背景</h3><p>随着代码越写越多，<br>感觉要想成为一名合格的程序猿，<br>不能仅仅是一味低头的当一个“码农”，<br>偶尔也得尝试抬起头看看隔壁产品同学的日常。<br>搞清楚产品的工作思路，也能把握自身的代码开发方向。<br>（就好像要把握出题者的意图，答题才能更顺手的感觉~）<br>正逢赶上公司的产品大佬分享，<br>抽出身子过去赶紧学习一波。</p>
<a id="more"></a>

<h3 id="分享内容"><a href="#分享内容" class="headerlink" title="分享内容"></a>分享内容</h3><p>这次分享会，主要分享了四点内容：</p>
<ol>
<li><p>过往创业背景</p>
<p>讲述了大佬的的创业经历，从一个只有 2 个人的团队，做到拿到 A 轮融资 500w 的一个小企业的过程（需要有个好看的 PPT）。<br>其中也并不是产品一次成型，每个方向都在不断试探，不断试错。<br>将客户首先定位在大学生群体，外卖，兼职，帮帮等等，<br>最后针对招聘这个方向开始重点发力。</p>
</li>
<li><p>创业中产品工作问题&amp;解决</p>
<p>期间拒绝阿里的 B 轮融资方案。最后只把希望寄托在一个客户机构上，没有 plan B，最后由于意外，导致最后资金链断裂，失败落幕。<br>所得的经验教训就是不能把企业的生死存亡寄托在其他人身上，在没有实锤之前，都给自己留一条后路。</p>
</li>
<li><p>产品常见错误</p>
<p>大佬总结之下大概分为 6 点：</p>
<ol>
<li><p>自嗨。<br>产品在想需求的过程中，有时候会自我感觉良好。<br>灵光一闪想到个 idea，感觉有了这个玩法，产品瞬间可以逆风翻盘，感动自己。<br>其实越兴奋的时候，越要冷静。<br>正常来说，产品可以说是在部门里话语权优先级很高的。<br>如果不做深思熟虑，只是拍脑门之下，研发便投入开发，销售开始地推，<br>最后很可能客户反应冷淡，远远没有达到预期，无形浪费成本。</p>
</li>
<li><p>一言堂。<br>一般是有绝对话语权的人易犯的错误。<br>很可能其他人都不统一他的观点，<br>这个时候他声音大，<br>其他人抱着不想和他争，抱着要不做着看看效果的心态敷衍了事，<br>最后出来的效果也未必会好。</p>
</li>
<li><p>节奏感<br>产品要有自身的节奏感。<br>对于产品方向和思路的把控，这是一个合格产品应该具备的条件。<br>那么如何带出产品的节奏感，这个是一个优秀产品的必备条件。</p>
</li>
<li><p>龟毛<br>强迫症发作，过度于纠结细致的东西，却失去了把控大局的思路。<br>比如这个按钮的位置。<br>高几像素还是矮几像素不会太影响大局，客户不会因为这个按钮歪了一点就不去使用我们的产品。<br>客户只会因为这个产品不好用，没办法解决自身痛点而放弃使用产品。</p>
</li>
<li><p>脱离客户<br>由于客户的需求是一个动态的，甚至客户自身都不知道他需要什么。<br>所以就需要做到经常去跟客户沟通。<br>如果做不到两周跟客户有过沟通，那就意味着已经脱离了客户。<br>既然都不知道客户的最新需求，自然就没办法做出打动客户的产品。</p>
</li>
<li><p>经验主义<br>这是一般老产品会犯下的错误。<br>一看到有类似场景，那么直接就想起之前做过的案例。<br>拿出以前的方案，直接生搬硬套，没有做到因地制宜。<br>所以结果也不会很乐观的。</p>
</li>
</ol>
</li>
<li><p>产品运营紧密协同</p>
<p>产品需求设计过程中，不是一个单向的流动，应该是双向的，也是需要有反馈的。<br>通过对产品功能的埋点，进而对客户的行为数据收集分析，<br>推测客户行为，通过数据驱动，进而推出下一步的方案。<br>以产品推销 VIP 会员为例。<br>强制蒙层弹窗可能大部分人看都不看直接叉掉，销售效果未必好。<br>通过后台的客户行为分析，在用户观看较多的页面，放置对应会员 VIP 的广告，<br>以及分批发放试用 VIP。<br>观察有试用 VIP 与没有使用 VIP 客户的行为差别。<br>观察 VIP 是否能够让客户感受得到便利。<br>进而对 VIP 的付费内容，以及推广策略进行调整。</p>
</li>
</ol>
<h3 id="会下交流"><a href="#会下交流" class="headerlink" title="会下交流"></a>会下交流</h3><p>创业公司的合伙人需要分工明确。<br>创立公司之初的团队组成。<br>设计产品，要保持初心。<br>代码会写出 bug，产品需求也会有 bug，所以需求有变动其实是可以理解的。</p>
<h3 id="所思所得"><a href="#所思所得" class="headerlink" title="所思所得"></a>所思所得</h3><p>听完这次分享会之后，<br>感觉目前公司的项目还是有很多地方需要优化的。<br>至少很多细节地方都没有打磨。<br>单就目前的每个版本的流程来说，就是一个单向流，<br>从市场销售捕获客户痛点，产品转化为需求，设计出稿，需求评审，技术评审，正式开发，验收转测，最后提审上线。<br>然后这样就结束了。<br>这一套流程下来，最后到客户手里反馈如何，却不了了之。<br>如何改善，也都是自身在凭空想象。</p>
<p>同时，埋点是一个项目很必备的功能。<br>从代码层级上来看，<br>如果每个地方到处复制粘贴，以后管理必将是一件麻烦事。<br>那么如何优雅的实现这个功能，<br>也是需要我们去思量的。</p>
<p>再就是在版本迭代的过程中，<br>新增功能是一个很容易的事情，不过更多考虑的是如何提高体验。<br>同样都能解决客户的痛点，<br>一个方案需要点 3 次，一个方案只需要点 2 次。<br>这样给客户带来的体验是完全不同的。</p>
<p>另外，要善于做减法。<br>把每一个做出来的功能都当成个宝贝一样保留着，最后只会让项目臃肿不堪。<br>其实对于已经通过客户行为数据验证过，对客户没有太大帮助的功能，是完全可以下掉删除的，<br>好的功能就全力发扬，不好的功能果断放弃。<br>这样既可以避免分散客户的注意力，也能提高自身产品的性能，从而提高用户体验。</p>
]]></content>
      <tags>
        <tag>产品运营</tag>
      </tags>
  </entry>
  <entry>
    <title>2.微信小程序BLE蓝牙连接智能硬件流程</title>
    <url>/2020/06/18/2-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FBLE%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="BLE-蓝牙连接智能硬件流程"><a href="#BLE-蓝牙连接智能硬件流程" class="headerlink" title="BLE 蓝牙连接智能硬件流程"></a>BLE 蓝牙连接智能硬件流程</h3><p>微信小程序蓝牙模块只支持 BLE，通常说的蓝牙 4.0（及以上版本）。<br>特点在于低功耗，高速率，距离短，数据量小，以字节流传输。</p>
<p>可以通过手机下载对应 APP 应用来模拟被连接的硬件设备</p>
<ul>
<li>iOS lightblue</li>
<li>Android BLE 调试宝</li>
</ul>
<a id="more"></a>

<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.startBluetoothDevicesDiscovery.html" target="_blank" rel="noopener">微信小程序蓝牙官方文档</a></p>
<h3 id="通讯流程"><a href="#通讯流程" class="headerlink" title="通讯流程"></a>通讯流程</h3><ol>
<li>初始化蓝牙适配器。</li>
<li>搜索蓝牙设备获取设备 UUID(deviceId)。（占用资源较多，不搜索要及时停止搜索）（另部分安卓机可能需要获取位置权限才能搜索到蓝牙设备）</li>
<li>配对绑定设备，建立连接。</li>
<li>通过设备 UUID(deviceId)，获取该设备的设备所有服务(services)。</li>
<li>通过设备 UUID(deviceId)、服务 UUID(serviceId)，获取蓝牙设备指定服务的所有特征值(characteristic)。</li>
<li>通过特征值(characteristic)的属性，获取该特征值的读、写、广播权限。</li>
<li>通过设备 UUID(deviceId)、服务 UUID(serviceId)、特征值 UUID(characteristicId)，来对该特征值进行读写操作。（传输类型只支持 ArrayBuffer）</li>
<li>通过监听特征值的回调，获取特征值的变化情况。进而实现小程序蓝牙与智能硬件设备的通讯。</li>
<li>由于 BLE 低功耗蓝牙的连接非常不稳定。比如：比如刚连接上就断开、连接成功之后传输数据随机断开等情况。所以要做好断线重连等底层通讯异常的对应处理。</li>
</ol>
<h3 id="参数示意图"><a href="#参数示意图" class="headerlink" title="参数示意图"></a>参数示意图</h3><p><img src="../../../../images/image_2_1.jpg" alt="参数示意图"></p>
<h3 id="蓝牙常用-API-及返回值"><a href="#蓝牙常用-API-及返回值" class="headerlink" title="蓝牙常用 API 及返回值"></a>蓝牙常用 API 及返回值</h3><ol>
<li>初始化蓝牙适配器<br>wx.openBluetoothAdapter</li>
<li>开始搜寻附近的蓝牙外围设备<br>wx.startBluetoothDevicesDiscovery</li>
<li>获取搜索发现到的蓝牙设备的具体信息<br>wx.onBluetoothDeviceFound<br>返回值：<br>信号强度：RSSI: number,<br>该设备启动服务的 UUID：advertisServiceUUIDs: array,<br>设备 UUID：deviceId: string,<br>设备名称：localName: string,<br>设备名称：name: string,<br>serviceData: array object</li>
<li>通过设备 UUID(deviceId)，来连接对应的设备。<br>wx.createBLEConnection<br>若小程序在之前已有搜索过某个蓝牙设备，并成功建立连接，可直接传入之前搜索获取的 deviceId 直接尝试连接该设备，无需进行搜索操作。</li>
<li>通过设备 UUID(deviceId)，获取指定蓝牙设备所有服务(service)<br>wx.getBLEDeviceServices<br>返回值：<br>设备 UUID：deviceId: string,<br>开启的服务列表：service: array,</li>
<li>通过设备 UUID(deviceId)和服务 UUID(serviceId)，获取蓝牙设备指定服务的所有特征值(characteristic)。<br>wx.getBLEDeviceCharacteristics<br>返回值：<br>设备 UUID：deviceId: string,<br>服务 UUID：serviceId: string,<br>特征值列表：characteristic: array object<br>特征值 UUID：characteristic[0].uuid<br>该特征值是否支持 read 操作：characteristic[0].properties.read<br>该特征值是否支持 write 操作：characteristic[0].properties.write<br>该特征值是否支持 notify 操作：characteristic[0].properties.notify<br>该特征值是否支持 indicate 操作：characteristic[0].properties.indicate</li>
<li>开启 notify。必须先启用 notifyBLECharacteristicValueChange 接口才能接收到设备推送的 notification<br>wx.notifyBLECharacteristicValueChange</li>
<li>监听低功耗蓝牙设备的特征值变化<br>wx.onBLECharacteristicValueChange<br>返回值：<br>设备 UUID：deviceId: string,<br>服务 UUID：serviceId: string,<br>特征值 UUID：characteristicId: string,<br>特征值: value: ArrayBuffer,</li>
<li>发送数据到设备中<br>wx.writeBLECharacteristicValue</li>
<li>关闭蓝牙模块。<br>wx.closeBluetoothAdapter</li>
<li>停止搜寻附近的蓝牙外围设备。<br>wx.stopBluetoothDevicesDiscovery</li>
</ol>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="../../../../assets/assets_2_1.wpy">基于 Wepy 的示例</a></p>
]]></content>
      <categories>
        <category>projects</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>24.Taro多端开发之RN踩坑记录</title>
    <url>/2021/06/21/24-Taro%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B9%8BRN%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="折腾背景"><a href="#折腾背景" class="headerlink" title="折腾背景"></a>折腾背景</h3><p>前几天偶尔跟虎爷聊天，<br>“…App 才显得高端，小程序看起来就 low…”<br>于是乎心中萌生了去研究一波 RN 的想法。<br>作为一个程序猿，还是应该对技术时刻准备奔赴山海，保持热爱的。<br>Taro 这么一个可以实现跨端的框架，结果我却天天只去用来写微信小程序，实在是有些可惜。<br>不过，配置这个恶心的环境真的是太痛苦了，用了 2 天的时间疯狂踩坑。<br>把遇到的问题整理一波。</p>
<a id="more"></a>

<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">➜ ~ nvm -v</span><br><span class="line"><span class="number">0.38</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">➜ ~ node -v</span><br><span class="line">v14<span class="number">.17</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">➜ ~ npm -v</span><br><span class="line"><span class="number">6.14</span><span class="number">.13</span></span><br><span class="line"></span><br><span class="line">➜ ~ yarn -v</span><br><span class="line"><span class="number">1.22</span><span class="number">.17</span></span><br><span class="line"></span><br><span class="line">➜ ~ taro -v</span><br><span class="line">👽 Taro v3<span class="number">.3</span><span class="number">.13</span></span><br><span class="line"></span><br><span class="line">➜ ~ pod --version</span><br><span class="line"><span class="number">1.11</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line"># 提前安装好 cocoapods</span><br><span class="line">➜ ~ brew install cocoapods</span><br><span class="line"># 或者使用gem</span><br><span class="line">➜ ~ sudo gem</span><br><span class="line"># M1芯片需要再执行下条语句</span><br><span class="line">➜ ~ sudo arch -x86_64 gem install ffi</span><br><span class="line"></span><br><span class="line"># 提前安装XCode并更新至最新版本，并手动先启动一次XCode，同意相关条款</span><br><span class="line"># 如果最新版本XCode依赖最新系统，则更新MacOS至最新系统</span><br><span class="line">➜ ~ sudo xcode-select --<span class="keyword">switch</span> /Applications/Xcode.app</span><br></pre></td></tr></table></figure>

<h3 id="踩坑步骤"><a href="#踩坑步骤" class="headerlink" title="踩坑步骤"></a>踩坑步骤</h3><ol>
<li>新建工程。<br>Taro 3.3.3 版本起支持了模板集成 RN 的模式，不用采取业务代码一套项目，RN 外壳一套项目了，还是比较有爱。<br>Taro 3.3.13 版本又支持了 Github Action 的 CI，每次 master 分支有改动，或者打 v 开头的 tag 就会触发打包集成，还是蛮舒适的。</li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Taro项目</span></span><br><span class="line">taro init SmartApp</span><br><span class="line"><span class="string">...</span></span><br><span class="line">选择 react-native 模板</span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>项目安装</li>
</ol>
<p>在<code>yarn upgradePeerdeps</code>这一步就卡了很久。<br>本质上就是会在 ios 目录下，执行了<code>pod install</code>。<br>不过多方面原因，<br>有的是没有安装 XCode 情况，会在安装 glog 时候报错；此时安装 XCode，并手动先启动一次 XCode 同意相关条款即可。<br>有的是单纯 github 网络问题，提示连接超时，克隆失败；这个就只能多试几次，要么更改网络环境配置，具体下面的参考文档。<br>如果出现以下字样即为安装成功。<br><code>Pod installation complete! There are 40 dependencies from the Podfile and 28 total pods installed.</code></p>
<p>在<code>yarn ios</code>阶段就是本地打个包，然后启动 XCode 的模拟器。<br>报错 Command PhaseScriptExecution failed with a nonzero exit code. 这个是设备的版本太新，采用老版本模拟器就好，具体下面的参考文档。</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">cd SmartApp</span><br><span class="line"></span><br><span class="line"><span class="meta"># 更新相关依赖。在初始化完成后或 Taro 版本更新后执行，用于同步 peerDependencies。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">$ yarn upgradePeerdeps</span><br><span class="line"></span><br><span class="line"><span class="meta"># 打包 js bundle 及静态资源。在初始化完成后执行，用于打包默认使用的 bundle。platform 可选 ios, android</span></span><br><span class="line">$ yarn build:rn --platform ios</span><br><span class="line"></span><br><span class="line"><span class="meta"># 启动 bundle server</span></span><br><span class="line">$ yarn start</span><br><span class="line"></span><br><span class="line"><span class="meta"># 启动 iOS</span></span><br><span class="line">$ yarn ios</span><br><span class="line"></span><br><span class="line"><span class="meta"># 启动安卓</span></span><br><span class="line">$ yarn android</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Taro 新增的 Taro Playground APP 进行调试</li>
</ol>
<p>开发者仅需要正常运行 JS 工程，通过这个 APP,<br>扫<code>yarn start</code>阶段出现二维码即可进行调试。</p>
<ol start="4">
<li>如果没有正常启动 Metro Server，可以手动新开终端去启动。如果启动 Metro Server 成功则跳过此步骤。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">react-native start --port 8082</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>访问本地触发对应终端平台的 js bundle 构建。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://127.0.0.1:8081/</span><br><span class="line">https://127.0.0.1:8081/rn_temp/index.bundle?platform=ios&amp;dev=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如果成功，则会在 Metro Server 终端下会新增一段描述</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">::ffff:<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> - - <span class="string">[25/Jun/2021:09:31:39 +0000]</span> <span class="string">"<span class="keyword">GET</span> /favicon.ico HTTP/1.1"</span> <span class="number">404</span> <span class="number">150</span> <span class="string">"http://127.0.0.1:8081/"</span> <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"</span></span><br></pre></td></tr></table></figure>

<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li><p>[!] No `Podfile’ found in the project directory.<br>确认路径，是否为 ios 目录下。</p>
</li>
<li><p>M1 芯片（Apple Silicon）的 Mac 上完全安装 cocoapods<br><a href="https://stackoverflow.com/questions/64901180/running-cocoapods-on-apple-silicon-m1/65334677#65334677" target="_blank" rel="noopener">https://stackoverflow.com/questions/64901180/running-cocoapods-on-apple-silicon-m1/65334677#65334677</a></p>
</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo arch -x86_64 gem <span class="keyword">install</span> ffi</span><br><span class="line">arch -x86_64 pod <span class="keyword">install</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果执行 pod install 报错</li>
</ol>
<p>可能是因为没有勾选使用 Rosetta 打开<br>(应用程序-实用工具-终端-显示简介-勾选“Rosetta”)就执行</p>
<ol start="4">
<li>解决 React-Native mac 运行报错 error Failed to build iOS project. We ran “xcodebuild” command but it exited with error code 65. To debug build logs further, consider building your app with Xcode.app, by opening reactNative.xcodeproj<br><a href="https://www.cnblogs.com/stevexu/archive/2019/04/21/10745769.html" target="_blank" rel="noopener">https://www.cnblogs.com/stevexu/archive/2019/04/21/10745769.html</a></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">error Failed to build iOS project. We ran "xcodebuild" command but it exited <span class="keyword">with</span> <span class="keyword">error</span> code <span class="number">65.</span> <span class="keyword">To</span> debug <span class="keyword">build</span> <span class="keyword">logs</span> further, <span class="keyword">consider</span> building your app <span class="keyword">with</span> Xcode.app, <span class="keyword">by</span> opening reactNative.xcodeproj</span><br><span class="line">taro-<span class="keyword">native</span>-shell git:(<span class="number">0.59</span><span class="number">.9</span>) ✗ rm -rf node_modules &amp;&amp; yarn <span class="keyword">cache</span> clean</span><br><span class="line">taro-<span class="keyword">native</span>-shell git:(<span class="number">0.59</span><span class="number">.9</span>) ✗ yarn <span class="keyword">install</span></span><br><span class="line">taro-<span class="keyword">native</span>-shell git:(<span class="number">0.59</span><span class="number">.9</span>) ✗ rm -rf ~/.rncache</span><br><span class="line">taro-<span class="keyword">native</span>-shell git:(<span class="number">0.59</span><span class="number">.9</span>) ✗ node_modules/react-<span class="keyword">native</span>/scripts/ios-<span class="keyword">install</span>-third-party.sh</span><br><span class="line">~ pwd</span><br><span class="line">/<span class="keyword">Users</span>/gengjian</span><br><span class="line">~ mv ..<span class="comment">/*.gz ./</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>N/A: version “default -&gt; N/A” is not yet installed.</li>
</ol>
<p>You need to run “nvm install default” to install it before using it.<br>Command PhaseScriptExecution failed with a nonzero exit code</p>
<p>指定默认版本即可解决<br>➜ nvm alias default 14.17.0</p>
<ol start="6">
<li>react-native 在新版 Xcode（10+）中运行出现的问题： node_modules/react-native/third-party/glog-0.3.4 , C compiler ca</li>
</ol>
<p><a href="https://blog.csdn.net/qq_15057213/article/details/83859251" target="_blank" rel="noopener">https://blog.csdn.net/qq_15057213/article/details/83859251</a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">taro-native-shell git:(<span class="number">0.59</span><span class="number">.9</span>) ✗ cd node_modules/react-native/third-party/glog<span class="number">-0.3</span><span class="number">.5</span>/</span><br><span class="line">glog<span class="number">-0.3</span><span class="number">.5</span> git:(<span class="number">0.59</span><span class="number">.9</span>) ✗ sh ../../scripts/ios-configure-glog.sh</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>react-native run-ios 编译成功之后，模拟器红屏，显示 Application taroDemo has not been registered.（正常情况应该不用特殊处理）</li>
</ol>
<p>设置项目名称不一致。<br>在 AppDelegate.m 和 index.ios.js 中不一致。<br>./taro-native-shell/ios/taroDemo/AppDelegate.m 文件中：moduleName:@”classesMini”，<br>./classesMini/rn_temp/app.json 文件中： { “name”: “classesMini” }<br>名称保持一致。</p>
<ol start="8">
<li>当集成模式的 Taro 项目，真机调试命令行报错，打包却能跑通完成。</li>
</ol>
<p>即，执行<code>yarn ios</code>调试模式状态如下报错</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">The following build commands <span class="string">failed:</span></span><br><span class="line">CompileC <span class="regexp">/Users/</span>gengjian<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/taroDemo-djzgdiaepvktgegyrmjouhzoeriw/</span>Build<span class="regexp">/Intermediates.noindex/</span>taroDemo.build<span class="regexp">/Debug-iphonesimulator/</span>taroDemo.build<span class="regexp">/Objects-normal/</span>x86_64<span class="regexp">/AppDelegate.o /</span>Users<span class="regexp">/gengjian/</span>Documents<span class="regexp">/github/</span>SmartApp<span class="regexp">/ios/</span>taroDemo/AppDelegate.m normal x86_64 objective-c com.apple.compilers.llvm.clang<span class="number">.1</span>_0.compiler</span><br></pre></td></tr></table></figure>

<p>不过<code>yarn build:rn --platform ios</code>打包却没有问题。</p>
<p>感觉跟 M1 芯片的坑有关系，最后解决方法直接修改报错文件的语句。<br>打开 XCode 找到报错文件<code>./ios/taroDemo/AppDelegate.m</code>，<br>报错语句为一个宏判断，如果是 DEBUG 模式执行另外的语句，<br>直接简单粗暴了一波，修改如下：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">#<span class="built_in">if</span> DEBUG</span><br><span class="line">//  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@<span class="string">"index"</span> fallbackResource:@<span class="string">"main"</span>];</span><br><span class="line">  return [[NSBundle mainBundle] URLForResource:@<span class="string">"main"</span> withExtension:@<span class="string">"jsbundle"</span>];</span><br><span class="line">#<span class="built_in">else</span></span><br><span class="line">  return [[NSBundle mainBundle] URLForResource:@<span class="string">"main"</span> withExtension:@<span class="string">"jsbundle"</span>];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol>
<li><a href="https://blog.csdn.net/weixin_42362496/article/details/109986611" target="_blank" rel="noopener">Mac M1 处理器 无法安装 cocoapods 的解决办法</a></li>
<li><a href="https://blog.csdn.net/qq_38735649/article/details/107954287" target="_blank" rel="noopener">项目第一次 pod install 时 glog 报错</a></li>
<li><a href="https://www.cnblogs.com/gchlcc/p/6068801.html" target="_blank" rel="noopener">CocoaPods 的简单快速安装方法</a></li>
<li><a href="https://www.jianshu.com/p/7812bc768844" target="_blank" rel="noopener">推荐几个 cocoapods 镜像源</a></li>
<li><a href="https://www.jianshu.com/p/93c4cd8390d3" target="_blank" rel="noopener">Mac 安装 CocoaPods 详解</a></li>
<li><a href="https://www.jianshu.com/p/c8116c167ce5" target="_blank" rel="noopener">解决首次 CocoaPods 拉取 repos 过慢问题</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/356820165" target="_blank" rel="noopener">【笔记】Mac M1 搭建 React Native 环境</a></li>
<li><a href="https://blog.csdn.net/ios_xumin/article/details/106888970" target="_blank" rel="noopener">Command PhaseScriptExecution failed with a nonzero exit code 问题</a></li>
<li><a href="https://www.cnblogs.com/shaoting/p/10235652.html" target="_blank" rel="noopener">Flutter 爬坑记录</a></li>
<li><a href="https://blog.csdn.net/henryzyk/article/details/118029141" target="_blank" rel="noopener">RN 项目的坑 （M1 Mac）</a></li>
<li><a href="http://t.zoukankan.com/lisa090818-p-4134376.html" target="_blank" rel="noopener">iOS 申请证书，Certificates, Identifiers &amp;Profiles 简介</a></li>
<li><a href="http://news.sohu.com/a/573939453_120174355" target="_blank" rel="noopener">苹果企业开发者账号，P12 证书如何生成？</a></li>
<li><a href="https://www.react-native.cn/docs/publishing-to-app-store" target="_blank" rel="noopener">上架 App Store</a></li>
<li><a href="https://www.react-native.cn/docs/signed-apk-android" target="_blank" rel="noopener">打包发布 Android</a></li>
</ol>
]]></content>
      <tags>
        <tag>Taro</tag>
        <tag>RN</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title>23.macOS本地搭建gitlab服务</title>
    <url>/2021/01/23/23-macOS%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0gitlab/</url>
    <content><![CDATA[<h3 id="搭建背景"><a href="#搭建背景" class="headerlink" title="搭建背景"></a>搭建背景</h3><p>有时候想要调试一些公司的项目，<br>不过公司的项目是没有办法传到 github 上的。<br>以免有泄漏的风险。<br>可是还需要借助 git 来管理，<br>于是乎，就诞生了本地搭建 gitlab 的想法。</p>
<p>另外，gitlab 还是功能蛮强大的，<br>拥有完善的权限管理系统，<br>集成 wiki 等相关功能，<br>以及具备 CI 持续集成、CD 持续部署等功能。<br>正好也借此机会玩一玩 gitlab ，完善一下自身搭建团队的技能树。</p>
<a id="more"></a>

<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><p>由于 gitlab 只能在 Linux 内核环境下部署。<br>手上也只有一台 MacBook 老爷机，<br>只好在上面再按照一个沙盒（虚拟机）了。</p>
<ol>
<li><p>下载<code>Docker Desktop</code>。<br>市面上大部分教程都是推荐使用<code>Docker Desktop</code>。<br>页面集成化界面操作，已经相对之前部署容易了很多。<br>并且注册一个<code>Docker Hub</code>账号。</p>
</li>
<li><p>下载<code>gitlab-ce</code>。<br>在仓库找到 gitlab-ce 并下载。 <a href="https://hub.docker.com/r/gitlab/gitlab-ce" target="_blank" rel="noopener">https://hub.docker.com/r/gitlab/gitlab-ce</a><br>不过网上教程有一键下载的方式，不过我没有找到，最后还是通过命令行给安装上了。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>

<p>大概 800MB 大小，干脆挂机一宿下载完的。</p>
</li>
<li><p>配置<code>gitlab</code></p>
<p>一早起来，就看到<code>Docker Desktop</code>的<code>Containers</code>里面已经静静的躺着个<code>gitlab/gitlab-ce</code>。<br>接下来就是按照教程配置 gitlab。<br>自带的 UI 页面有配置，不过依旧没有搞懂。<br>还是用命令行配置最简单。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo docker run -d \</span><br><span class="line"> <span class="params">--hostname</span> xxx.gitlab.com \</span><br><span class="line"> <span class="params">--name</span> gitlab \</span><br><span class="line"> <span class="params">--restart</span> always \</span><br><span class="line"> <span class="params">--publish</span> 22<span class="function">:22</span> <span class="params">--publish</span> 80<span class="function">:80</span> <span class="params">--publish</span> 443<span class="function">:443</span> \</span><br><span class="line"> <span class="params">--volume</span> <span class="string">/Users/xxx/gitlab/config</span>:<span class="string">/etc/gitlab</span> \</span><br><span class="line"> <span class="params">--volume</span> <span class="string">/Users/xxx/gitlab/logs</span>:<span class="string">/var/log/gitlab</span> \</span><br><span class="line"> <span class="params">--volume</span> <span class="string">/Users/xxx/gitlab/data</span>:<span class="string">/var/opt/gitlab</span> \</span><br><span class="line"> gitlab/gitlab-ce<span class="function">:latest</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 gitlab<br>此刻通过浏览器输入：<a href="http://localhost:80/" target="_blank" rel="noopener">http://localhost:80/</a>，即可到登录页面。<br>第一次登录会让你输入超级管理员的密码。<br>账号：root。<br>这个账号是最高权限。可以通过这个账号对 gitlab 配置一切。</p>
</li>
<li><p>注册 gitlab 账号<br>不过我们也不能一直用着 root 就去开发。<br>那也也未免太过霸气侧漏了。<br>我们还是需要注册一个自己开发用的账号。<br>让我们退出登录。<br>在刚刚登录页面重新注册一个属于自己的账号、密码、邮箱。<br>此时这个账号注册还不能被使用登录。<br>我们需要通过 root 账户，对刚刚注册的账号进行授权通过，<br>这样新注册的账号才能被使用。</p>
</li>
<li><p>配置 SSH-KEY<br>新账号在登录之后，需要配置 git 公钥。<br>通过命令行</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"xxx@mail.com"</span></span><br></pre></td></tr></table></figure>

<p>在<code>.ssh/</code>目录下会生成两个文件<code>id_rsa.pub</code>和<code>id_rsa</code>，<br>我们需要将<code>id_rsa.pub</code>文件内的内容复制到 gitlab 中 <code>SSH-KEY</code>输入框中即可。</p>
</li>
<li><p>搭建仓库<br>新建仓库，然后本地代码跟仓库相关联，跟 github 很相似了。在这里就不再赘述了。</p>
</li>
</ol>
<h3 id="踩坑相关"><a href="#踩坑相关" class="headerlink" title="踩坑相关"></a>踩坑相关</h3><ol>
<li><p>下载<code>gitlab-ce</code>真的是太慢了。<br>估计镜像资源也不怎么好。</p>
</li>
<li><p>登录 gitlab 的时候报错 502。<br>这个问题纠结了好久。<br>网上说的大部分情况都是端口冲突。<br>又是杀进程，又是改配置的，结果并没起作用。</p>
<p>最后想到，可能我是通过 docker 配置的 gitlab。<br>应该是给 docker 分配的资源太少，导致的报错。<br>解决方法是：<br>在 docker 的<code>设置(Preferences)</code>-&gt;<code>Resource</code>-&gt;<code>ADVANCED</code>。<br>将<code>Swap</code>调整到了 <code>3GB</code>。<br>不过为了保险起见，其他硬件参数也都调高一些。<br>将<code>Memory</code>调整到了 <code>3.00GB</code></p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来以为是一个很简单的事情，<br>结果也折腾来折腾去的搞了大半天。<br>不过终于搭建好仓库的时候，<br>还是很嗨皮的。<br>接下来有时间的时候可以好好玩一玩 CI 了~</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://billqiu.github.io/2016/07/08/%E5%9C%A8mac%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2gitlab/" target="_blank" rel="noopener">1. 在 mac 上使用 docker 部署 gitlab</a></li>
<li><a href="http://comdyn.hy.tsinghua.edu.cn/from-web/mac-os/570-docker-gitlat" target="_blank" rel="noopener">2. 基于 Docker 在 Mac OS X 系统中的部署和设置 GitLab</a></li>
<li><a href="https://blog.csdn.net/rex1129/article/details/110119830" target="_blank" rel="noopener">3. Docker gitlab 502 解决办法</a></li>
<li><a href="https://blog.csdn.net/ianly123/article/details/82984736" target="_blank" rel="noopener">4. 自建 gitlab 服务器以及出现 502 错误解决方案</a></li>
<li><a href="https://blog.csdn.net/top_code/article/details/50381432" target="_blank" rel="noopener">5. 调整 git 仓库的连接地址</a></li>
<li><a href="https://www.cnblogs.com/micrari/p/5659036.html" target="_blank" rel="noopener">6. 多个 git 账号的 SSH 配置</a></li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>25.ECharts的研究和使用</title>
    <url>/2021/07/07/25-ECharts%E7%9A%84%E7%A0%94%E7%A9%B6%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h3><p>最近项目疯狂折腾报表，很多图表纯使用 CSS 实现是不现实的，<br>专业的事情还是得交给专业的库去实现。<br>趁此机会在 ECharts 里面疯狂搪坑。</p>
<a id="more"></a>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>ECharts 生成对象、初始化等操作没什么太过特殊的地方。<br>主要核心是<code>setOptions()</code>这个核心方法。</p>
<p>我们通过 set 不同的 options 来实现对不同图表样式的调整。<br>一般来说我们在 options 的第一层级里面主要设置一下几个属性字段。</p>
<ol>
<li><p>title<br>标题组件，包含主标题和副标题。</p>
</li>
<li><p>grid<br>直角坐标系内绘图网格。</p>
</li>
<li><p>xAxis<br>直角坐标系 grid 中的 x 轴。</p>
</li>
<li><p>yAxis<br>直角坐标系 grid 中的 y 轴。</p>
</li>
<li><p>tooltip<br>提示框组件。</p>
</li>
<li><p>geo<br>地理坐标系组件。</p>
</li>
<li><p>series<br>核心字段，我们的数据信息，数据展示形态，都会存放在这里。</p>
</li>
</ol>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><ol>
<li><p>层级复杂的 options 对象<br>由于我们大部分操作都是为了拼凑这个大 options 对象。<br>导致有时候设置一个属性字段，无论怎么设置都不生效，最后发现是搞错了层级。<br>另外，不同层级同名的属性字段也非常多，在设置 options 属性字段的时候要格外认真比对。</p>
</li>
<li><p>注意效果的支持版本号<br>如果是一些老旧项目，可能引用 ECharts 库的版本不够高，<br>导致即使是参照文档按照标准设置某个属性字段，依旧不会生效。<br>所以也要注意属性支持的最低版本。<br>如：<br><code>series-bar.selectedMode</code> 属性从<code>v5.0.0</code>开始支持。<br><code>series-bar.showBackground</code>属性从<code>v4.7.0</code>开始支持。</p>
</li>
<li><p>更换 ECharts 库的版本，报错 “fp is not a function”<br>坑在官方定制 ECharts 库的网站的“代码压缩”选项有毒，不要勾选。<br>如果下载下来的包过大，可以自己手动通过其他网站<a href="https://tool.lu/js/" target="_blank" rel="noopener">https://tool.lu/js/</a>进行混淆压缩。<br>即可正常使用。</p>
</li>
<li><p>ECharts 多次 init 后 setOption，小程序会崩溃，疑似内存泄漏。</p>
<p>复现场景：一个页面 init9 个 ECharts 实例，同时对实例 setOptions，来回进出页面，约 15~16 次之后，小程序崩溃。<br>已经调用 this.chart.clear() / this.chart.dispose()的销毁方法，并没有实际作用。</p>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://echarts.apache.org/zh/option.html" target="_blank" rel="noopener">1. 官方 options 文档</a></li>
<li><a href="https://echarts.apache.org/examples/zh/index.html" target="_blank" rel="noopener">2. 官方示例</a></li>
<li><a href="https://echarts.apache.org/zh/builder.html" target="_blank" rel="noopener">3. 定制 ECharts 库</a></li>
<li><a href="https://blog.csdn.net/liuy_1314/article/details/108866987" target="_blank" rel="noopener">4. echarts 多个地区合并并实现标注</a></li>
<li><a href="https://blog.csdn.net/weixin_33743661/article/details/93469931" target="_blank" rel="noopener">5. echarts 合并地图，把中国各个省份分成大区</a></li>
<li><a href="https://www.makeapie.com/explore.html" target="_blank" rel="noopener">6. echarts 示例</a></li>
</ul>
]]></content>
      <tags>
        <tag>ECharts</tag>
      </tags>
  </entry>
  <entry>
    <title>26.深拷贝进坑小记</title>
    <url>/2022/02/02/26-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%9B%E5%9D%91%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="进坑背景"><a href="#进坑背景" class="headerlink" title="进坑背景"></a>进坑背景</h3><p>长久以来，凡是涉及到深拷贝的地方基本都是 JSON 一把梭。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cloneData = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(target));</span><br></pre></td></tr></table></figure>

<p>用的久了已经觉得这一切都是顺理成章。<br>直到最近终于是踩了一波坑。</p>
<a id="more"></a>

<h3 id="情景复现"><a href="#情景复现" class="headerlink" title="情景复现"></a>情景复现</h3><p>在做图表项目的时候，<br>由于页面会用到很多类型的图表，<br>每个类型的图表都要单独写一个 options 感觉非常冗余，<br>于是将柱状图、饼图、折线图、面积图分别抽象出来模板，<br>而在使用的时候，<br>对这些模板进行深拷贝后，塞入对应的 data 即可使用，<br>这也为后续的悲剧埋入了隐患。</p>
<p>其他的都么有问题，直到遇到进行格式化坐标轴的展示格式的时候，<br>formatter 字段是支持<code>字符串模板</code>和<code>回调函数</code>两种形式的。<br>在模板中传入字符串模板是没有问题的，不过传入回调函数，始终不会生效。<br>简直质疑人生，甚至怀疑项目引用的 ECharts 的版本是否是不支持回调函数。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>经过 debug 打印日志发现，<br>深拷贝模板得到的对象，确实丢失了 formatter 字段。<br>而在得到的字段里面赋值 formatter 字段，<br>即可以实现通过回调函数渲染坐标轴展示格式。<br>于是就把目光落向了深拷贝的公共方法。<br>果然，简单粗暴版本的深拷贝用多了，就忘记了无法拷贝函数的这个缺陷。<br>于是，重新写了一个新的完整版深拷贝公共方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完整版深拷贝方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deepCloneFull = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 定义一个变量</span></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">// 如果当前需要深拷贝的是一个对象的话</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">      <span class="comment">// 如果是一个数组的话</span></span><br><span class="line">      result = []; <span class="comment">// 将result赋值为一个数组，并且执行遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="comment">// 递归克隆数组中的每一项</span></span><br><span class="line">        result.push(deepCloneFull(target[i]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断如果当前的值是null的话；直接赋值为null</span></span><br><span class="line">      result = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.constructor === <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断如果当前的值是一个RegExp对象的话，直接赋值</span></span><br><span class="line">      result = target;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则是普通对象，直接for in循环，递归赋值对象的所有值</span></span><br><span class="line">      result = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">        result[i] = deepCloneFull(target[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是对象的话，就是基本数据类型，那么直接赋值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最终结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>果然，使用了这个完整版的深拷贝公共方法，<br>再次深拷贝模板 options 的时候，<br>formatter 字段即使是函数也可以携带过来了~</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这个其实本来最初设计的时候，应该就是偷懒了一下。<br>导致一直都是问题被埋藏着，<br>直到遇到深拷贝<code>带函数的字段</code>才爆发出来。<br>其实，如果早些遇到，定位问题也不至于会这么慢，<br>主要是这个深拷贝公共方法被用过太多次，<br>潜意识之下，最初一点都没有怀疑是深拷贝的问题。<br>（用的地方太多也导致不敢直接改原来的公共方法，只好新写一个方法，然后通知团队小伙伴以后深拷贝就使用新的深拷贝方法吧，略尴尬 =。=!）<br>这也是个教训，有些懒是偷不得的，<br>出来混，早晚都是要还的。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>27.微信小程序安卓机型输入框内容错位问题</title>
    <url>/2022/02/02/27-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E6%A1%86%E5%86%85%E5%AE%B9%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>开发过程中写一个活动页面，需求调整为搜索栏在页面下方。<br>不过遇到一个问题，<br>安卓机型下，在页面滑动的时候或者弹出输入法过程中，<br>在输入框的内容会有错位的情况。</p>
<p>收到测试反馈这个问题之后，就感觉一阵蛋疼。<br>因为这种奇葩问题感觉更像是微信小程序的自身原因，<br>只能用曲线救国非常规的方式去解决。</p>
<a id="more"></a>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>具体问题如图所示：<br><img src="../../../../images/image_27_1.png" alt="输入框内容错位"></p>
<p>找网上论坛看是否有相关的解决方法：</p>
<ul>
<li>使用 textarea 标签代替 input 实现</li>
</ul>
<p>不过多行的输入特点，无法很准确的对齐 label，想想坑也未会比 input 少，<br>尝试几次就无奈放弃，</p>
<ul>
<li>将 scrollview 更换为 view</li>
</ul>
<p>网上论坛有说是，这种现象主要是由于 input 的父级中有 scrollview 包裹导致的。<br>改用普通的 view 布局 属性中增加 overflow-y: auto<br>不过改为 view 之后，页面布局更改太多，这个方案暂时搁置。</p>
<ul>
<li>动态修改 scrollview 的 scroll-y 属性</li>
</ul>
<p>这个试了一下，<br>在 input 的 onfocus 生命周期，设置禁用滚动，<br>在 input 的 onblur 生命周期，设置启用滚动。<br>这样改动之后确实有效果，<br>不过还是会有内容错位，闪过然后恢复正常，也不是很友好。</p>
<ul>
<li>给 scrollview 的高度不设置 100vh(亲测有效)</li>
</ul>
<p>找了很久之后，有一个帖子回复，提到了这一点。<br>感觉毫无关系，不过也抱着试一试的心态，去调整了一下。<br>我之前的写法是 flex 的自适应布局，flex: 1<br>现在我将高度设置为 height: calc(100vh-1px)<br>经过调整之后，果然好用，这个问题也终于得到了解决</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/0004e6550c4a602c826a3e7a65b800" target="_blank" rel="noopener">1. 在 scroll-view 中使用 input，input 键盘弹出时，滚动页面，输入框内容会出现错位问题？</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/00006850f70cc08156ea2c53c56800" target="_blank" rel="noopener">2. scroll-view 滚动页面，input 键盘弹出时，页面滚动到顶部，输入框内容错位问题。怎么解决？</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000a00e1fd0790488e6a034f156813" target="_blank" rel="noopener">3. input 键盘弹出时，滚动页面，输入框内容错位问题</a></li>
</ul>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title>29.Taro多端开发之跨端踩坑</title>
    <url>/2022/02/03/29-Taro%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%A8%E7%AB%AF%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h3 id="关于跨端"><a href="#关于跨端" class="headerlink" title="关于跨端"></a>关于跨端</h3><p>公司基本都选择采取敏捷开发，<br>快速的迭代版本，以应对瞬息万变的市场情况。</p>
<p>而每次版本迭代都要分别使用原生开发各端的项目，这明显是不现实的，<br>而且公司的人力成本也是决不允许这样做的。</p>
<p>这么下来使用可以实现跨端的框架，<br>即维护一套代码就可以部署在各个终端，成为了越来越多人的选择。<br>（约等于现在一个人干了以前 N 个人的活）</p>
<a id="more"></a>

<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol>
<li>className 全局不要重名</li>
</ol>
<p>支付宝小程序所有的组件样式会全局同步，同名的话会造成样式互相污染，且 RN 不支持。</p>
<ol start="2">
<li>样式类名不支持 less 嵌套语法，将类名平铺实现，RN 不支持。</li>
</ol>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="selector-class">.page-wrap</span> &#123;</span><br><span class="line">  <span class="selector-class">.page-content</span> <span class="selector-class">.page-list</span> &#123;</span><br><span class="line">    <span class="selector-class">.page-item</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="selector-class">.pageWrap</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pageContent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pageList</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pageItem</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>避免使用 float、fixed 布局。</li>
</ol>
<p>RN 不支持。</p>
<ol start="4">
<li>文本样式写在<code>&lt;Text&gt;</code>标签，不要写在<code>&lt;View&gt;</code>标签。</li>
</ol>
<p>RN 不支持。</p>
<ol start="5">
<li>边框的实现，避免直接写 0.5px。</li>
</ol>
<p>边框宽度使用偶数像素如 2px。项目的 designWidth 是基于 750 的，在 375 的手机上就会解析成 1px，如果使用单数会解析成 0.5px，部分型号手机会丢失宽度默认为 0，导致边框的线无法显示。</p>
<ol start="6">
<li><p><code>Taro.getImageInfo</code> 获取图片信息返回值不同</p>
<ul>
<li>微信小程序平台 返回值示例</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">errMsg:</span> <span class="string">"getImageInfo:ok"</span></span><br><span class="line"><span class="symbol">height:</span> <span class="number">64</span></span><br><span class="line"><span class="symbol">orientation:</span> <span class="string">"up"</span></span><br><span class="line"><span class="symbol">path:</span> <span class="string">"http://tmp/O3dPoGO2Eopw3e718fa1668604635a50f3ab88c97597.png"</span></span><br><span class="line"><span class="symbol">type:</span> <span class="string">"png"</span></span><br><span class="line"><span class="symbol">width:</span> <span class="number">64</span></span><br></pre></td></tr></table></figure>

<ul>
<li>H5 平台 返回值示例 (无 orientation、path、type 字段)</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">errMsg:</span> <span class="string">"getImageInfo:ok"</span></span><br><span class="line"><span class="attr">height:</span> <span class="number">84</span></span><br><span class="line"><span class="attr">width:</span> <span class="number">84</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上传图片的行为实现不同</p>
<ul>
<li><p>微信小程序平台<br>使用<code>Taro.uploadFile</code>封装好的 API 方法即可。<br>// uploadImage.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">uploadImage</span>(<span class="params">tempFile</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> filePath = tempFile.path</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'uploadImage weapp'</span>, tempFile)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Taro.uploadFile(&#123;</span><br><span class="line">		url: config.ph.upload.url, <span class="comment">// 后台接口名</span></span><br><span class="line">		filePath: filePath, <span class="comment">// : tempFilePaths[0],</span></span><br><span class="line">		<span class="comment">// 后台字段名为为file 的name传file（根据后台定义的入参）</span></span><br><span class="line">		name: <span class="string">'file'</span>,</span><br><span class="line">		header: &#123;</span><br><span class="line">			<span class="string">'Content-type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>H5 平台<br>使用<code>Taro.request</code>重新对上传文件请求进行封装处理。<br>// uploadImage.h5.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">uploadImage</span>(<span class="params">tempFile</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">	formData.append(<span class="string">'file'</span>, tempFile.originalFileObj)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">		Taro.request(&#123;</span><br><span class="line">			url: config.ph.upload.url, <span class="comment">// 后台接口名</span></span><br><span class="line">			data: formData,</span><br><span class="line">			method: <span class="string">'POST'</span>,</span><br><span class="line">			dataType: <span class="string">''</span>,</span><br><span class="line">			responseType: <span class="string">'text'</span>,</span><br><span class="line">			timeout: <span class="number">20000</span>,</span><br><span class="line">			complete: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">'uploadImage h5 request'</span>, res)</span><br><span class="line">				resolve(res)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>Taro.getCurrentPages()</code> 获取页面栈 API 的结果不同</p>
<p>建议获取页面信息统一使用<code>this.$router</code>取值</p>
<ul>
<li>微信小程序平台<br>返回值数组中元素有 router 字段，为页面路由名称</li>
<li>H5 平台<br>返回值数组中元素没有 router 字段，无法通过该 api 获取路由名称</li>
</ul>
</li>
<li><p>顶部导航</p>
<p>需要做样式兼容</p>
<ul>
<li>微信小程序平台<br>默认是有头部导航条</li>
<li>H5 平台<br>默认是没有头部导航条的</li>
</ul>
</li>
<li><p>CSS 的 animation 动画效果 RN 端不支持</p>
</li>
<li><p><code>Taro.chooseImage()</code> H5 端在 APP 浮层中使用 部分安卓机型取消也会触发成功回调</p>
</li>
</ol>
<p>选择图片，然后在选择相机或者相册时，直接取消。<br>Taro.chooseImage 也会触发成功回调，不过 size 为 0。<br>可以通过 size 这个字段来进行筛选。<br><img src="../../../../images/image_29_1.jpg" alt="取消选择图片也会触发成功回调"></p>
<ol start="12">
<li>ios 拍照上传图片，H5 端会有旋转 90 度的问题</li>
</ol>
<p>这个应该是 ios 的自身问题。<br>不过可以通过曲线救国的方式解决这个问题，<br>首先要知道图片是否旋转了，可以通过 exif.js 这个插件，根据得到的 Orientation 属性，获取到它的拍照方向。<br>其次，创建一个 image 标签去接收文件获取图片的宽高和比例</p>
<table>
<thead>
<tr>
<th align="center">旋转角度</th>
<th align="center">参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0°</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">顺时针 90°</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">180°</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">逆时针 90°</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>然后，将图片转为 base64 格式，通过 canvas 标签，绘制在上面，再通过 api 将其旋转。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旋转画布(弧度制)</span></span><br><span class="line">context.rotate(angle);</span><br></pre></td></tr></table></figure>

<p>随后，将旋转后的图片，保存为 base64 格式<br>（根据需求看是否需要前端将图片压缩，如需压缩则通过该步骤进行压缩）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// canvas绘制的图片转为base64</span></span><br><span class="line">canvas.toDataURL();</span><br></pre></td></tr></table></figure>

<p>最后，将 base64 转换为接口上传所需要的格式（Blob），进而完成图片的上传功能。</p>
<ol start="13">
<li>H5 获取参数通过 this.$router.params 获取不到参数中携带=等字符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">"h5"</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; href = <span class="string">""</span> &#125; = (<span class="built_in">window</span> &amp;&amp; <span class="built_in">window</span>.location) || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">path</span>: pathH5 = <span class="string">""</span>, <span class="attr">params</span>: paramsH5 = &#123;&#125; &#125; =</span><br><span class="line">    router2Params(href) || &#123;&#125;;</span><br><span class="line">  host = pathH5.split(<span class="string">"#"</span>)[<span class="number">0</span>] || <span class="string">""</span>;</span><br><span class="line">  path = pathH5.split(<span class="string">"#"</span>)[<span class="number">1</span>] || <span class="string">""</span>;</span><br><span class="line">  params = paramsH5;</span><br><span class="line">  <span class="comment">// 暂不兼容类似 http://localhost:10086?code=071UBEge2snGkI0Szxhe2BPNge2UBEgU&amp;state=123#/pages/index 格式，如有场景需要可后续拓展</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">path</span>: pathTmp = <span class="string">""</span>, <span class="attr">params</span>: paramsTmp = &#123;&#125; &#125; = <span class="keyword">this</span>.$router || &#123;&#125;;</span><br><span class="line">  path = pathTmp;</span><br><span class="line">  params = paramsTmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>微信 H5 长按图片识别码功能。</li>
</ol>
<p>如果屏幕内有很多码，长按没有完整展示在屏幕内的码，<br>进行识别的时候，可能会识别出是屏幕其他码的信息。（疑似是微信的自身 bug）</p>
<ol start="15">
<li>获取用户信息 API getUserProfile</li>
</ol>
<p>Taro.getUserProfile 不支持微信小程序。（Taro2.x 版本）<br>解决方案为如果是微信小程序端，通过 wx.getUserProfile 去调用，其他端则不作处理跳过该逻辑</p>
<ol start="16">
<li>H5 端 如果元素设置绝对定位，通过 bottom 控制位置不准确。</li>
</ol>
<p>当有 Input 聚焦的时弹出输入法，部分安卓机型，此时屏幕高度会被调整。（device.windowHeight 高度会改变）<br>此时如果通过 absolute + bottom 布局，元素就会被输入法挤上去。<br>解决方案为页面渲染之前，将屏幕高度获取到，并且计算好元素的对应 top 或者 margin-top，然后引用到对应元素上即可。</p>
<ol start="17">
<li><p>文字要包在 Text 组件里面，否则 RN 端会不显示</p>
</li>
<li><p>RN 动画不支持：Animation 和 transform</p>
</li>
<li><p>RN 与 H5/小程序 的 flex 布局相关属性的默认值有差异，所以需要显式声明，不采用默认值。</p>
</li>
</ol>
<p>flexDirection 指定布局的主轴。<br>RN 子元素默认是沿着 竖直轴(column) 方向排列；这点和 CSS 不一样，需要注意</p>
<ol start="20">
<li>选择器的写法</li>
</ol>
<ul>
<li>基本选择器只支持类选择器</li>
<li>不支持组合选择器的写法</li>
<li>不支持伪类及伪元素</li>
</ul>
<ol start="21">
<li>读写缓存<br>RN 端不支持 setStorageSync 需要改用 setStorage<br>RN 端不支持 getStorageSync 需要改用 getStorage<br>RN 端不支持 removeStorageSync 需要改用 removeStorage</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://taro-docs.jd.com/taro/docs/envs" target="_blank" rel="noopener">1. Taro 多端开发文档</a></li>
<li><a href="https://blog.csdn.net/gwdgwd123/article/details/84726238" target="_blank" rel="noopener">2. taro 框架的缺陷以及注意事项</a></li>
<li><a href="https://blog.csdn.net/chuogun0812/article/details/100766099" target="_blank" rel="noopener">3. Taro 兼容 h5 踩坑指南</a></li>
<li><a href="https://blog.csdn.net/perryliu6/article/details/87791231" target="_blank" rel="noopener">4. window.close()不能关闭页面时的解决办法及思路</a></li>
<li><a href="https://blog.csdn.net/weixin_30394975/article/details/112942957" target="_blank" rel="noopener">5. h5 跨域访问图片_Taro - 本地 H5 无法访问远程服务器（跨域问题）</a></li>
<li><a href="https://www.jianshu.com/p/8186b70eb316" target="_blank" rel="noopener">6. Taro 踩坑记之 React-Native 环境教程</a></li>
<li><a href="https://github.com/CocoaPods/CocoaPods/issues/10718" target="_blank" rel="noopener">7. I can not install pod files. #10718</a></li>
<li><a href="https://stackoverflow.com/questions/64901180/running-cocoapods-on-apple-silicon-m1/65334677#65334677" target="_blank" rel="noopener">8. How to running CocoaPods on Apple Silicon (M1)</a></li>
<li><a href="https://blog.csdn.net/weixin_55869781/article/details/119110800" target="_blank" rel="noopener">9. 解决 ios 上传图片被旋转的问题</a></li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>如果后续有遇到的会随时更新。</p>
]]></content>
      <tags>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title>30.微信小程序Canvas绘制海报踩坑</title>
    <url>/2022/04/09/30-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FCanvas%E7%BB%98%E5%88%B6%E6%B5%B7%E6%8A%A5%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h3 id="绘制海报"><a href="#绘制海报" class="headerlink" title="绘制海报"></a>绘制海报</h3><p>对于小程序的分享，目前来说就是三种方法：<br>一个是点击小程序的卡片分享链接，<br>一个是通过生成小程序短码，<br>一种是通过微信扫小程序的太阳码进入。</p>
<p>小程序卡片分享只能在微信私聊和群聊中使用，相对会受限一些。<br>小程序短码后台生成的有<code>临时</code>和<code>永久</code>两种。临时有效期只有 30 天，永久则是个数上会受到限制(10w 个)。短码目前不是一个很好的方案。<br>小程序短码还有一种途径是安卓手机通过小程序右上角胶囊按钮的菜单复制链接也可以拿到，不过文档未说明该功能，不确定是临时还是永久的。</p>
<p>而小程序分享朋友圈的功能暂时还未开放。<br>（据说安卓用户内测一段时间，不过限制很多）</p>
<p>所以想要在朋友圈传播开来，<br>目前大家的解决方案基本都是会在朋友圈发海报的形式来引流小程序。</p>
<p>那么小程序生成海报的功能就显得必不可缺，<br>不过想要实现这个功能，其中隐藏的坑也不老少。</p>
<a id="more"></a>

<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><ol>
<li>模拟器、真机调试模式正常，关闭调试模式保存图片白屏。</li>
</ol>
<p>一般一旦遇到调试模式正常，关闭调试就不正常的情况，<br>第一直觉就是需要看一下小程序后台的开发设置，<br>我们需要绘制的图片或者请求的接口，是否在合法域名的白名单内。<br>80%都是忘记配置域名导致的这类问题。<br>PS：其实如果模拟器不勾选<code>不校验合法域名、web-view（业务域名）、TLS版本以及HTTPS证书</code>这一项，也会复现这个问题，只不过这一项习惯性的常年勾选而发现不了。</p>
<ol start="2">
<li>个别安卓机，海报绘制可以绘制出来，个别图片绘制不出来，开启调试模式就没问题。IOS 机型不开调试模式也没问题。</li>
</ol>
<p>首先跟问题 1 一样，校验域名是否在合法域名内。<br>不过 ios 机型没问题，应该不是后台配置的问题。<br>这个问题纠结了很久，<br>最后请教组内前端大佬帮忙解决。<br>有些图片资源服务器的 ng 没有配置跨域字段。（=。=！~）<br>沟通到运维大哥，经过一番邮件协调，同意将跨域字段添加。<br>中间由于资源服务器可能很多台，运维大哥可能只加几个服务器。中途又实锤几个 IP 忘记加跨域字段了。最终全部加上之后，这个问题得以解决。<br>PS：前端大佬说，也可以尝试不直接通过 url 把图片绘制到 canvas 上，而是把图片下载之后，转成 Base64，再将 Base64 绘制到 canvas，应该就会回避跨域的问题。不过只是理论猜想，不知道会不会有隐藏坑。由于项目上线时间紧张就没敢乱尝试。<br><img src="../../../../images/image_30_1.png" alt="图片资源服务器的 ng 没有配置跨域字段"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.cnblogs.com/DSH-/p/10169016.html" target="_blank" rel="noopener">1. 关于微信小程序使用 canvas 生成图片，内容图片跨域的问题</a></li>
</ul>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>31.记录几个操作git仓库的命令</title>
    <url>/2022/04/09/31-%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AA%E6%93%8D%E4%BD%9Cgit%E4%BB%93%E5%BA%93%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="运用背景"><a href="#运用背景" class="headerlink" title="运用背景"></a>运用背景</h3><p>正常情况下，我们的项目只会跟一个仓库关联，<br>然后对这个仓库的分支进行拉去，推送等操作。</p>
<p>可是开发过程中，总会有些奇葩的场景。<br>比如：<br>代码需要统一迁移到一个 group 下，<br>再比如：<br>代码需要同步推送到另一个仓库的分支，<br>通过 sonar 来扫代码计(keng)算(die)代码量。</p>
<p>在这里也十分感谢组内大佬分享。<br>我记录下来，以防后续还会有这种奇葩情况发生。</p>
<a id="more"></a>

<h3 id="仓库迁移其他-group-方法"><a href="#仓库迁移其他-group-方法" class="headerlink" title="仓库迁移其他 group 方法"></a>仓库迁移其他 group 方法</h3><ol>
<li>本地新建一个 mirrorGit 目录，用于存放需要迁移项目的临时目录。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir mirrorGit</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>进入 mirrorGit 目录后，将待迁移的仓库 clone 到本地</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --mirror https://github.com/gengjian1203/module-test.git</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入该目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> module-test.git</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>设置要即将迁移的仓库地址(需要提前将仓库建好)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url --push origin https://github.com/gengjian0312/module-test.git</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>获取老仓库的代码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch -p origin</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将代码推送到新仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --mirror</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>后续如果老仓库代码还有更新<br>只需要再次执行 5、6 两个步骤，<br>即可再次同步将老仓库代码推送到新仓库。</li>
</ol>
<p>最后总结一下，这波操作最后的核心就是：<br>代码拉取操作是会向老仓库发起请求拉取，<br>代码推送则会向新仓库发起推送。<br>而这个本地临时项目就是一个中转站搬运工的作用~</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin	https://github.com/gengjian1203/module-test.git (fetch)</span><br><span class="line">origin	https://github.com/gengjian0312/module-test.git (push)</span><br></pre></td></tr></table></figure>

<h3 id="修改代码同步推送到其他仓库的分支"><a href="#修改代码同步推送到其他仓库的分支" class="headerlink" title="修改代码同步推送到其他仓库的分支"></a>修改代码同步推送到其他仓库的分支</h3><ol>
<li>进入项目，将本地代码新增绑定另一个仓库的地址</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin-0312 https://github.com/gengjian0312/module-test.git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看项目绑定状态</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">origin-0312	https://github.com/gengjian0312/module-test.git (fetch)</span><br><span class="line">origin-0312	https://github.com/gengjian0312/module-test.git (push)</span><br><span class="line">origin	https://github.com/gengjian1203/module-test.git (fetch)</span><br><span class="line">origin	https://github.com/gengjian1203/module-test.git (push)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从老仓库拉取代码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将代码同步推送到新绑定的仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin-0312 master</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>后续有复杂的 git 管理需求，同步记录下来。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>28.Node脚本之微信小程序持续集成自动上传</title>
    <url>/2022/02/03/28-Node%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h3 id="折腾背景"><a href="#折腾背景" class="headerlink" title="折腾背景"></a>折腾背景</h3><p>开发过程中，每次需要打小程序的体验版，供测试同学测试的时候。<br>都需要压缩编译代码，然后点击上传按钮，对小程序进行上传的操作。<br>一次两次还好，手上事情多的时候，这个上传操作是很挑战心态的一件事情。<br>所以为了避免每次人肉点击上传操作，<br>写了一个脚本，放在命令里面，方便了开发人员的压力。<br>（如果一套代码供多个小程序使用的时候效果更佳 (＾－＾)V）</p>
<a id="more"></a>

<h3 id="CI-是什么"><a href="#CI-是什么" class="headerlink" title="CI 是什么"></a>CI 是什么</h3><p>CI 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。<br>通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，<br>确保这些更改没有对应用造成破坏。<br>微信小程序自身也具备这项功能，给开发人员提供了库和对应方法，实现通过代码上传小程序的能力。</p>
<h3 id="微信小程序-CI-上传代码流程"><a href="#微信小程序-CI-上传代码流程" class="headerlink" title="微信小程序 CI 上传代码流程"></a>微信小程序 CI 上传代码流程</h3><ol>
<li><p>微信小程序后台的配置<br>在<code>微信公众平台</code>-&gt;<code>开发</code>-&gt;<code>开发设置</code>后下载<code>代码上传密钥</code>。<br>秘钥需要妥善保管，弄丢了就只能重新生成了。<br>同时将自身的公网 IP，放到代码上传的白名单内。<br>不然上传的时候会提示报错。<br>或者关闭这个白名单，任何 IP 都可以允许上传，不过这样无疑风险会变大一些。</p>
</li>
<li><p>脚本所在项目添加依赖库 miniprogram-ci</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install miniprogram-ci --save</span><br><span class="line">或者</span><br><span class="line">yarn add miniprogram-ci</span><br></pre></td></tr></table></figure>
</li>
<li><p>js 脚本实现</p>
<p>引用 CI 库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ci = <span class="built_in">require</span>(<span class="string">"miniprogram-ci"</span>);</span><br></pre></td></tr></table></figure>

<p>声明 CI 对象 注意： new ci.Project 调用时，请确保项目代码已经是完整的，避免编译过程出现找不到文件的报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> project = <span class="keyword">new</span> ci.Project(&#123;</span><br><span class="line">  appid: <span class="string">"wxsomeappid"</span>,</span><br><span class="line">  type: <span class="string">"miniProgram"</span>,</span><br><span class="line">  projectPath: <span class="string">"the/project/path"</span>,</span><br><span class="line">  privateKeyPath: <span class="string">"the/privatekey/path"</span>,</span><br><span class="line">  ignores: [<span class="string">"node_modules/**/*"</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上传操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uploadResult = <span class="keyword">await</span> ci.upload(&#123;</span><br><span class="line">  project,</span><br><span class="line">  version: <span class="string">"1.1.1"</span>,</span><br><span class="line">  desc: <span class="string">"hello"</span>,</span><br><span class="line">  setting: &#123;</span><br><span class="line">    es6: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  onProgressUpdate: <span class="built_in">console</span>.log,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对应的 api 参数可以参考下方的官方文档。</p>
</li>
<li><p>执行脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node ./script/uploadWeapp.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>集成到 package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">   "upload": "node ./script/uploadWeapp.js",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html" target="_blank" rel="noopener">1. 微信官方文档/CI</a></li>
</ul>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="../../../../assets/assets_28_1.js">自动上传微信小程序体验版脚本</a></p>
]]></content>
      <tags>
        <tag>Node脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>34.企微侧边栏开发记录</title>
    <url>/2022/05/22/34-%E4%BC%81%E5%BE%AE%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="记录背景"><a href="#记录背景" class="headerlink" title="记录背景"></a>记录背景</h3><p>企微侧边栏是企业微信 PC 端，用于帮助运营和管理人员，提供工具服务，来协助管理对应的群和客户。<br>在进入外部群或者外部联系人会话的时候，输入栏右上方才会有的侧边栏图标。<br>点击侧边栏图标，会在弹窗右侧出现一个定宽(360px)不定高的 webview。<br>而开发者可以以开发企微 H5 应用的形式对其进行开发。</p>
<p>这个侧边栏出发点确实是好的，不过其开发和调试环境实在是过于恶劣，<br>可能也因为该功能也是刚开始开发给客户，里面有很多隐藏的坑。<br>而且官方文档比较模糊，全靠开发者的悟性，企微自身的 bug 让开发浪费了很多时间，也背了无数的锅。<br>借此记录一下，以免后续开发同学免去踩这些坑。</p>
<a id="more"></a>

<h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><ol>
<li><p>企微后端管理平台创建好<code>自建应用</code>，且需要将该应用设置为侧边栏项目<code>配置到聊天侧边栏</code></p>
<p>建议将侧边栏设置为第一项。（如需有跳转群操作，侧边栏只会默认打开第一项侧边栏）</p>
</li>
<li><p>该应用需要把<code>网页授权及JS-SDK</code>设置好可信域名</p>
<p>即，初次设置时会拿到一个 txt 秘钥文件，将该文件放置到域名的根目录下，再将域名输入到可信域名列表中，校验成功后即为配置成功。<br>该文件只会拿到一次，假如弄丢就只能删掉引用重建了。</p>
</li>
<li><p>侧边栏开发基础要求</p>
<p>侧边栏与企微 H5 很相似，都是需要经过 wx.config 与 wx.agentConfig 注入应用权限后才能使用对应 api 的。</p>
</li>
<li><p>跳转群会话实现传参</p>
<p>企微侧边栏无法使用路由带参跳转实现传参。<br>只能使用企微自带的 api 来通过 chatId 来进行跳转，<br>群会话跳转后，侧边栏的 webview 会销毁后重新创建。<br>所以路由只能为固定后台设置写死的 url。</p>
<p>目前方案为跳转群会话前先存入有效期缓存，<br>然后在新的会话加载侧边栏页面后，<br>让页面先读取缓存，如有对应缓存即为作为传参字段来实现。</p>
</li>
<li><p>侧边栏的缓存 Storage 仅为 2.5M，且业务对缓存极为依赖</p>
<p>侧边栏如有需求获取用户信息，<br>每次都需要走一遍 Auth 流程，跳转至企微授权页面，通过 code 来换取用户信息。<br>不过该操作如果有频繁切换会话的时候，会使用户体验很差，大概需要用时 1s-2s 白屏，如网络不稳定则白屏时间更长。</p>
<p>目前方案为第一次走该流程获取用户数据，并缓存下来，<br>后续使用缓存的用户数据，不再走登录流程。<br>如果企微更换用户登录，<br>则需要用户主动触发更换用户，或者通过接口返回异常来判断用户是否异常，而进行更换用户交互。</p>
</li>
</ol>
<h3 id="开发踩坑"><a href="#开发踩坑" class="headerlink" title="开发踩坑"></a>开发踩坑</h3><ol>
<li><p>侧边栏白屏</p>
<p>a) loading chunk {} failed<br>该问题疑似企微的 webview 功能不是很健全，一些现代浏览器的基本兼容都没有实现。<br>通过 webpack 打包的代码块没有加载成功。代码不完整导致白屏。<br>尝试通过生命周期捕获异常，尝试了如下几种方法，不过没有办法捕捉异常(即没有弹出 alert)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> forceRefresh = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'app forceRefresh'</span>, location.href)</span><br><span class="line">  <span class="comment">// 设置只强制刷行一次页面</span></span><br><span class="line">  <span class="keyword">if</span>(location.href.index0f(<span class="string">'#reloaded'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">    alert(<span class="string">`即将刷新页面`</span>)</span><br><span class="line">    location.href = location.href + <span class="string">'#reloaded'</span></span><br><span class="line">    <span class="built_in">window</span>.location.reload(<span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'请手动刷新页面!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">'app componentDidMount'</span>);</span><br><span class="line">  <span class="built_in">window</span>.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">`app DidMount <span class="subst">$&#123;JS0N.stringify(e)&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'window.onerror'</span>, e)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'app error'</span>, error,error &amp;&amp;error.message)</span><br><span class="line">    <span class="keyword">const</span> pattern = <span class="regexp">/Loading chunk (\d)+ failed/g</span></span><br><span class="line">    <span class="keyword">const</span> isChunkLoadFailed=error.message.match(patterr)</span><br><span class="line">    <span class="keyword">if</span> (isChunkLoadFailed) &#123;</span><br><span class="line">      forceRefresh()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  alert(<span class="string">`app DidCatch <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(error)&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'componentDidCatch'</span>, error, info)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">String</span>(error).includes(<span class="string">'Loading chunk'</span>)) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.reload()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidCatchError(error, info) &#123;</span><br><span class="line">  alert(<span class="string">`app DidCatchError <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(error)&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'componentDidCatchError'</span>, error, info)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">String</span>(error).includes(<span class="string">'Loading chunk'</span>)) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.reload()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目测这个 bug 在最新版的企微上好像没有再复现了，可能企微偷偷的修复该问题了。<br><img src="../../../../images/image_34_1.jpeg" alt="loading chunk {} failed"></p>
<p>b) wx is not defined<br>因为是通过异步 https 加载的 jweixin-1.2.0.js 文件，如果网络等原因 js 未加载成功，或加载过慢而 wx 对象异步操作被提前使用，<br>这个时候直接去调用 wx 对象即会报错，程序不在往后走，现象为白屏。<br>目前方案为，通过 try catch 来判断是否拿到 wx 对象，如果没有则等待一段时间，直至拿到 wx 对象。<br>如果一定时间内依然拿不到，就去动态新增 jweixin-1.2.0.js 脚本，去重新请求一次 js 文件。<br><img src="../../../../images/image_34_2.jpg" alt="wx is not defined"></p>
</li>
<li><p>调用跳转群会话 api，无法跳转异常群，且该回调也不会报错。<br>以下为异常群情况，<br>静默群：用户被拉入一个外部群，不过群里没人发言，该用户的会话列表不存在该群，是无感知的，不过后台群列表统计能拿到该群，则该群属于静默群。<br>解散群：群已解散。<br>目前方案为执行跳转后，在成功的回调通过该方法<code>wx.invoke(&#39;getContext&#39;)</code>和<code>wx.invoke(&#39;getCurExternalChat&#39;)</code>方法来判断。<br>如果真正的跳转成功，那么 webview 就会销毁后续逻辑不再执行，<br>如果真正的跳转失败，那么后续逻辑还会执行，判断当前群 chatId 和期望跳转 chatId 是否相同，<br>如果相同则算作正常；如果不相同，则算作异常群跳转失败。</p>
</li>
<li><p>Win/Mac 环境表现不一样。<br>Mac 支持 jweixin-1.6.0  版本引用。<br>Win 仅支持 jweixin-1.2.0 版本引用。（如引用 1.6.0 版本没有报错直接程序卡住白屏。通过打印日志 wx.agentConfig 为 undefined）</p>
<p>引用 jweixin-1.2.0 版本后。<br>官方文档说明从企业微信 3.0.24 及以后版本，无须先调用 wx.config，可直接 wx.agentConfig。</p>
<p>Mac 直接调用 wx.agentConfig 报错，一定需要再 wx.config 之后的 wx.ready 回调中使用，才能正常。<br>Win 则可以直接调用 wx.agentConfig。</p>
</li>
<li><p>配置较差电脑，如果输入栏内有信息不发出去，调用跳转群 api 会出现闪退情况。<br>该问题疑似企微自身 bug。</p>
</li>
<li><p>配置较差电脑，侧边栏使用跳转群 api 次数频繁后，电脑会慢慢越来越卡。<br>该问题疑似企微自身 bug。</p>
</li>
<li><p>连续发送文字、发送图片，图片有概率会出现在文字中间。<br>该问题疑似企微自身 bug。<br>目前方案为，发送文字后，通过一定时间的延迟再去发送下一个类型的消息。</p>
</li>
</ol>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://developer.work.weixin.qq.com/document/path/90514" target="_blank" rel="noopener">1. 引用 jweixin.js 版本</a></li>
<li><a href="https://developer.work.weixin.qq.com/tutorial/h5-application/1" target="_blank" rel="noopener">2. 快速集成 H5 项目</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/465436686" target="_blank" rel="noopener">3. 企业微信侧边栏</a></li>
<li><a href="https://www.cnblogs.com/chuaWeb/p/12430140.html" target="_blank" rel="noopener">4. 企业微信侧边栏功能/微信企业授权</a></li>
<li><a href="https://blog.csdn.net/hu_baobao/article/details/109120687" target="_blank" rel="noopener">5. Loading chunk failed 问题处理</a></li>
<li><a href="https://blog.csdn.net/u014505277/article/details/119181385" target="_blank" rel="noopener">6. 企业微信客户端 web 页面调试</a></li>
</ul>
]]></content>
      <tags>
        <tag>企业微信</tag>
      </tags>
  </entry>
  <entry>
    <title>32.企业微信小程序开发记录</title>
    <url>/2022/04/10/32-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="记录背景"><a href="#记录背景" class="headerlink" title="记录背景"></a>记录背景</h3><p>接触企微小程序也大概有一年多了，<br>一直想要找时间想把开发企微小程序的一些相关知识复盘一下，<br>整理之后，作为技术积累。</p>
<a id="more"></a>

<h3 id="企微小程序体验版不同分享渠道的体现"><a href="#企微小程序体验版不同分享渠道的体现" class="headerlink" title="企微小程序体验版不同分享渠道的体现"></a>企微小程序体验版不同分享渠道的体现</h3><p>企微小程序是有两套体验版的：<br>一是通过官方文档说明的，<br>通过小程序右上角胶囊按钮的分享，<br>点击配置体验版，以邀请体验版的形式发出来的体验版。</p>
<p>二是通过开发工具点击上传按钮，<br>通过小程序后台配置小程序的体验版，<br>以企业微信扫描这个体验版二维码即可进入体验版。</p>
<p>需要说明的是，这两套体验版是隔离的，可以部署两套代码，给测试、产品同学同步测试验收。</p>
<p>同时，这两套体验版的体验权限设置也是有区别的：<br>企微邀请体验版的体验权限，是在邀请的时候设置的；<br>通过扫体验版二维码的体验权限，是在小程序后台<code>成员管理</code>=&gt;<code>体验成员</code>处设置的。</p>
<p>PS：不同企业，同一个企微小程序，以邀请体验版的形式发出来的体验版也是相互隔离的。</p>
<h3 id="企微邀请体验版的生效周期"><a href="#企微邀请体验版的生效周期" class="headerlink" title="企微邀请体验版的生效周期"></a>企微邀请体验版的生效周期</h3><p>在企微邀请体验版的时候，一定要记住点击<code>更新版本</code>按钮。<br>不然分享出去还会是以前的老版本。</p>
<p>在企微邀请体验版的时候，如果调整体验权限名单，那么体验版就会自动更新到当前的模拟器的开发版本。<br>等效于点击了<code>更新版本</code>按钮。</p>
<h3 id="点击体验链接时候，报错“打开失败-内部错误”"><a href="#点击体验链接时候，报错“打开失败-内部错误”" class="headerlink" title="点击体验链接时候，报错“打开失败 内部错误”"></a>点击体验链接时候，报错“打开失败 内部错误”</h3><p>疑似企业微信自身 bug。<br>解决方法：开发者工具重新点击预览，扫码后，重新配置体验版，<br>在配置小程序体验版页面的时候，<br>一定先等页面完全加载完毕后，即上方加载进度条加载完毕，<br>才可以点击“更新版本”。</p>
<p>为保险起见，第一次只邀请给自己查看。如能够成功打开，再分享一次给大家。如不成功则重复该步骤。</p>
<h3 id="wx-saveImageToPhotosAlbum-API-踩坑"><a href="#wx-saveImageToPhotosAlbum-API-踩坑" class="headerlink" title="wx.saveImageToPhotosAlbum API 踩坑"></a>wx.saveImageToPhotosAlbum API 踩坑</h3><p>通过企微邀请体验版进入，<br>没有小程序后台体验权限的账号，安卓手机调用保存相册 API，会保存白色图片。<br>没有小程序后台体验权限的账号，苹果手机则一切正常。</p>
<h3 id="wx-saveImageToPhotosAlbum-API-踩坑-1"><a href="#wx-saveImageToPhotosAlbum-API-踩坑-1" class="headerlink" title="wx.saveImageToPhotosAlbum API 踩坑"></a>wx.saveImageToPhotosAlbum API 踩坑</h3><p>保存图片需要企业微信对相册授权全部权限。否则即使保存成功，也会返回报错信息。</p>
<h3 id="开发者工具调用-wx-qy-login-报-invoke-result-qy-login-qy-login-fail，真机正常"><a href="#开发者工具调用-wx-qy-login-报-invoke-result-qy-login-qy-login-fail，真机正常" class="headerlink" title="开发者工具调用 wx.qy.login 报 invoke result:qy.login,qy.login:fail，真机正常"></a>开发者工具调用 wx.qy.login 报 invoke result:qy.login,qy.login:fail，真机正常</h3><p>确认自身网络环境，如网络环境正常，则可能微信 api 挂掉了。坐等官方修复。</p>
<h3 id="wx-qy-shareToExternalMoments-API-踩坑"><a href="#wx-qy-shareToExternalMoments-API-踩坑" class="headerlink" title="wx.qy.shareToExternalMoments API 踩坑"></a>wx.qy.shareToExternalMoments API 踩坑</h3><p>发布人可以通过这个接口无限制发布到朋友圈，不过一天内，客户只能看到 3 条。<br>如果发布人手动发多条，一天内，客户也只能看到 3 条。<br>这个应该是企微的自身设定。</p>
<h3 id="wx-qy-shareToExternalMoments-API-回调方法踩坑"><a href="#wx-qy-shareToExternalMoments-API-回调方法踩坑" class="headerlink" title="wx.qy.shareToExternalMoments API 回调方法踩坑"></a>wx.qy.shareToExternalMoments API 回调方法踩坑</h3><p>官方文档是通过传入第二个参数来作为方法的回调，不过实测毫无效果。<br>通过查询社群帖子遇到大佬帮忙解惑。<br>跟大多数微信 api 的机制相似，也是在传入对象的 success,fail,complete 这些字段以实现对应的回调。<br>其实如果文档不写传入第二个参数示例代码反而不会被带偏，这个就很是坑爹了。<br><img src="../../../../images/image_32_1.jpg" alt="官方文档错误以及修改方案"></p>
<h3 id="弹窗内有-Input-，输入后，关闭弹窗-Input-输入内容不消失"><a href="#弹窗内有-Input-，输入后，关闭弹窗-Input-输入内容不消失" class="headerlink" title="弹窗内有 Input ，输入后，关闭弹窗 Input 输入内容不消失"></a>弹窗内有 Input ，输入后，关闭弹窗 Input 输入内容不消失</h3><p>目测为企微小程序存在的 bug，同样代码放到微信小程序没有复现。<br>异常情况如下图所示：<br><img src="../../../../images/image_32_2.png" alt="Input异常1"><br><img src="../../../../images/image_32_3.png" alt="Input异常2"></p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://developer.work.weixin.qq.com/document/path/92380" target="_blank" rel="noopener">1. 小程序体验版配置</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/0000c0d9be84d82a990c4902756400?highline=invoke%20result%3Aqy.login,qy.login%3Afail" target="_blank" rel="noopener">2. 2021 年 4 月 23 日微信开发者工具无法调用 wx.qy.login 进行企业微信登录</a></li>
<li><a href="https://developers.weixin.qq.com/community/enterprisewechat/doc/000e22cd200f005fb6eca583b51400" target="_blank" rel="noopener">3. 企业微信分享客户朋友圈 shareToExternalMoments 没法获取成功或失败状态？</a></li>
</ul>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>企业微信</tag>
      </tags>
  </entry>
  <entry>
    <title>33.微信小程序插件开发记录</title>
    <url>/2022/04/16/33-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="记录背景"><a href="#记录背景" class="headerlink" title="记录背景"></a>记录背景</h3><p>其实微信小程序插件，一直想要学习研究。<br>可是插件又不会对小程序个人开发者开放，没办法用自己的小程序来研究。</p>
<p>在上家公司的时候，没有参与到插件开发的小组内，甚是遗憾。<br>正好这次有个项目机会用到了小程序插件，<br>赶紧把握机会玩耍了一波。</p>
<p>感觉这个插件功能，在对多个小程序都可以复用的场景，还是很有帮助的。</p>
<a id="more"></a>

<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><p>通过开发插件的体验，我自己总结了一下插件的开发规则：</p>
<ol>
<li>插件需要挂载一个符合指定类目的小程序下开发。（个人小程序不允许开发插件）</li>
<li>插件的版本号只能递增且不能重复。已发布的版本会永远在线上列表内。可以通过设置来控制用户使用插件的最低版本。(说明文档只会展示最新版本)</li>
<li>插件的体验版版本号，只在模拟器上传之后会出现，注意复制保存。（小程序引用体验版的时候，版本号前面需要追加<code>dev-</code>）</li>
<li>插件和小程序内存相互独立，想要通讯只能通过传参，互相无法直接读取到对方的缓存等信息。</li>
<li>插件像是一个更高纬度的组件，其支持开发页面、组件、方法。业务小程序可通过引用插件来对插件的页面、组件、方法进行调用。</li>
<li>插件的大小会被业务小程序主包、子包计算在内，也会受到 2M 的限制，所以组件如果太大会影响业务小程序的调用。（貌似只有直播插件不会计算在内）</li>
<li>插件被业务小程序调用的时候，要么放在全局（占用主包大小），如果放到指定子包（占用指定子包大小）则只有这个子包可以使用，其他子包无法引用该插件也无法运用该插件。</li>
<li>插件的一些小程序 api 会无法使用如登录、鉴权等，具体详情可见下方文档。</li>
<li>插件的安全域名与业务小程序的安全域名是相互独立的。即：插件功能需要接口通讯时，需要在插件后台配置域名列表配置对应域名；而调用插件的业务小程序则无需配置插件功能所需的域名，直接引用插件功能即可实现接口通讯。</li>
</ol>
<h3 id="插件项目结构介绍"><a href="#插件项目结构介绍" class="headerlink" title="插件项目结构介绍"></a>插件项目结构介绍</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README<span class="selector-class">.md</span>                   <span class="comment">// 项目README</span></span><br><span class="line">├── doc</span><br><span class="line">│   └── README<span class="selector-class">.md</span>               <span class="comment">// 插件使用文档，用于上传到插件介绍</span></span><br><span class="line">├── miniprogram                 <span class="comment">// 开发时测试用小程序</span></span><br><span class="line">│   ├── app.js</span><br><span class="line">│   ├── app.json</span><br><span class="line">│   ├── pages</span><br><span class="line">│   │   └── index</span><br><span class="line">├── plugin                      <span class="comment">// 插件代码</span></span><br><span class="line">│   ├── components              <span class="comment">// 插件暴露出来的组件目录</span></span><br><span class="line">│   │   └── comTest</span><br><span class="line">│   │       ├── comTest.js</span><br><span class="line">│   │       ├── comTest.json</span><br><span class="line">│   │       ├── comTest.wxml</span><br><span class="line">│   │       └── comTest.wxss</span><br><span class="line">│   ├── functions               <span class="comment">// 插件暴露出来的方法目录</span></span><br><span class="line">│   │   └── funTest.js</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── pages</span><br><span class="line">│   │   └── pageTest            <span class="comment">// 插件暴露出来的页面目录</span></span><br><span class="line">│   │       ├── pageTest.js</span><br><span class="line">│   │       ├── pageTest.json</span><br><span class="line">│   │       ├── pageTest.wxml</span><br><span class="line">│   │       └── pageTest.wxss</span><br><span class="line">│   ├── plugin<span class="selector-class">.json</span>             <span class="comment">// 配置插件暴露出来的页面、组件、方法目录</span></span><br><span class="line">│   └── utils                   <span class="comment">// 插件内部使用的公共方法</span></span><br><span class="line">└── project<span class="selector-class">.config</span>.json</span><br></pre></td></tr></table></figure>

<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/" target="_blank" rel="noopener">1. 微信小程序插件介绍</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/development.html" target="_blank" rel="noopener">2. 开发插件</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/introduction/plugin.html" target="_blank" rel="noopener">3. 小程序插件功能介绍</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/api-limit.html" target="_blank" rel="noopener">4. 插件调用 API 的限制</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/" target="_blank" rel="noopener">5. 自定义组件</a></li>
</ul>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>37.简单聊一聊ESLint的相关内容</title>
    <url>/2022/09/09/37-%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%80%E8%81%8AESLint%E7%9A%84%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h3 id="讲个笑话"><a href="#讲个笑话" class="headerlink" title="讲个笑话"></a>讲个笑话</h3><p>最近开发自己的项目的时候，感觉自己如有神助，<br>写出来的代码，编译器竟然一个报错有没有。<br>正暗自感慨自身的技术，竟在不知不觉之中已然出神入化，<br>瞥了一眼，发现编译器的 ESLint 正在疯狂的报错。😒😒😒</p>
<a id="more"></a>

<h3 id="eslintrc-参考配置"><a href="#eslintrc-参考配置" class="headerlink" title=".eslintrc 参考配置"></a>.eslintrc 参考配置</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: [<span class="string">"taro/react"</span>],</span><br><span class="line">  <span class="attr">"parserOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"ecmaFeatures"</span>: &#123;</span><br><span class="line">      <span class="attr">"jsx"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"tsx"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"useJSXTextNode"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"useTSXTextNode"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">    <span class="attr">"react/jsx-uses-react"</span>: <span class="string">"off"</span>,</span><br><span class="line">    <span class="attr">"react/react-in-jsx-scope"</span>: <span class="string">"off"</span>,</span><br><span class="line">    <span class="attr">"no-const-assign"</span>: <span class="number">2</span>, <span class="comment">// 禁止修改const声明的变量</span></span><br><span class="line">    <span class="attr">"no-fallthrough"</span>: <span class="number">1</span>, <span class="comment">// 禁止switch穿透</span></span><br><span class="line">    <span class="attr">"no-func-assign"</span>: <span class="number">2</span>, <span class="comment">// 禁止重复的函数声明</span></span><br><span class="line">    <span class="attr">"no-multiple-empty-lines"</span>: [<span class="number">1</span>, &#123; <span class="attr">"max"</span>: <span class="number">2</span> &#125;], <span class="comment">// 空行最多不能超过2行</span></span><br><span class="line">    <span class="attr">"no-param-reassign"</span>: <span class="number">2</span>, <span class="comment">// 禁止给参数重新赋值</span></span><br><span class="line">    <span class="attr">"no-mixed-spaces-and-tabs"</span>: [<span class="number">2</span>, <span class="literal">false</span>], <span class="comment">// 禁止混用tab和空格</span></span><br><span class="line">    <span class="attr">"no-sequences"</span>: <span class="number">0</span>, <span class="comment">//禁止使用逗号运算符</span></span><br><span class="line">    <span class="attr">"no-unneeded-ternary"</span>: <span class="number">2</span>, <span class="comment">// 禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span></span><br><span class="line">    <span class="attr">"no-unused-vars"</span>: [<span class="number">1</span>, &#123; <span class="attr">"vars"</span>: <span class="string">"all"</span>, <span class="attr">"args"</span>: <span class="string">"after-used"</span> &#125;], <span class="comment">// 不能有声明后未被使用的变量或参数</span></span><br><span class="line">    <span class="attr">"no-var"</span>: <span class="number">0</span>, <span class="comment">// 禁用var，用let和const代替</span></span><br><span class="line">    <span class="attr">"arrow-parens"</span>: <span class="number">0</span>, <span class="comment">// 箭头函数用小括号括起来</span></span><br><span class="line">    <span class="attr">"arrow-spacing"</span>: <span class="number">0</span>, <span class="comment">// =&gt;的前/后括号</span></span><br><span class="line">    <span class="attr">"curly"</span>: [<span class="number">2</span>, <span class="string">"all"</span>], <span class="comment">// 必须使用 if()&#123;&#125; 中的&#123;&#125;</span></span><br><span class="line">    <span class="attr">"default-case"</span>: <span class="number">2</span>, <span class="comment">// switch语句最后必须有default</span></span><br><span class="line">    <span class="attr">"eqeqeq"</span>: <span class="number">2</span>, <span class="comment">// 必须使用全等</span></span><br><span class="line">    <span class="attr">"init-declarations"</span>: <span class="number">0</span>, <span class="comment">// 声明时必须赋初值</span></span><br><span class="line">    <span class="attr">"import/order"</span>: <span class="number">1</span>, <span class="comment">// import顺序有误</span></span><br><span class="line">    <span class="attr">"import/no-commonjs"</span>: <span class="number">0</span>, <span class="comment">// 忽略require使用告警</span></span><br><span class="line">    <span class="attr">"import/no-named-as-default"</span>: <span class="number">0</span> <span class="comment">// 忽略默认导出方法的名称</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="prettierrc-参考配置"><a href="#prettierrc-参考配置" class="headerlink" title=".prettierrc 参考配置"></a>.prettierrc 参考配置</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsxSingleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"printWidth"</span>: <span class="number">150</span>,</span><br><span class="line">  <span class="attr">"tabWidth"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"semi"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"singleQuote"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"trailingComma"</span>: <span class="string">"none"</span>,</span><br><span class="line">  <span class="attr">"jsxBracketSameLine"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"arrowParens"</span>: <span class="string">"always"</span>,</span><br><span class="line">  <span class="attr">"quoteProps"</span>: <span class="string">"preserve"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://blog.csdn.net/chengqiuming/article/details/109958407" target="_blank" rel="noopener">1. ESLint 简介</a></li>
<li><a href="https://blog.csdn.net/resolverr/article/details/109495981" target="_blank" rel="noopener">2. vscode 中关于 eslint 的各种报黄线错误</a></li>
</ul>
<p>😈 没错，我水了一贴</p>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>3.关于Taro框架中Redux的使用方法</title>
    <url>/2020/06/20/3-%E5%85%B3%E4%BA%8ETaro%E6%A1%86%E6%9E%B6%E4%B8%ADRedux%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="关于-Redux"><a href="#关于-Redux" class="headerlink" title="关于 Redux"></a>关于 Redux</h3><p>个人认为，一些轻量级的项目是完全用不到 Redux。<br>简单的单例出一个全局变量管理器，就可以满足项目的需要。<br>不过如果项目一旦沉重起来，需求逻辑繁琐，父子组件通讯错综复杂，<br>开发人员思路又不统一，<br>这个时候如果只是使用全局变量管理，<br>那么数据随时都可能被更改，全局变量将会成为一团乱麻，变得不可被信任。<br>项目的迭代和维护成本也将会迎来指数级的上升，<br>如果这个时候能有一个全局的对象，<br>可随时被观察状态，只能用特殊方式修改状态，<br>将会对项目的维护非常有帮助。<br>而这也就是 Redux。</p>
<a id="more"></a>

<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://taro-docs.jd.com/taro/docs/redux/" target="_blank" rel="noopener">Taro 的 Redux 官方文档</a></p>
<h3 id="Redux-数据流程图"><a href="#Redux-数据流程图" class="headerlink" title="Redux 数据流程图"></a>Redux 数据流程图</h3><p>借用网上流传的图片，发现有个箭头的遗漏，<br>一切起源是因为组件触发了 action，<br>才引发了这一系列的流程。<br><img src="../../../../images/image_3_1.jpg" alt="Redux数据流程图"></p>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ol>
<li>准备好仓库 state。（只操作一次，聚合所有数据）</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">"redux-thunk"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createLogger &#125; <span class="keyword">from</span> <span class="string">"redux-logger"</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">"../reducers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = [thunkMiddleware, createLogger()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer, applyMiddleware(...middlewares));</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>准备一个数据对象。<br>举个例子，我准备将主页的相关信息都存储在仓库的这个对象里 MainPageInfo。<br>所以我会创建 3 个文件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../actions/MainPageInfo.ts    <span class="comment"># 做逻辑处理</span></span><br><span class="line">../constants/MainPageInfo.ts  <span class="comment"># 更新Redux标记</span></span><br><span class="line">../reducers/MainPageInfo.ts   <span class="comment"># 小片段的数据，处理数据，更新数据</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>准备好对这个对象操作的指令代号。<br>我会将指令代号以及类型声明存放在这个文件中。<br>../actions/MainPageInfo.ts</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切换主页底部导航</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_MAIN_PAGE_SELECT: <span class="built_in">string</span> = <span class="string">"SET_MAIN_PAGE_SELECT"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> MainPageInfoType = &#123;</span><br><span class="line">  nSelectIndex: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>准备对这个对象的行动。<br>我会将所需要的操作存放在这个文件中。<br>../actions/MainPageInfo.ts</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SET_MAIN_PAGE_SELECT &#125; <span class="keyword">from</span> <span class="string">"@/constants/MainPageInfo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setMainPageSelect</span>(<span class="params">nSelectIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: SET_MAIN_PAGE_SELECT,</span><br><span class="line">    nMainPageSelect: nSelectIndex,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setMainPageSelect,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>准备对这个对象数据的改动。<br>我会将操作之后的数据改动放在这个文件中。<br>../reducers/MainPageInfo.ts</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SET_MAIN_PAGE_SELECT &#125; <span class="keyword">from</span> <span class="string">"@/constants/MainPageInfo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INITIVAL_STATE = &#123;</span><br><span class="line">  nSelectIndex: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MainPageInfo</span>(<span class="params">state = INITIVAL_STATE, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_MAIN_PAGE_SELECT:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        nSelectIndex: action.nMainPageSelect,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>准备阶段完毕<br>那么准备阶段完毕，<br>我可以通过 setMainPageSelect 方法传入的参数，<br>来修改 store.MainPageInfo.nSelectIndex<br>而此时我的期望数据结构就会是这样。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">store = &#123;</span><br><span class="line">  MainPageInfo: &#123;</span><br><span class="line">    nSelectIndex: <span class="built_in">number</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 Taro 中运用<br>其实 TS 近乎强迫症的语法，在这一步折腾了好久，不断的在语法错误提示中挣扎。<br>在参考了多方资料之后，总算摸索出来一套不再错误提示的写法。<br>示例是用最基本的方法来操作 Redux。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  connect</span><br><span class="line">&#125; from &#39;@tarojs&#x2F;redux&#39;;</span><br><span class="line">import &#123;</span><br><span class="line">  MainPageInfoType</span><br><span class="line">&#125; from &#39;@&#x2F;constants&#x2F;MainPageInfo&#39;;</span><br><span class="line">import &#123;</span><br><span class="line">  setMainPageSelect,</span><br><span class="line">&#125; from &#39;@&#x2F;actions&#x2F;MainPageInfo&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型声明：传递过来的变量</span><br><span class="line">type PageStateProps &#x3D; &#123;</span><br><span class="line">  MainPageInfo: MainPageInfoType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型声明：传递过来的dispatch方法</span><br><span class="line">type PageDispatchProps &#x3D; &#123;</span><br><span class="line">  setMainPageSelect: (nSelectIndex: number) &#x3D;&gt; any;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型声明：传递过来的普通方法</span><br><span class="line">type PageOwnProps &#x3D; &#123; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型声明：组件内变量</span><br><span class="line">type PageState &#x3D; &#123; &#125;;</span><br><span class="line"></span><br><span class="line">type IProps &#x3D; PageStateProps &amp; PageDispatchProps &amp; PageOwnProps;</span><br><span class="line"></span><br><span class="line">type IState &#x3D; PageState;</span><br><span class="line"></span><br><span class="line">@connect(</span><br><span class="line">  (&#123; MainPageInfo &#125;) &#x3D;&gt; (&#123;</span><br><span class="line">    MainPageInfo</span><br><span class="line">  &#125;),</span><br><span class="line">  dispatch &#x3D;&gt; (&#123;</span><br><span class="line">    setMainPageSelect (nSelectIndex: number) &#123;</span><br><span class="line">      dispatch(setMainPageSelect(nSelectIndex));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">export default class Main extends Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 测试按钮</span><br><span class="line">  handleTestClick () &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      MainPageInfo,</span><br><span class="line">      setMainPageSelect</span><br><span class="line">    &#125; &#x3D; this.props;</span><br><span class="line">    console.log(&#39;handleTestClick before.&#39;, MainPageInfo);</span><br><span class="line">    setMainPageSelect(9999);</span><br><span class="line">    console.log(&#39;handleTestClick after.&#39;, MainPageInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  render () &#123;</span><br><span class="line">    (</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不能直接的去修改 store 中的数据，<br>我们可以触发 handleTestClick，<br>通过 dispatch，调用 setMainPageSelect 方法，<br>来对 store.MainPageInfo.nSelectIndex 的数值进行修改。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>前端的框架语法更新很快，<br>React 16.8 版本新增了 React Hook 的写法。<br>这也让操作 Redux 的方式更加灵活了。<br>我会在接下来的时间里研究一下 Hook 的写法，整理出来。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>36.调研微信链接卡片分享总结</title>
    <url>/2022/05/24/36-%E8%B0%83%E7%A0%94%E5%BE%AE%E4%BF%A1%E9%93%BE%E6%8E%A5%E5%8D%A1%E7%89%87%E5%88%86%E4%BA%AB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="调研背景"><a href="#调研背景" class="headerlink" title="调研背景"></a>调研背景</h3><p>其实在微信的群里，总能看到一些分享的微信卡片。<br>潜移默化之下以为这就是一个很容易的事情，<br>实际真正想要发链接的时候，只会发出来一串 url 的字符串，<br>经过调研之后，发现想要分享成微信卡片形式的话，发现还是很复杂的。<br>特此记录下来。</p>
<a id="more"></a>

<h3 id="分享总结"><a href="#分享总结" class="headerlink" title="分享总结"></a>分享总结</h3><ol>
<li>分享朋友圈只能分享标题、图片，描述没办法带上（微信限制）</li>
<li>实现卡片分享的入口，必须是从微信公众号点击字符串链接进入，或者字符串转二维码后通过扫二维码进入。<br>单纯的点击微信聊天字符串链接，是无法分享出卡片的（微信限制）</li>
<li>分享需要等页面加载 1 秒左右，需要完成微信的注册功能，自定义分享才能生效。<br>如果进入页面马上点分享就会分享成默认的。</li>
<li>只有公众号后台配置好域名才能实现分享卡片的功能。（公众号需要经过认证）</li>
<li>如果 link 字段绑定错误，微信分享卡片就会取默认分享文案，默认分享卡片规则如下：<ul>
<li>IOS 用户会取网页标题作为 title、网页 url 作为 desc、灰色兜底图片作为 imgUrl</li>
<li>安卓用户会取网页标题作为 title、网页 url 作为 desc、页面第一张图片作为 imgUrl</li>
</ul>
</li>
</ol>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="../../../../images/image_36_1.jpg" alt="微信卡片分享示例"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://blog.csdn.net/weixin_44646763/article/details/120689669" target="_blank" rel="noopener">1. 微信 h5 实现分享卡片</a></li>
</ul>
]]></content>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>38.整理一波前端面试的应知应会</title>
    <url>/2022/09/21/38-%E6%95%B4%E7%90%86%E4%B8%80%E6%B3%A2%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A/</url>
    <content><![CDATA[<h3 id="自由万岁"><a href="#自由万岁" class="headerlink" title="自由万岁"></a>自由万岁</h3><p>作为一个憧憬自由的射手座，<br>总是有一些作死的基因流淌在身体里面的。<br>毕竟人生总会有三大错觉：手机振动，她喜欢我、我还能跳。<br>可能也是嗅到了公司前景有些不是那么景气，<br>然后一时脑残冲动，选择了跳槽跑路，</p>
<p>确实享受了一次完美的没有后顾之忧的度假之旅，<br>同时也被行业的寒冬打击的体无完肤。<br>在这个时期裸辞找工作确实比较辛苦，真是为自己的骚操作买单。<br>整理了一波面试八股知识，也算是为这一阶段的面试情况做一个复盘。</p>
<a id="more"></a>

<p>标识意义如下：<br>🔴 频率高（面试中经常遇到）<br>🟠 频率中（面试中遇到过一次以上）<br>🟢 频率低（面试中遇到过一次）<br>⚪ 自己瞎捉摸、自己面试会可能会问到。可以酌情忽略</p>
<h3 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h3><p>🔴 简单说一下浏览器有哪些缓存：localstorage、sessionstorage、cookie。有什么区别？缓存大小限制？在你之前项目中分别在什么场景下使用？<br>🟢 有做过 SEO 相关经验么？<br>🟢 http 的强缓存、协商缓存都是什么<br>🟠 常见 http 协议状态码有哪些。200、301，401、404、500<br>⚪ 语义化标签有什么好处？h1 ~ h6 / code / pre / nav / aside / section / strong<br>⚪ Canvas、video、audio、是否有使用过？如何 api 绘图 Canvas？如何 api 操作多媒体？点击 video 自动全屏且播放如何实现？</p>
<h3 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h3><p>🔴 了解盒子模型么。<br>从内到外 content / padding / border / margin<br>配合属性 box-sizing / width / height<br>🔴 大小两个元素，小元素在大元素中如何实现垂直水平居中。<br>（文档流内 flex / 脱离文档流 position: absolute;top: 0;left: 0;right: 0;bottom: 0）<br>🟢 实现三个模块，左右模块固定宽度，中间宽度自适应如何实现。（用过 flex 布局么？对应参数的意义）<br>🟢 如何画个圆、画个三角。<br>🟢 给一段文本，超过 100px 就要省略号，怎么实现？多行文本省略号呢（有什么限制）？<br>🟢 是否遇到过一像素问题？<br>🟢 渐变效果分几种？线性渐变、径向渐变<br>🟢 了解 BFC(块格式化上下文)么？<br>🟢 讲讲你对 CSS 思维 原子化的理解？组件化的理解？<br>⚪ 缩放需要用什么属性，通过 transform:scale(0.5) 缩放缩小后，实际占用的空间缺没有变化，你会如何处理。<br>⚪ transform: rotate(70deg) translate(100px, 200px); 请问这种书写方法是先旋转再位移，还是先位移再旋转<br>⚪ 如果我想将元素设置半透明有几种处理方式，他们有什么区别？opacity: 0.5 / background-color: rgba(0, 0, 0, 0.5)<br>⚪ 如果一个元素宽度是动态的为当前浏览器的 50%，宽高比始终保持 16:9，如何通过 CSS 实现？aspect-ratio: 16 / 9;<br>⚪ 有用 css 实现过动画么？了解贝塞尔曲线么？通过控制曲线上的四个点（起始点、终止点以及两个相互分离的中间点）来创造、编辑图形。</p>
<h3 id="三、JS"><a href="#三、JS" class="headerlink" title="三、JS"></a>三、JS</h3><p>🔴 你用过那些 ES6 的新特性。定义变量、扩展元素符…对象解构<br>🔴 数据精度丢失，0.1 + 0.2 = ?。为什么会有这个情况? 项目中是如何处理的? 如果两个数的小数位数不同的时候，要如何处理? 如果小数位数过多，乘以 10 的 n 次幂数据过大如何处理? （后面恶心问题也基本不会追问）<br>🟢 暂时性死区了解过么？变量提升了解过么？<br>⚪ 有用过序列化，反序列化么？什么场景下会用到？需要注意什么。应当放在 try…catch 内会安全一些。<br>序列化时应当注意对象中是否有循环引用字段(其中对象字段的值是自己)，否则直接报错；<br>反序列化时，以防传入的是非法 JSON 格式字符，也会导致直接报错；<br>⚪ 有用过编码，解码相关 api 么？什么场景下会用到？可以解决路由传值时，中文参数的乱码问题。</p>
<p>🔴 简单说一下你对 Promise 的一个理解，解决了什么问题。如何将其改为同步实现。<br>有一个场景同时调用多个接口你会如何实现？Promise.all<br>那假如其中的一个接口报错如何处理？Promise.allsettled，或者每个接口都有 try…catch 。Promise.race 是做什么的？<br>手写 Promise 的思路，实现链式调用，有三种状态且成功失败后则状态凝固，两个入参实现其回调，等等。<br>🟢 应用过 generator、yield 么？<br>⚪ 使用过 async await 么? 如果想在循环中使用，应当如何操作？for 可以么？forEach 可以么？for await of 了解过么？</p>
<p>🟢 简单说一下 Set 、 Map 数据结构都是什么，Map 和 Object 有什么区别，之前项目中分别在什么场景会用到？<br>🟢 了解过设计模式么，有在项目中实际应用么？装饰器模式，工厂模式，单例模式，观察者模式。<br>🟢 RESTFUL 接口规范。GET POST 有什么不一样的地方？<br>🟢 说说想实现数组的循环有哪些方式？for in .of while forEach map reduce 哪种效率最快？</p>
<p>🔴 数组相关操作 api。<br>数组筛选，遍历，取输入前三个，slice \ splice<br>数组的哪些 API 会改变原数组？不会改变：concat、every、some、filter、indexOf、join、toString、lastIndexOf、map、slice、valueOf。会改变：pop、push、shift、unshift、reverse、sort、splice</p>
<p>🟢 讲讲你对宏任务与微任务的理解？<br>🟢 setTimeout,setInterval 会有时间偏差？requestAnimationFrame 是否用过？</p>
<p>🔴 了解什么是深拷贝么？<br>简单的通过 JSON.parse / JSON.stringify 处理。<br>复杂的，如果涉及到字段包含方法的，就需要递归实现。<br>手写深拷贝说出思路，函数如何拷贝，数组如何拷贝，对象如何拷贝。<br>如何判断对象中的字段是数组，对象。typeof / instanceof<br>typeof 判断所有变量的类型，返回值有 number、string、boolean、function、object、undefined。typeof 对于丰富的对象实例，只能返回 object，导致有时候得不到真实的数据类型。<br>instanceof 可以对不同的实例对象进行判断，判断方法是根据对象的原型链依次向上查询。<br>🟢 递归应该注意什么？边界，明确条件返回。</p>
<p>🟠 讲一讲你对原型链的理解，平时开发过程中有对原型链操作过么？<br>当函数自身有相应的方法或者属性时就用自己的，当自身没有时才通过<em>proto</em>原型链查找。<br>封装或者调整公共的方法绑定到一种类型变量上。比如：实现工厂模式设计模式的时候，可以把一些基础的方法挂在到工厂类的方法里，然后实例化工厂类的对象，则天然就会携带这些刚刚的基础方法。</p>
<p>🟠 什么是闭包，平时开发中什么场景会用到闭包？比如：写防抖节流时，存储定时器的变量不去污染全局。<br>🟠 普通函数和箭头函数有什么区别？箭头函数不能用于 new，this 指向不同：普通函数指向调用该函数的对象，箭头函数根据声明的位置决定 this<br>🟢 apply、bind、call 有什么区别？<br>都是可以实现改变函数内部 this 的指向。第一个参数都是 this 要指向的对象。<br>第二个参数：apply 是以数组形式传入、bind、call 则是以平铺参数传入。bind 直接改变了绑定的函数<br>箭头函数能否使用 apply、bind、call？不能。</p>
<p>🟢 讲讲为什么会有内存泄漏，什么情况下会有内存泄漏的风险？<br>内存泄漏：闭包、未注销事件/定时器、直接使用函数内未定义变量会绑定到全局对象 window<br>常见的内存垃圾回收机制 GC 清理算法：</p>
<ol>
<li>引用计数。为每个对象设置引用数字，引用关系变化时引用计数器会修改对应的引用数字，引用数字为 0 时立即回收。 缺点：无法回收循环引用的对象。</li>
<li>标记清除。定期遍历所有对象并标记活动对象（可达对象），然后将不可到达的对象释放掉。缺点：容易产生碎片化空间，浪费空间，不会立即回收垃圾对象，清除垃圾对象时程序暂停。</li>
<li>标记整理。标记清除可以看作是标记清除的增强。标记的阶段和标记清除一致。清除阶段会先执行整理，移动对象位置。</li>
</ol>
<p>🟠 用过 TS 么？有哪些基本类型？写过泛型么？</p>
<p>🔴 以往项目中有埋点相关业务么？是如何实现的？第三方/自研接口？<br>第三方会有引用埋点包后有实现自动上传数据的功能。比如点击元素自动埋点上传、页面跳转自动埋点上传，而这些不需要开发者额外写代码，你知道是如何实现的么？</p>
<p>🟢 基础变量相关<br>var a = ‘a’<br>var b = new String(‘a’)<br>a == b // true<br>a === b // false<br>a、b 分别是如何在内存中存放的<br>Const b = new String(a)<br>a、b 分别是如何内存中存放的<br>a = ‘c’<br>那么，b 的内容是否会发生变化？</p>
<p>🟢 基础函数相关<br>var a = function () {}<br>function b () {}<br>var c = new function()<br>分别解释一下这三种方式 js 内部是如何实现的？<br>js 编译器是如何解析声明函数的？</p>
<p>🟢 基础算法相关<br>🟢 手写 字符串转数字 思路<br>🟢 手写 快速排序 思路<br>🟢 手写 将一个数组顺序随机打乱 思路<br>🟢 手写 统计一个字符串中 每个字符出现的次数 思路<br>⚪ 手写 反转链表 思路</p>
<h3 id="四、框架相关"><a href="#四、框架相关" class="headerlink" title="四、框架相关"></a>四、框架相关</h3><p>🔴 能简单说一下 MVVM 模型的概念么？<br>🔴 Vue 生命周期都有哪些？在对应生命周期适合做那些事情？<br>🔴 Vue watch 和 computed 有什么区别？watch 深度监听数组、对象如何处理？computed 缓存计算结果优化性能。那么在你之前工作项目中什么场景会用到了 watch，什么场景用到了 computed？<br>🟠 Vue 、React 你觉得有什么不同，你更喜欢用哪个。<br>🟠 Vue3 有使用过么？Vue3 和 2 相比有什么区别？<br>🟠 Vue 数据双向绑定的原理是什么？Vue2 是通过 Object.defineProperty，Vue3 是通过 Proxy 分别有什么优缺点？<br>🟠 了解过路由守卫么？平时项目中什么场景会用到？<br>🟢 缓存页面状态应该用什么？keep-alive 用过么？keep-alive 如果单独想要缓存几个页面如何处理？<br>🟢 Vue 使用过动态组件么？<br>⚪ input 标签的 v-module 是如何实现数据双向绑定的。<br>⚪ Vue 文件中 template、style、script 哪些是必须的？template 必须，style、script 没有也可编译通过。<br>⚪ Vue 用有 watch 这个概念，那 React 中，传入子组件字段变化，组件渲染逻辑跟着变化，怎么实现？componentDidUpdate 无法实现深度监听如何处理？</p>
<p>🔴 React 生命周期都有哪些？在对应生命周期适合做那些事情？<br>🔴 父子组件如何传值、兄弟组件如何传值。<br>🟠 React 的 this.setState 是同步还是异步？setState 为什么合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步的？<br>🟠 React 的 useEffect()封装了什么生命周期？<br>🟠 React 的 useCallback()什么场景会用到？与 useMemo()相比有什么区别。<br>🟠 用过 Hook 么？为什么诞生了 hook，是为了解决什么问题。<br>🟠 有用过 React 高阶组件么？封装组件，可以实现对参数透传。<br>🟢 React 的 Hook 可以在循环中使用么？那可以再条件判断中使用么？为什么？<br>🟢 React 的版本平时用的是多少？16、17、18 分别有哪些更新？<br>🟢 React 的 useState 和 this.setState 有什么区别？useState 只能改变绑定的变量，this.setState 可以一次性修改多个变量。<br>⚪ React 的绑定的事件和原生事件一样么？不一样，原生的消息继承自 MouseEvent，React 的消息继承自 SyntheticEvent（合成事件）。event.nativeTarget 是真正的原生消息。</p>
<p>🔴 说一下你对 Redux/Vuex 的理解。状态机，把所有状态存到一个对象中，如何读值、如何写值。会触发页面的响应式么？<br>⚪ 我在项目中声明一个全局对象，这样是不是就没必要使用 Redux/Vuex 了？</p>
<p>🟠 有个数组[0..100]，实现个 list，循环渲染列表。key 的作用是什么。<br>🟠 简单说一下虚拟 DOM 是什么？为什么要引用这个概念？<br>🟠 了解过自己所用的框架源码中的 diff 算法？</p>
<p>⚪ 路由跳转传参有几种方式，PC 端通过传参来控制页面是编辑/展示状态，如果我手动将 url 中参数修改了，怎么防止这种情况。如果页面用户主动 F5 刷新了，怎么处理。</p>
<p>🟠 小程序 webview 是如何 H5 与小程序通讯的。<br>H5 网页向小程序通讯，H5 页面通过引用<a href="https://res.wx.qq.com/open/js/jweixin-1.3.2.js，然后使用wx.miniProgram.postMessage向小程序发送消息。" target="_blank" rel="noopener">https://res.wx.qq.com/open/js/jweixin-1.3.2.js，然后使用wx.miniProgram.postMessage向小程序发送消息。</a><br>小程序向 H5 页面通讯，webview 组件的 src 字段后面 url 拼接参数。<br>🟢 小程序原生由于 setData 效率很慢，如何处理？渲染进程、数据处理进程。<br>⚪ Taro 有使用过么？有做过跨端项目么？跨端遇到过什么问题，最后怎么解决的？<br>⚪ 小程序的生命周期有哪些？小程序 onShow / onLoad 生命周期什么情况下会触发，一般什么业务场景会用到这两个生命周期。<br>⚪ 小程序太阳码码生成过么？小程序的登录流程熟悉过么？小程序授权流程熟悉过么？<br>⚪ 小程序图片长按识别二维码怎么开启，想要长按图片然后绑定事件如何实现？</p>
<h3 id="五、项目相关"><a href="#五、项目相关" class="headerlink" title="五、项目相关"></a>五、项目相关</h3><p>🔴 遇到过跨域问题么？为什么会有跨域问题，同源策略是为了防止什么情况的发生？<br>你在平时开发中面对跨域怎么解决的。<br>前端调整：项目的 config 配置代理 或者 浏览器追加参数 –disable-web-security<br>后端调整：jsonp 、CORS （Access-Control-Allow-Origin）<br>🟢 cdn 加速是怎么实现的？用户和服务器之间增加 Cache 层，智能 DNS 负载均衡系统解析域名，把对用户响应速度最快的 IP 节点返回给用户。<br>🟢 配置过 webpack 么？<br>🟢 开发阶段有优化打包效率的相关经验么？webpack / vite<br>⚪ 有跨端项目经验开发经验么？怎么实现的？遇到过什么坑？<br>⚪ 微信小程序插件有做过么？<br>⚪ 有大屏经验么？字号的适配怎么实现，用 px 可以么？<br>⚪ 有 Canvas 的经验么？是矢量图还是位图？生成 canvas 保存之后图片会很模糊怎么解决。<br>⚪ 有 ECharts 的经验么？<br>⚪ 简单说一下如何使用 ECharts，如何初始化 this.mapChart = echarts.init，<br>⚪ 通过什么 api 渲染图像。this.mapChart.setOption<br>⚪ 本地随机生成的背景颜色，然后要在此颜色上显示文字，文字的颜色，希望能通过代码的方法来判断，背景颜色深就用白色显示文字，背景颜色浅就用黑色，这个有思路可以代码实现么？<br>⚪ 有实现登录功能么？知道 Auth2.0 登录么？如果用 hash 路由，返回来的结果参数被拼到.html 与 # 之间了。你需要怎么处理？</p>
<p>⚪ React const {list} = this.state 然后直接对第一个对 list[0] = 111，this.setState(list)可以触发渲染么？<br>⚪ Vue 直接 this.list[0] = 1111, 可以触发渲染么？<br>⚪ 你在之前的项目中，表单校验一般如何实现的？<br>⚪ 如果这个 List 数据非常多，会白屏一段时间，你有什么好的优化方案？<br>⚪ UI 给出 List 空列表样式，不过页面请求接口获取数据，接口请求时，列表没有数据 就会闪过空列表样式，你怎么解决。</p>
<h3 id="六、开放问题"><a href="#六、开放问题" class="headerlink" title="六、开放问题"></a>六、开放问题</h3><p>🔴 有对项目性能优化方面的经验么？<br>只把用于渲染的变量放在 state。逻辑中间变量尽量不要放到 state 内。不然每次渲染都会 diff 处理 state 中的字段。过多无意义的比较，会浪费性能。<br>懒加载组件/图片，减少接口调用，图片资源压缩，cdn 加速，白屏优化，节流、防抖，骨架屏，虚拟列表等。<br>css 样式放在 head 里，js 脚本放在最后。</p>
<p>🟠 简单说一下浏览器从输入 url 到获得页面经历的所有事情：</p>
<ol>
<li>输入网址</li>
<li>缓存解析</li>
<li>域名解析</li>
<li>tcp 连接，三次握手</li>
<li>浏览器发送请求（请求头、请求体），服务器返回响应（响应头、响应体）</li>
<li>页面渲染</li>
<li>生成 DOM 树</li>
<li>解析 CSS 样式</li>
<li>加载 js 脚本，实现交互</li>
</ol>
<p>🟢 如果生产上出现了问题，你一般会如何去定位问题？SourceMap 用过么？<br>🟢 说一下自己工作中遇到最困难的问题是什么，你是怎么解决的？或者说一下在你工作中最有成就感的事情。<br>🟢 能简单说一下自己的优势么？你相比于其他开发同学你有哪些核心竞争力？<br>🟢 如果给小伙伴安排工作，不过他不服从安排，你应该如何处理？<br>🟢 如果 2 个领导给出的意见不一致，你会如何处理？<br>🟢 有为团队中作出什么贡献的事情么？</p>
<p>⚪ UI 库的样式跟设计稿不匹配，你会怎么处理？<br>⚪ 平时用过缺陷管理系统么？禅道，tapd？<br>⚪ 自己有从头搭建过项目的经历么？<br>⚪ 有做过 封装公共组件，封装插件，开放辅助工作的工具和脚本。封装了哪些？为解决什么问题？</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>哈哈，本来准备在放飞理想的咸鱼博主后面加一个（先苟一波），<br>后来想想还是有点太怂了，实在是下不去手。<br>富贵不能淫，<br>贫贱不能移，<br>威武不能屈，<br>理想还是应该放飞放飞。😎</p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>4.关于Taro框架中装饰器的使用方法</title>
    <url>/2020/06/21/4-%E5%85%B3%E4%BA%8ETaro%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="关于装饰器"><a href="#关于装饰器" class="headerlink" title="关于装饰器"></a>关于装饰器</h3><p>装饰器模式是在不影响原来的类/方法/属性的基础上，<br>增加的新功能的方式。<br>一般可以运用在权限校验、日志打印、性能测验、属性保护、节流防抖、耦合度低的重复性工作（加积分）等等……<br>或者说，你干脆不想动别人写的代码，免得背锅，<br>这个时候就可以通过装饰器模式进行改造。</p>
<a id="more"></a>

<h3 id="装饰器的几种模式"><a href="#装饰器的几种模式" class="headerlink" title="装饰器的几种模式"></a>装饰器的几种模式</h3><ol>
<li><p>对类进行的装饰<br>以类为单元，可以对类中的声明周期，以及所有类中的属性和方法进行装饰。<br>虽然都能够包括在内，不过以类为单元过于庞大，<br>需要做精准的筛选和操作。<br>而 Taro 可能是因为框架的原因，只能够修饰类，其他两种方式都不能被使用，所以只能硬着头皮去装饰类。</p>
</li>
<li><p>对方法进行的装饰<br>这个用起来比较精准，用起来比较顺眼，便于理解，<br>也是常用的装饰器模式。</p>
</li>
<li><p>对属性进行的装饰<br>同时，装饰器也能装饰一些变量，<br>比如给某个变量增加只读的属性，<br>这样如果无意间修改了变量，编译器也能做出对应的提示。</p>
</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>装饰模式装饰类的实现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Demo装饰器示例</span></span><br><span class="line"><span class="comment">// 功能在类中所有方法前后都打印Log，并且屏蔽指定的方法，替换成输出数字。</span></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="comment">// @Demo(['componentDidMount'], 123)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">arrFunc: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [], num: <span class="built_in">Number</span> = 9999</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Demo Params"</span>, &#123; target, key, descriptor, arrFunc, num &#125;);</span><br><span class="line">    <span class="keyword">if</span> (target.prototype) &#123;</span><br><span class="line">      <span class="comment">// 拷贝对象，获取类中的所有方法</span></span><br><span class="line">      <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(target.prototype);</span><br><span class="line">      <span class="comment">// 遍历该对象中所有方法</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key of <span class="built_in">Object</span>.keys(desc)) &#123;</span><br><span class="line">        <span class="keyword">const</span> func = desc[key].value;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> func === <span class="string">"function"</span>) &#123;</span><br><span class="line">          <span class="comment">// 修改对象的现有属性key，并且返回这个对象</span></span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(target.prototype, key, &#123;</span><br><span class="line">            value(...args: <span class="built_in">any</span>[]) &#123;</span><br><span class="line">              <span class="comment">// 指定方法则屏蔽原方法，打印个参数</span></span><br><span class="line">              <span class="keyword">if</span> (arrFunc &amp;&amp; arrFunc.indexOf(key) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> - <span class="subst">$&#123;num&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 其他方法 装饰前后log</span></span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> - before.`</span>);</span><br><span class="line">              <span class="keyword">const</span> res = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> - after.`</span>);</span><br><span class="line">              <span class="keyword">return</span> res;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Demo;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastTime = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> lastMethodTime = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理业务逻辑</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> dealFun = <span class="keyword">async</span> (that, args, gapTime) =&gt; &#123;</span><br><span class="line">  <span class="comment">// console.log('CheckLogin args', gapTime)</span></span><br><span class="line">  <span class="keyword">if</span> (lastMethodTime) &#123;</span><br><span class="line">    clearTimeout(lastMethodTime);</span><br><span class="line">    lastMethodTime = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理业务逻辑</span></span><br><span class="line">  <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">if</span> (!lastTime || nowTime - lastTime &gt;= gapTime) &#123;</span><br><span class="line">    that.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    lastTime = nowTime;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lastMethodTime = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastMethodTime) &#123;</span><br><span class="line">        lastMethodTime = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      that.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;, gapTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流装饰器：固定一段时间内只有一次有效操作，第一次立即执行，且保证最后一次也会执行</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; gapTime</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Throttle =</span><br><span class="line">  (gapTime = <span class="number">200</span>) =&gt;</span><br><span class="line">  (...args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> descriptor = args[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 兼容箭头函数</span></span><br><span class="line">    <span class="keyword">if</span> (descriptor.initializer) &#123;</span><br><span class="line">      <span class="keyword">const</span> replaceInitializer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 此处传入了指向类实例的this</span></span><br><span class="line">        <span class="keyword">const</span> fn = descriptor.initializer.call(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">async</span> (...retArgs) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> dealFun(fn, retArgs, gapTime);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        initializer: replaceInitializer,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldValue = descriptor.value;</span><br><span class="line">    descriptor.value = dealFun(oldValue, args, gapTime);</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Throttle;</span><br></pre></td></tr></table></figure>

<p>Taro 的装饰器使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Demo, Throttle &#125; from &#39;@&#x2F;kits&#x2F;decorator&#x2F;index&#39;;</span><br><span class="line"></span><br><span class="line">@Demo([&#39;componentDidMount&#39;], 123)</span><br><span class="line">export default class AvatarModule extends Component &#123;</span><br><span class="line"></span><br><span class="line">  @Throttle(200)</span><br><span class="line">  handleTestClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;handleTestClick&#39;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  render () &#123;</span><br><span class="line">    (</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>话说，刚刚说过的 Redux 的 connect 其实也是装饰器的实现。<br>另外，装饰器其实也是高阶函数的一种实现，<br>那么通过 Hook 的方法也能够实现类似装饰器带来的效用。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>设计模式</tag>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title>41.好用的网站整理</title>
    <url>/2023/02/11/41-%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="记录背景"><a href="#记录背景" class="headerlink" title="记录背景"></a>记录背景</h3><p>被所谓的“信息饕餮症”困扰了许久，<br>收藏夹里收藏了了 N 多网站在吃灰。<br>今天终于下定决心好好的捋一遍收藏过的网站，<br>把一些好的网站整理下来，<br>这样下次想用的时候能找的更方便一点。</p>
<a id="more"></a>

<h3 id="推荐自己"><a href="#推荐自己" class="headerlink" title="推荐自己"></a>推荐自己</h3><ul>
<li><a href="https://www.orz2.online/gengjian1203/">1. 个人博客页</a></li>
<li><a href="https://www.orz2.online/viewTool/#/?pageName=PageTool">2. 个人工具页</a></li>
<li><a href="https://www.orz2.online/fiveball/">3. 玖玖五子连珠</a></li>
<li><a href="https://www.orz2.online/mathcookies/">4. 数字饼干</a></li>
<li><a href="https://www.orz2.online/zero/">5. 工具箱</a></li>
<li><a href="https://www.orz2.online/weather/">6. 气象日历</a></li>
<li><a href="https://www.orz2.online/carbon/">7. 小工具</a></li>
</ul>
<h3 id="Mac-软件下载"><a href="#Mac-软件下载" class="headerlink" title="Mac 软件下载"></a>Mac 软件下载</h3><ul>
<li><a href="https://xclient.info/" target="_blank" rel="noopener">1. 精品 MAC 应用分享</a></li>
</ul>
<h3 id="好用工具"><a href="#好用工具" class="headerlink" title="好用工具"></a>好用工具</h3><ul>
<li><a href="https://tinypng.com/" target="_blank" rel="noopener">1. TinyPNG</a> 一个超好用的在线图片压缩工具</li>
<li><a href="https://www.jq22.com/textDifference" target="_blank" rel="noopener">2. 在线文本差异对比</a> 在线文本差异对比,文本比对、文本比较工具</li>
<li><a href="https://c.runoob.com/front-end/854/" target="_blank" rel="noopener">3. 正则表达式在线测试</a></li>
<li><a href="https://www.gaoding.com/koutu?" target="_blank" rel="noopener">4. 稿定设计抠图</a> 一款在线抠图工具</li>
<li><a href="https://www.codeandweb.com/free-sprite-sheet-packer" target="_blank" rel="noopener">5. Free Sprite Sheet Packer</a> 一款免费的在线 TexturePacker 用于雪碧图的生成，可以将多张图片拼成一张图片以及对应的 json</li>
<li><a href="https://fonthaha.com/edit" target="_blank" rel="noopener">6. 艺术字体在线生成器</a></li>
<li><a href="https://www.ldmap.net/index.html" target="_blank" rel="noopener">7. 兰图绘</a> 一款在线的图片标记平台</li>
<li><a href="https://tool.lu/js/" target="_blank" rel="noopener">8. javascript 工具</a> 一款 javascript 在线格式化、去注释、压缩解压、混淆工具</li>
<li><a href="http://www.esjson.com/jsformat.html" target="_blank" rel="noopener">9. ESJSON</a> 又一款代码在线处理工具，支持 js、css、html、xml、SQL 压缩混淆格式化等</li>
<li><a href="https://c.runoob.com/front-end/59/" target="_blank" rel="noopener">10. 菜鸟工具</a> 图片转 base64 等 N 多在线工具</li>
<li><a href="https://app.xunjiepdf.com/editor" target="_blank" rel="noopener">11. 迅捷 PDF 编辑器</a></li>
<li><a href="https://check.lzfh.com/wx/" target="_blank" rel="noopener">12. 微信卡片在线制作工具</a></li>
<li><a href="https://pixel-me.tokyo/en/" target="_blank" rel="noopener">13. Pixel Me</a> 通过图片在线生成像素画</li>
<li><a href="https://www.strerr.com/screen.html" target="_blank" rel="noopener">14. 常见移动设备尺寸</a> 获取本机当前的屏幕尺寸</li>
<li><a href="https://m.wannianli.tianqi.com/jisuanqi/daoshuri/?ivk_sa=1024609w" target="_blank" rel="noopener">15. 倒计时计算器</a></li>
<li><a href="http://sfz.fatcarter.cn/" target="_blank" rel="noopener">16. 随机身份证号生成器 1</a></li>
<li><a href="http://sfz.uzuzuz.com/" target="_blank" rel="noopener">17. 随机身份证号生成器 2</a></li>
<li><a href="https://ps.gaoding.com/#/" target="_blank" rel="noopener">18. 稿定在线 PS</a></li>
<li><a href="http://ico.bst108.com/" target="_blank" rel="noopener">19. 在线 ico 图标制作_ICO 图标生成器 - 在线工具</a></li>
</ul>
<h3 id="相关平台"><a href="#相关平台" class="headerlink" title="相关平台"></a>相关平台</h3><ul>
<li><a href="https://gitmoji.dev/" target="_blank" rel="noopener">1. gitmoji</a> 可用在 git 仓库介绍上的 emoji 图标库</li>
<li><a href="https://www.juhe.cn/" target="_blank" rel="noopener">2. 聚合数据 API</a> 提供接口查询信息，如节假日、气象、股票数据等</li>
<li><a href="https://datav.aliyun.com/portal/school/atlas/area_selector#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5" target="_blank" rel="noopener">3. DataV.GeoAtlas</a> 地图选择器，可以拿到国省市区的地图 json 信息，方便通过 echart 绘制地图信息</li>
<li><a href="https://dev.qweather.com/" target="_blank" rel="noopener">4. 和风天气开发服务</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000ecc775a86807f7ba9b7dc956c13" target="_blank" rel="noopener">5. 微信小程序 UI 组件库合集</a></li>
<li><a href="https://chat.openai.com/chat" target="_blank" rel="noopener">6. ChatGPT</a></li>
</ul>
<h3 id="素材参考"><a href="#素材参考" class="headerlink" title="素材参考"></a>素材参考</h3><ul>
<li><a href="https://www.ui.cn/singlist" target="_blank" rel="noopener">1. UICN 用户体验平台</a> 展示各种 APP 的设计稿，给自己提升灵感</li>
<li><a href="https://www.pexels.com/zh-cn/" target="_blank" rel="noopener">2. Pexels</a> 免费素材图片</li>
<li><a href="https://www.gaoding.com/scenes/newmedia?ids=4828770,4833303" target="_blank" rel="noopener">3. 稿定设计公众号模板</a></li>
<li><a href="https://www.mockplus.cn/example/rp" target="_blank" rel="noopener">4. 摹客 RP</a></li>
</ul>
<h3 id="视频资源"><a href="#视频资源" class="headerlink" title="视频资源"></a>视频资源</h3><ul>
<li><a href="https://cupfox.app/" target="_blank" rel="noopener">1. 茶杯狐</a></li>
<li><a href="https://www.smmy360.com/" target="_blank" rel="noopener">2. 三米影视</a></li>
</ul>
<h3 id="技术选型（微前端）"><a href="#技术选型（微前端）" class="headerlink" title="技术选型（微前端）"></a>技术选型（微前端）</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/634567028" target="_blank" rel="noopener">1.微前端技术方案调研（qiankun、micro-app、wujie）</a></li>
<li><a href="https://blog.csdn.net/JKK_jkk/article/details/128133638" target="_blank" rel="noopener">2. 这些前端新技术群你了解了吗？ pnpm turbo vitepress vercel</a></li>
<li><a href="https://wujie-micro.github.io/doc/guide/start.html" target="_blank" rel="noopener">3. 无界官网</a></li>
</ul>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>40.菜鸡前端从0到1搭建阿里云服务器记录</title>
    <url>/2022/12/31/40-%E8%8F%9C%E9%B8%A1%E5%89%8D%E7%AB%AF%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本来一直以来是使用微信的云函数以及部署静态网站的。（确实很傻瓜式，简单易操作）<br>结果微信现在是把人圈到手之后，开启收割模式了。</p>
<p>记得最最开始的时候微信云服务是免费很多额度的，<br>后来大概到了 20 年左右吧，再创建新的云环境的时候，免费额度下调到原来的十分之一（也是勉强可以接受），<br>那么现在厉害了，有最低消费了，<br>先 20 元 / 月试行 3 个月，<br>然后自 2023 年起 40 元 / 月。<br>算下来一年也得小 500 块呢，还不如搞个低配版云服务器了。<br>选择了阿里云，毕竟老牌大厂，相关教程应该很多，上手能快一些。</p>
<a id="more"></a>

<h3 id="搞个服务器能做什么"><a href="#搞个服务器能做什么" class="headerlink" title="搞个服务器能做什么"></a>搞个服务器能做什么</h3><p>我要搞清楚，<br>如果需要花重金来养一台服务器，那么这个服务器能为我做什么？</p>
<ol>
<li>帮我部署网站。<br>之前的网站都是部署在微信云静态网站上的，我有些网站 demo 想要部署到公网上。<br>这个就需要用到 nginx + jenkins。捎带学一学 nginx 和 jenkins 怎么配置的。（代码都存到了 github 上，使用 github 的静态页面实在太卡了，根本没法展示使用；gitee 也不想用，一套代码存两个仓库这么冗余太累了）</li>
<li>为我提供接口服务。<br>比如小程序登录，或者三方 api 跨域，没办法由前端调用接口的时候，需要有个后端服务替我转发请求。而且一些 demo 的数据信息也需要存储起来。<br><del>这个就需要用到 express + MySQL。（后来想了一下，还需要服务器维护一个这样的服务太麻烦了，干脆改用了阿里云的函数计算 FC，也就是 serverless，还能省去了运维成本。）</del><br>现在更新为 express + mongo, 迁移数据库的原因是, 首先 mongo 是非关系型的, 后期拓展字段的时候非常方便, 而且 mongo 支持的字段类型也比较多也很灵活, 相加字段直接在类型上加就好, 不用再去特意去跑 SQL 脚本, (MySQL 每次都要序列化 / 反序列化对数据操作感觉不是很舒适). 再就是看了一下阿里云的配套产品也都是搭配 mongo 的, 后期如果想要在迁移到单独的阿里云数据库也会更顺滑一些.<br>那么对于 mongo 的一些弱势我也觉得我可以接受, 比如: 当大体量数据的时候, 他会效率变低, 由于这个目前我的定位只是 demo 展示,不会有大量数据的情况.</li>
<li>服务器可以为我提供定时任务。<br>比如说定时爬取一些文章，积累数据，或者定时让机器人发送一些消息，以作日常提醒之用。</li>
<li>学习 Docker 常用指令以及运维的相关知识。</li>
<li>能够真正弄懂要上线一个产品的整个技术链路，比如申请域名，https 证书，安全，相关权限审核，部署网站，部署服务。以作自身的技术储备之用。</li>
</ol>
<h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><p>下定决心之后，开始付之于行动。<br>首先，登录阿里云服务器<a href="https://www.aliyun.com/" target="_blank" rel="noopener">https://www.aliyun.com/</a>真是惊了个呆，<br>花里胡哨产品一大堆脑瓜子嗡嗡的，<br>我记得之前曾经搞过<code>云服务ECS</code>，我估计就没有新人优惠了，没有点进去细看，<br>然后发现现在多出来了个<code>轻量应用服务器</code>，感觉自己应该也不会有太多用户，而且后端逻辑不会太重，搞个最简单的应该就好。于是我就选择了这个轻量应用服务器。<br><del>不过我应该是买贵了，选择的是 2 核 1G 内存的最低配，一年需要 612 元。</del><br><del>我同事跟我说他买相同配置也就 300 多点，瞬间感觉自己略微有点头大，</del><br><del>没办法，技术不够只能氪金凑了，</del><br><del>虎爷告诉过我，只要为了学习投资都是值得的，毕竟花这个钱，总要比在原神氪个 648 要强吧 =.=!</del>）~~<br>没错，确实是买贵了，阿里云前端时间出来个云服务器<code>99元/年</code>的活动，<br>果断今年换成这个服务器了，开始了各种迁移工作。</p>
<p>不过相对来说, 便宜没好货, 估计这台服务器也就是一个 VPS, 好在能满足个人级别的使用我就满足了.</p>
<h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>现在买完服务器之后，你在工作台就能看到自己的服务器卡片了。<br>第一件事就是重置密码，然后可以选择镜像进行安装。<br>一我开始是选择了宝塔镜像，不过感觉集成度太高，导致实际很多东西还是学习不到，都被宝塔封装实现了，只是点点鼠标，而且用起来有种很古老的感觉扑面而来；<br>后来决定改用了安装 Docker 镜像，毕竟还是要紧跟时代潮流的，捎带还能学习一波 Docker 的相关知识。</p>
<h3 id="管理服务器"><a href="#管理服务器" class="headerlink" title="管理服务器"></a>管理服务器</h3><p>安装完镜像之后，服务器就可以处于正常运行状态啦。<br>现在就可以通过页面卡片来对服务器进行一个简单的管理，也可以通过终端远程连接服务器。<br>Dokcer 镜像是基于 CentOS 操作系统的，如果之前是使用的 Mac 系统，经常使用命令行能够更平滑更友好的过度和接受。</p>
<h3 id="Docker-浅尝"><a href="#Docker-浅尝" class="headerlink" title="Docker 浅尝"></a>Docker 浅尝</h3><p>Docker 有两个概念：</p>
<ol>
<li><p>镜像<br>用代码来类比说，是类似于“抽象类”的概念。<br>他没有实体，只是一个镜像模板。</p>
</li>
<li><p>容器<br>用代码来类比说，是类似于“示例”的概念。<br> 他是对应镜像的实例化对象。<br>而我们操作也是都会在对应的容器里面操作。</p>
</li>
</ol>
<p>备注几个 docker 常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.1 查看镜像列表</span></span><br><span class="line">sudo docker images</span><br><span class="line"><span class="comment"># 1.2 镜像搜索</span></span><br><span class="line">sudo docker search jenkins</span><br><span class="line"><span class="comment"># 1.3 拉下镜像</span></span><br><span class="line">sudo docker pull 镜像名</span><br><span class="line">sudo docker pull 镜像名:Tag</span><br><span class="line"><span class="comment"># 1.4 删除镜像 id可以通过查看镜像列表获取</span></span><br><span class="line">sudo docker rmi -f 镜像名/镜像ID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1 查看容器列表</span></span><br><span class="line">sudo docker ps</span><br><span class="line">sudo docker ps -a <span class="comment"># 包含正在运行和已停止的</span></span><br><span class="line"><span class="comment"># 2.2 创建容器</span></span><br><span class="line"><span class="comment"># -it 表示 与容器进行交互式启动</span></span><br><span class="line"><span class="comment"># -d 表示可后台运行容器 （守护式运行）</span></span><br><span class="line"><span class="comment"># --name 给要运行的容器 起的名字</span></span><br><span class="line"><span class="comment"># /bin/bash  交互路径</span></span><br><span class="line"><span class="comment"># -p 将容器的端口映射到宿主机上，通过宿主机访问内部端口</span></span><br><span class="line"><span class="comment"># -v 将容器内的指定文件夹挂载到宿主机对应位置</span></span><br><span class="line">docker run -it -d --name 要取的别名 -p 宿主机端口:容器端口 -v 宿主机文件存储位置:容器内文件位置 镜像名:Tag /bin/bash</span><br><span class="line"><span class="comment"># 2.3 停止容器 id可以通过查看容器列表获取</span></span><br><span class="line">sudo docker stop 容器名/容器ID</span><br><span class="line"><span class="comment"># 2.4 删除容器 删除容器之前要先将容器停止</span></span><br><span class="line"><span class="comment"># 删除一个容器</span></span><br><span class="line">docker rm -f 容器名/容器ID</span><br><span class="line"><span class="comment"># 删除多个容器 空格隔开要删除的容器名或容器ID</span></span><br><span class="line">docker rm -f 容器名/容器ID 容器名/容器ID 容器名/容器ID</span><br><span class="line"><span class="comment"># 删除全部容器</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"><span class="comment"># 2.5 进入容器</span></span><br><span class="line">sudo docker attach 容器ID/容器名</span><br></pre></td></tr></table></figure>

<h3 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h3><ol>
<li>直接拉取最新的 nginx 镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建一些目录，把 nginx 容器内的相关文件夹挂载到宿主机上，主要方便改写配置，其次是删除容器，这些文件不会丢失</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/<span class="built_in">local</span>/nginx/&#123;conf,html,logs,ssl&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动一个 nginx 容器，将默认的配置文件 cp 出来，拷贝到刚刚新建的目录下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name nginx -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将默认的配置文件 cp 出来，拷贝到刚刚新建的目录下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp 刚刚创建的nginx容器id:/etc/nginx/nginx.conf /usr/<span class="built_in">local</span>/nginx/conf/</span><br><span class="line">docker cp 刚刚创建的nginx容器id:/etc/nginx/conf.d /usr/<span class="built_in">local</span>/nginx/</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>停止当前 nginx 容器，并删除</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop a25b9f301349</span><br><span class="line">docker rm a25b9f301349</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将 https 证书（aaa.bbb.key、aaa.bbb.pem）放到 ssl 目录下 (https 证书可在阿里云域名菜单处免费生成)</li>
</ol>
<p>下载到证书之后，本地将证书复制过去。<br>下面命令在本地执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp `你的域名`.key、`你的域名`.pem `服务器账户`@`服务器IP`:/usr/<span class="built_in">local</span>/nginx/ssl</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>修改配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim conf/nginx.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    listen  [::]:80;</span><br><span class="line">    server_name  www.aaa.bbb; # 你的域名</span><br><span class="line"></span><br><span class="line">    rewrite ^(.*) https:&#x2F;&#x2F;$server_name$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  www.aaa.bbb; # 你的域名</span><br><span class="line"></span><br><span class="line">    ssl_certificate      &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;aaa.bbb.pem; # 你的证书</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;aaa.bbb.key; # 你的证书</span><br><span class="line"></span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP         $remote_addr;</span><br><span class="line">        proxy_set_header   Host              $http_host;</span><br><span class="line">        proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 专门为jenkins提供的配置</span><br><span class="line">    location &#x2F;jenkins&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;111.111.111.111:8080; # 你的IP</span><br><span class="line">        proxy_read_timeout 90s;</span><br><span class="line"></span><br><span class="line">        proxy_set_header   X-Real-IP         $remote_addr;</span><br><span class="line">        proxy_set_header   Host              $http_host;</span><br><span class="line">        proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要在特定的 location 禁用缓冲，将 location 中的 proxy_buffering 指令设置为 off,<br>如下：To disable buffering in a specific location, place the proxy_buffering directive in the location with the off parameter, as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;some&#x2F;path&#x2F; &#123;</span><br><span class="line">    proxy_buffering off;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;localhost:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>启动新的 nginx 容器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name nginx \</span><br><span class="line">-p 443:443 -p 80:80 \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/nginx/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/nginx/ssl:/etc/nginx/ssl/  \</span><br><span class="line">--privileged=<span class="literal">true</span> -d --restart=always nginx</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>网站部署</li>
</ol>
<p>那么此时你可以本地将你的网站如目录为<code>home</code>，打包压缩为<code>home.tar.gz</code>，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zcvf home.tar.gz home</span><br></pre></td></tr></table></figure>

<p>然后将其上传到 /usr/local/nginx/html 即可。<br>命令在本地执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp home.tar.gz `服务器账户`@`服务器IP`:/usr/<span class="built_in">local</span>/nginx/html</span><br></pre></td></tr></table></figure>

<p>那么再登录服务器，cd 进入到/usr/local/nginx/html 路径，将上传上来的文件解压即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf home.tar.gz</span><br></pre></td></tr></table></figure>

<p>那么此时，就可以通过域名或者 IP 访问到你刚刚上传的网站啦~<br>（如果不可以，那就可以考虑重启一下 nginx 实例再试一试）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.aaa.bbb<span class="regexp">/home/i</span>ndex.html</span><br><span class="line">http:<span class="regexp">//</span><span class="number">111.111</span>.<span class="number">111.111</span>:<span class="number">8080</span><span class="regexp">/home/i</span>ndex.html</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>后面完善</li>
</ol>
<p>目前只是人肉来上传网站实在是太累了。<br>可以考虑用 Jenkins 来接入持续集成，到时候就可以提交完代码后，直接在 Jenkins 发布个任务，即可将网站部署上去。（优先级不那么高，后续有空的时候研究一波）</p>
<h3 id="安装-Jenkins"><a href="#安装-Jenkins" class="headerlink" title="安装 Jenkins"></a>安装 Jenkins</h3><p>其实有了 nginx 的部署经验之后，安装后面的容器和配置也都大同小异，我就简单说明了。</p>
<p>Jenkins 的话，是需要提前安装好 maven 和 java 环境的。<br>安装好之后，要记录好安装路径，后面启动容器的时候需要关联上。</p>
<p>如果没有安装，可以先看一下后面的参考资料<code>3</code>、<code>4</code>、<code>5</code>。</p>
<ol>
<li>拉取 jenkins 镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull jenkins/jenkins:2.344</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动 jenkins 容器</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">8080</span>:<span class="number">8080</span> -p <span class="number">50000</span>:<span class="number">50000</span> -v <span class="regexp">/usr/</span>local<span class="regexp">/jenkins/</span><span class="string">jenkins_home:</span><span class="regexp">/var/</span>jenkins_home -v <span class="regexp">/usr/</span>local<span class="regexp">/maven/</span>apache-maven<span class="number">-3.8</span><span class="number">.5</span>:<span class="regexp">/usr/</span>local<span class="regexp">/maven -v /</span>etc<span class="regexp">/localtime:/</span>etc<span class="regexp">/localtime -v /</span>mnt<span class="regexp">/jenkins/</span><span class="string">sysconfig:</span><span class="regexp">/etc/</span>sysconfig -e JENKINS_OPTS=<span class="string">"--prefix=/jenkins"</span> -e JENKINS_ARGS=<span class="string">"--prefix=/jenkins"</span> --name jenkins --restart=always jenkins/jenkins</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化 jenkins</li>
</ol>
<p>由于已经配置好 nginx，<br>那么就可以登录进入 jenkins 进行初始化，以及相关插件的安装，<br>以及配置路径，方便后续可以通过域名方式登录 Jenkins</p>
<h3 id="安装-MongoDB"><a href="#安装-MongoDB" class="headerlink" title="安装 MongoDB"></a>安装 MongoDB</h3><ol>
<li>获取 MongoDB 镜像。来获取 MongoDB 的最新版本镜像。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mongo:4.2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动 MongoDB 容器。</li>
</ol>
<p>首先简单启动一下.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mongo -p 222222:27017 -v /usr/<span class="built_in">local</span>/mongo/data:/data/db -d --restart=always --privileged=<span class="literal">true</span> mongo:4.2</span><br></pre></td></tr></table></figure>

<p>登录进容器<code>docker exec -it my-mongo bash</code>, 创建一个 admin 角色</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: <span class="string">"myUserAdmin"</span>,</span><br><span class="line">    pwd: <span class="string">"abc123"</span>,</span><br><span class="line">    roles: [ &#123; <span class="attr">role</span>: <span class="string">"userAdminAnyDatabase"</span>, <span class="attr">db</span>: <span class="string">"admin"</span> &#125;, <span class="string">"readWriteAnyDatabase"</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>然后再把宿主的<code>mongod.conf.orig</code>文件拷贝出来, 用来在宿主环境报错对应的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID或者NAME:/etc/mongod.conf.orig /usr/<span class="built_in">local</span>/mongo/mongod.conf.orig</span><br></pre></td></tr></table></figure>

<p>然后删除刚刚创建的容器<code>docker rm -f 容器ID</code>, 调整好映射端口和文件, 重新再新建个容器.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mongo -p 222222:27017 -v /usr/<span class="built_in">local</span>/mongo/data:/data/db -v /usr/<span class="built_in">local</span>/mongo/mongod.conf.orig:/etc/mongod.conf.orig -d --restart=always --privileged=<span class="literal">true</span> mongo:4.2 --auth</span><br></pre></td></tr></table></figure>

<p>然后再把时区文件放到容器里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp /usr/share/zoneinfo/Asia/Shanghai 容器ID或者NAME:/etc/localtime</span><br></pre></td></tr></table></figure>

<p>docker cp /usr/share/zoneinfo/Asia/Shanghai c91a9edf7a81:/etc/localtime</p>
<p>具体参数含义如下:</p>
<ul>
<li><code>--name</code> 指定容器的名称</li>
<li><code>-p</code> 映射容器的端口到宿主机的端口</li>
<li><code>-v</code> 将宿主机的目录挂载到容器中作为数据目录</li>
<li><code>-e</code> 设置系统参数</li>
<li><code>-d</code> 表示以守护进程方式运行容器</li>
<li><code>--restart</code> 设置容器重启策略</li>
<li><code>--privileged</code> 允许容器拥有额外的权限</li>
<li><code>--auth</code> 开启安全认证(只有 admin 用户后才生效)</li>
</ul>
<ol start="3">
<li>进入 MongoDB 容器。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mongo /bin/bash</span><br></pre></td></tr></table></figure>

<p>或者直接进入 MongoDB 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mongo mongo</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建 MongoDB 用户。<br>在容器中，使用命令<code>mongo admin</code>进入<code>admin</code>数据库，然后为<code>testdb</code>的数据库,创建一个名为<code>root</code>，密码为<code>123456</code>的用户，并设置读写权限权限。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先去admin创建一个超级管理员</span></span><br><span class="line">use admin</span><br><span class="line">db.createUser(&#123;<span class="attr">user</span>: <span class="string">"root"</span>, <span class="attr">pwd</span>: <span class="string">"123456"</span>, <span class="attr">roles</span>: [&#123; <span class="attr">role</span>: <span class="string">"root"</span>, <span class="attr">db</span>: <span class="string">"admin"</span> &#125;]&#125;);</span><br><span class="line"><span class="comment">// 然后去testdb数据库, 创建一个zhangsan的拥有读写权限的用户</span></span><br><span class="line">use testdb</span><br><span class="line">db.createUser(&#123;<span class="attr">user</span>: <span class="string">"zhangsan"</span>, <span class="attr">pwd</span>: <span class="string">"123456"</span>, <span class="attr">roles</span>: [&#123; <span class="attr">role</span>: <span class="string">"readWrite"</span>, <span class="attr">db</span>: <span class="string">"testdb"</span> &#125;]&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改用户密码\权限</span></span><br><span class="line">db.updateUser(<span class="string">"root"</span>, &#123;</span><br><span class="line">  pwd: <span class="string">"666666"</span>,</span><br><span class="line">  roles: [&#123; <span class="attr">role</span>: <span class="string">"root"</span>, <span class="attr">db</span>: <span class="string">"admin"</span> &#125;],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>测试 MongoDB 服务。<br>在 MongoDB 里,输入下面命令, 如果提示没有权限, 则说明<code>安全认证</code>配置好了.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">show user</span><br></pre></td></tr></table></figure>

<p>如果发现没有权限之后,<br>使用命令<code>db.auth(&#39;root&#39;,&#39;666666&#39;)</code>进行用户认证, 就可以正常的操作了.</p>
</li>
<li><p>连接本地客户端。<br>使用客户端工具如 Studio 3T 或 Robo 3T 连接到 MongoDB 数据库，并验证连接是否正常。</p>
</li>
<li><p>后续运维。<br>如果需要对 MongoDB 进行更多的管理和维护操作，可以使用命令<code>docker stop mongo</code>来停止容器，<code>docker rm mongo</code>来删除容器，或者<code>docker start mongo</code>来重新启动容器。</p>
</li>
<li><p>mongo 内命令</p>
<ul>
<li><p>查看所有数据库<br><code>show databases</code></p>
</li>
<li><p>查看当前数据库<br><code>db.getName();</code></p>
</li>
<li><p>查看当前数据库的所有集合<br><code>show collections</code></p>
</li>
<li><p>查看当前所有用户<br><code>show users;</code></p>
</li>
<li><p>切换/创建数据库<br><code>use Member</code></p>
</li>
<li><p>创建集合<br><code>db.createCollection(&quot;test1&quot;)</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><ol>
<li>拉取 MySQL 镜像（除了使用 docker 官方镜像，也可以尝试用一下<a href="https://c.163.com/hub#/m/home/" target="_blank" rel="noopener">网易云 Docker 仓库</a>的镜像）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull hub.c.163.com/library/mysql:latest</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动 MySQL 容器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 11111:3306 \</span><br><span class="line">-v /usr/share/zoneinfo/:/usr/share/ \</span><br><span class="line">-v /usr/share/zoneinfo/:/usr/share/zoneinfo/ \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=你的数据库密码 \</span><br><span class="line">-e TZ=Asia/Shanghai \</span><br><span class="line">-d --privileged=<span class="literal">true</span> --restart=always hub.c.163.com/library/mysql:latest</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>本地可视化连接 MySQL</li>
</ol>
<p>可以使用 Navicat 本地连接服务器的数据库，进行增删改查。</p>
<ol start="4">
<li>更新数据库本地时间</li>
</ol>
<h3 id="安装-Ollama"><a href="#安装-Ollama" class="headerlink" title="安装 Ollama"></a>安装 Ollama</h3><ol>
<li>拉取 Ollama 镜像</li>
</ol>
<p>各种被墙, 人都麻了.<br>到处找镜像站, 最后终于找到了一个能用的, 赶紧拉下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull dockerpull.org/ollama/ollama</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动 Ollama 容器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama dockerpull.org/ollama/ollama</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>下载 llama3.2 模型并应用</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it ollama ollama run llama3.2</span><br></pre></td></tr></table></figure>

<h3 id="风险相关"><a href="#风险相关" class="headerlink" title="风险相关"></a>风险相关</h3><p>在实例化 docker 服务的时候, 建议<code>修改一下默认的端口</code>, 数据库相关服务的 <code>IP</code> 也限制一下, <code>密码</code>也设置的稍显复杂一些, 以防会有坏人对安全进行破坏.<br>由于昨晚刚刚搭建好 MongoDB, 并且随便刷了 1000 条测试数据,今天一大早就发现昨晚数据都没了,而且数据库被篡改了…收到了勒索信息 = =!~<br>幸亏还没开始有真实的数据, 也给自己敲响了一个警钟. (没错, 我连踩 3 坑, 我用的就是 mongo 默认端口, 然后访问 IP 还全部放开了, 然后 MongoDB 安装好后, 还是默认不启用安全认证的. 研究了一天终于搞定了)</p>
<h3 id="代办事项"><a href="#代办事项" class="headerlink" title="代办事项"></a>代办事项</h3><p>继续 docker 深造一波, 可以使用 docker 来部署前端网站和后端服务.</p>
<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3><p>后续随着自身的学习，会不定期的复盘，在积累和总结之后会继续完善这篇文章。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.jb51.net/article/242762.htm" target="_blank" rel="noopener">1. docker 安装 nginx 并配置 ssl 的方法步骤</a></li>
<li><a href="https://blog.csdn.net/win7i/article/details/127805064" target="_blank" rel="noopener">2. nginx 反向代理 jenkins 服务,实现 https 域名访问</a></li>
<li><a href="https://blog.csdn.net/lzc2644481789/article/details/124888223" target="_blank" rel="noopener">3. docker 安装 jenkins 并且通过 jenkins 部署项目(超详细 and 靠谱)</a></li>
<li><a href="https://blog.csdn.net/lzc2644481789/article/details/124888804" target="_blank" rel="noopener">4. centos7.6 安装 maven</a></li>
<li><a href="https://juejin.cn/post/6862497968973742094" target="_blank" rel="noopener">5. 超详细 Docker 安装 jenkins（避坑！！！）</a></li>
<li><a href="https://www.freesion.com/article/62721131766/" target="_blank" rel="noopener">6. 服务器 DOCKER 部署 jenkins 无法连接</a></li>
<li><a href="https://blog.51cto.com/u_15790101/5673548" target="_blank" rel="noopener">7. 安装 jenkins 时 web 界面出现该 jenkins 实例似乎已离线</a></li>
<li><a href="https://c.163.com/hub#/m/home/" target="_blank" rel="noopener">8. 网易云 Docker 仓库</a></li>
</ul>
]]></content>
      <tags>
        <tag>运维</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>42.关于H5混合开发的部分方案梳理</title>
    <url>/2023/04/05/42-%E5%85%B3%E4%BA%8EH5%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%9A%84%E9%83%A8%E5%88%86%E6%96%B9%E6%A1%88%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h3 id="书写背景"><a href="#书写背景" class="headerlink" title="书写背景"></a>书写背景</h3><p>最近在公司的开发过程中，<br>混合 H5 用的实在是太多了。<br>虽然这样操作，会让后续开发工作会变得很零碎，<br>不过这种开发模式也确实帮忙解决了很多问题。</p>
<a id="more"></a>

<h3 id="H5-混合开发优缺点"><a href="#H5-混合开发优缺点" class="headerlink" title="H5 混合开发优缺点"></a>H5 混合开发优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>发版方便快捷。</li>
<li>可以非常快速的复制出来一套新渠道项目。</li>
<li>真·一套代码部署多端业务。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>H5 可实现的操作比较局限。</li>
<li>宿主环境不可控，市面太多浏览器，要考虑兼容。</li>
<li>H5 给用户的直观体验不好，有浓浓的粗制劣造感。</li>
</ol>
<h3 id="混合开发场景场景"><a href="#混合开发场景场景" class="headerlink" title="混合开发场景场景"></a>混合开发场景场景</h3><h4 id="H5-与-APP-混合开发"><a href="#H5-与-APP-混合开发" class="headerlink" title="H5 与 APP 混合开发"></a>H5 与 APP 混合开发</h4><p>需要在最开始的加载 H5 页面时候，判断环境，来引用对应 APP 的 bridge.js。</p>
<ol>
<li>通讯</li>
</ol>
<p><code>H5</code> =&gt; <code>APP</code><br>调用 bridge.js 其中封装的通讯方法来向 APP 发送消息。<br><code>APP</code> =&gt; <code>H5</code> 通讯<br>通过修改 webview 的 url 的参数对 H5 发送消息</p>
<ol start="2">
<li>登录</li>
</ol>
<p>调用 bridge.js 其中封装的登录方法来实现拿到用户的登录信息。</p>
<ol start="3">
<li>定位</li>
</ol>
<p>调用 bridge.js 其中封装的定位方法来获取定位信息。</p>
<ol start="4">
<li>支付</li>
</ol>
<p>调用 bridge.js 其中封装的支付方法来跳转到 APP 统一收银台进行支付。</p>
<h4 id="H5-与小程序-以微信小程序为例-混合开发"><a href="#H5-与小程序-以微信小程序为例-混合开发" class="headerlink" title="H5 与小程序(以微信小程序为例)混合开发"></a>H5 与小程序(以微信小程序为例)混合开发</h4><p>H5 套壳在微信小程序 webview 之中，会被自动注入 wx 对象。</p>
<ol>
<li>通讯</li>
</ol>
<p><code>H5</code> =&gt; <code>微信小程序</code><br>调用其中的 wx.miniProgram.postMessage 可以向微信小程序主动发送消息。<br>不过小程序接收到消息的时机被限制。（只有在小程序后退、组件销毁、分享时才会触发）<br><code>微信小程序</code> =&gt; <code>H5</code><br>通过修改 webview 的 url 的参数对 H5 发送消息</p>
<ol start="2">
<li>登录</li>
</ol>
<p>在进入小程序或者进入 webview 页面的时候，获取用户信息，通过 url 将用户信息 url 传参形式传给 H5</p>
<ol start="3">
<li>定位</li>
</ol>
<p>可以通过小程序定位后的信息通过 url 传入，<br>也可以 H5 调用浏览器或者三方 js 的定位能力获取当前位置信息。</p>
<ol start="4">
<li>支付</li>
</ol>
<p>可以调用 jssdk 来支付，<br>也可以跳转到微信小程序的中间页实现支付</p>
<h4 id="公众号-H5-混合开发"><a href="#公众号-H5-混合开发" class="headerlink" title="公众号 H5 混合开发"></a>公众号 H5 混合开发</h4><p>需要在最开始的加载 H5 页面时候，判断环境，来引用 wx 的 JS-SDK。<br><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html" target="_blank" rel="noopener">JS-SDK 说明文档</a></p>
<ol>
<li>通讯</li>
</ol>
<p>通过微信暴露出来的一些开放标签来实现：<br>跳转 APP：<wx-open-launch-weapp /><br>跳转微信小程序：<wx-open-launch-app /><br>服务号订阅通知：<wx-open-subscribe /><br>音频播放：<wx-open-audio /></p>
<p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html" target="_blank" rel="noopener">开放标签说明文档</a><br><a href="https://blog.csdn.net/weixin_45532305/article/details/109491862" target="_blank" rel="noopener">使用微信开放标签<wx-open-launch-weapp>的踩坑日记(动态渲染开放标签)</a></p>
<ol start="2">
<li>登录</li>
</ol>
<p>通过 <code>OAuth2.0</code> 机制，单点登录来实现。<br>以 <code>snsapi_base</code> 为 scope 发起的网页授权。可以简单获取用户 openid\unionid 信息，用户是无感知的。<br>以 <code>snsapi_userinfo</code> 为 scope 发起的网页授权，可以获取用户 昵称头像基本信息的，需要用户主动手动操作授权。</p>
<p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html" target="_blank" rel="noopener">网页授权</a></p>
<ol start="3">
<li>定位</li>
</ol>
<p>调用 wx 的 JS-SDK 其中封装的<code>wx.getLocation</code>方法来实现拿到用户的位置信息。</p>
<p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#38" target="_blank" rel="noopener">获取地理位置接口</a></p>
<ol start="4">
<li>支付</li>
</ol>
<p>可以实现<code>JSAPI支付</code>、<code>H5支付</code>等多种支付模式</p>
<p><a href="https://pay.weixin.qq.com/wiki/doc/apiv3/index.shtml" target="_blank" rel="noopener">微信支付</a></p>
<h4 id="微信侧边栏-H5-混合开发"><a href="#微信侧边栏-H5-混合开发" class="headerlink" title="微信侧边栏 H5 混合开发"></a>微信侧边栏 H5 混合开发</h4><p>该部分内容详见<code>33.微信小程序插件开发记录</code></p>
<h3 id="混合场景各维度环境判断"><a href="#混合场景各维度环境判断" class="headerlink" title="混合场景各维度环境判断"></a>混合场景各维度环境判断</h3><p>硬件设备：IOS、安卓、Windows、Mac、DevTool 等。<br>宿主环境：各种浏览器（微信内置、qq、支付宝、UC 等）、各种小程序（微信、百度、支付宝等）、APP<br>渠道：根据项目的业务决定</p>
<p>可以根据 H5url 拼接的参数 + UserAgent 来进行判断</p>
]]></content>
      <tags>
        <tag>npm</tag>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>43.研究搭建一个前端轮子组织orz2</title>
    <url>/2023/04/22/43-%E7%A0%94%E7%A9%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E8%BD%AE%E5%AD%90%E7%BB%84%E7%BB%87orz2/</url>
    <content><![CDATA[<h3 id="书写背景"><a href="#书写背景" class="headerlink" title="书写背景"></a>书写背景</h3><p>从事前端开发许多年，总是绕不开想要造个轮子练练手。<br>我个人是不喜欢别人造轮子的，<br>因为没品味的人造的轮子除了增加其他开发人员的心智负担，对工作效率只能是负提升。<br>我个人又是希望自己能够造个轮子出来，<br>因为我觉得我还挺有品味的。[狗头]</p>
<a id="more"></a>

<h3 id="产品想法"><a href="#产品想法" class="headerlink" title="产品想法"></a>产品想法</h3><p>我希望能够作出来的一个<code>多框架多端组件库</code>的产品。</p>
<p><code>多框架</code>指的是：Vue2 + Vue3 + React<br><code>多端</code>指的是：移动端 h5 + 电脑端 pc</p>
<p>同时具备即时可预览可交互的在线文档。</p>
<p><code>可预览</code>指的是：在线文档页面即可看到组件的样子，所见即所得。<br><code>可交互</code>指的是：会将组件的传入参数可以在文档页面输入，组件就会展示对应的预期样子。</p>
<p>达到的目的就是：<br>通过项目的一个命令，就可以分别打包 vue2、3、React 组件、微信小程序原生等等各端组件库，同时也会打包一些通用公共方法，这些方法可以被各端组件去调用。<br>最理想状态下的实现就是，UI 与逻辑完全解耦，组件部分只去实现 UI 渲染，而业务逻辑完全在公共方法内去实现。</p>
<p>em…我承认这样有点难搞，先把目标定高一点，后续的人生里慢慢实现吧。</p>
<h3 id="结构介绍"><a href="#结构介绍" class="headerlink" title="结构介绍"></a>结构介绍</h3><h4 id="组织内搭建如下几个库（对应代码目录packages）："><a href="#组织内搭建如下几个库（对应代码目录packages）：" class="headerlink" title="组织内搭建如下几个库（对应代码目录packages）："></a>组织内搭建如下几个库（对应代码目录<code>packages</code>）：</h4><ol>
<li>@orz2/config</li>
</ol>
<p>封装一个为开发人员存放常用配置的统一数据源。<br>比如：postcss 所需的一些参数，这样在后续的组件库中配置信息的时候，都要求使用本库内的变量以保证各个组件库的一致性。</p>
<ol start="2">
<li>@orz2/kits</li>
</ol>
<p>封装一个应用在 node.js 的公共方法库。<br>比如：获取 git 最新 commit 等信息、企微/飞书机器人发送消息等。</p>
<ol start="3">
<li>@orz2/utils</li>
</ol>
<p>封装一个应用在 JavaScript 的公共方法库。<br>不仅可以为后续的组件库提供支持，也可以在项目的一些脚本上提供支持。<br>比如：解析 url 的参数转为对象等。</p>
<ol start="3">
<li>@orz2/vue2-h5</li>
</ol>
<p>封装一个基于 vue2 框架用于 h5 移动端的 ui 组件库。</p>
<ol start="4">
<li>@orz2/vue3-h5</li>
</ol>
<p>封装一个基于 vue3 框架用于 h5 移动端的 ui 组件库。</p>
<ol start="5">
<li>@orz2/${frame}-${platform}</li>
</ol>
<p>封装一个基于<code>frame</code>框架用于<code>platform</code>端的 ui 组件库。</p>
<p>待完善的后续组件库…</p>
<h4 id="上述的组件库想要展示同时需要有承载页面（对应代码目录subs）"><a href="#上述的组件库想要展示同时需要有承载页面（对应代码目录subs）" class="headerlink" title="上述的组件库想要展示同时需要有承载页面（对应代码目录subs）"></a>上述的组件库想要展示同时需要有承载页面（对应代码目录<code>subs</code>）</h4><ol>
<li>vue2-h5</li>
</ol>
<p>封装一个基于 vue2 语法用于 h5 移动端的组件承载页面。<br>同时基于对应组件的 README.md 文件来动态展示对应组件的介绍、预览、交互功能。</p>
<ol start="2">
<li>vue3-h5</li>
</ol>
<p>封装一个基于 vue3 语法用于 h5 移动端的组件承载页面。<br>同时基于对应组件的 README.md 文件来动态展示对应组件的介绍、预览、交互功能。</p>
<ol start="3">
<li>${frame}-${platform}</li>
</ol>
<p>封装一个基于<code>frame</code>语法用于<code>platform</code>端的组件承载页面。<br>同时基于对应组件的 README.md 文件来动态展示对应组件的介绍、预览、交互功能。</p>
<h4 id="需要把承载页面集成到一个微前端基座项目中（对应代码目录orz2-ui）"><a href="#需要把承载页面集成到一个微前端基座项目中（对应代码目录orz2-ui）" class="headerlink" title="需要把承载页面集成到一个微前端基座项目中（对应代码目录orz2-ui）"></a>需要把承载页面集成到一个微前端基座项目中（对应代码目录<code>orz2-ui</code>）</h4><p>通过应用 wujie 微前端框架，来对上述的几个子应用承载页面进行整合。<br>基座项目是基于 vue2 语法构建的。</p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>通过 turbo 来对各个应用进行批量启动、批量打包。<br>同时也借助 pnpm Monorepo 技术方案，方便管理一个仓库的多个项目。</p>
<h3 id="如何打包一个组件库"><a href="#如何打包一个组件库" class="headerlink" title="如何打包一个组件库"></a>如何打包一个组件库</h3><p>我准备借助 vite、rollup 这些打包工具来对组件库进行打包。<br>与 webpack 相比，rollup 更适合打包组件库，而 vite 也是基于 rollup 的基础上实现的。</p>
<p>通过 rollup 打包出来的代码体积很小，<br>而且 ESM 模块天然会携带 tree shaking 功能，只会打包所需的模块，<br>这样也可以减轻业务端的代码体积压力。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.npmjs.com/" target="_blank" rel="noopener">1. npm 官网</a></li>
<li><a href="https://www.npmjs.com/org/orz2" target="_blank" rel="noopener">2. orz2 组织</a></li>
<li><a href="https://www.orz2.online/orz2-ui/">3. orz2-ui 组件官网</a></li>
<li><a href="https://wujie-micro.github.io/doc/" target="_blank" rel="noopener">4. 无界官方文档</a></li>
<li><a href="https://turbo.build/" target="_blank" rel="noopener">5. turbo 官方文档 1</a></li>
<li><a href="https://turbo.build/repo/docs" target="_blank" rel="noopener">6. turbo 官方文档 2</a></li>
<li><a href="https://turbo.build/repo/docs/reference/codemods#create-turbo-config" target="_blank" rel="noopener">8. turbo.json 文档</a></li>
<li><a href="https://github.com/vercel/turbo" target="_blank" rel="noopener">7. turbo github</a></li>
<li><a href="https://v2.cn.vuejs.org/" target="_blank" rel="noopener">8. Vue2 官方文档</a></li>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">9. Vue3 官方文档</a></li>
<li><a href="https://blog.csdn.net/qq_30436011/article/details/127926847" target="_blank" rel="noopener">10. rollup 从入门到打包一个按需加载的组件库</a></li>
<li><a href="https://www.zhihu.com/question/266745124/answer/2749383835" target="_blank" rel="noopener">11. 设计一个前端组件库（规模并不是很大），需要具备哪些能力？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/171686818" target="_blank" rel="noopener">12. 从 0 到 1，搭建一个体系完善的前端 React 组件库</a></li>
<li><a href="https://blog.csdn.net/Moonoly/article/details/124554952" target="_blank" rel="noopener">13. 用 rollup 打包 vue 组件库</a></li>
<li><a href="https://www.rollupjs.com/" target="_blank" rel="noopener">14. rollup 官方文档</a></li>
<li><a href="https://blog.csdn.net/tsoTeo/article/details/115679008" target="_blank" rel="noopener">15. 前端模块化标准对比 iife amd cmd cjs umd es6</a></li>
<li><a href="https://juejin.cn/post/7212929901602308133" target="_blank" rel="noopener">16. rollup 3.x + vue2 打包组件</a></li>
<li><a href="https://www.jianshu.com/p/cea946fa3c58" target="_blank" rel="noopener">17. webpack、rollup、gulp 对比</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/373935751" target="_blank" rel="noopener">18. 使用 pnpm 构建 Monorepo 项目</a></li>
<li><a href="https://jishuin.proginn.com/p/763bfbd3bcff" target="_blank" rel="noopener">19. 为什么现在我更推荐 pnpm 而不是 npm/yarn</a></li>
</ul>
]]></content>
      <tags>
        <tag>npm</tag>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>35.各平台对识别二维码的测试记录</title>
    <url>/2022/05/24/35-%E5%90%84%E5%B9%B3%E5%8F%B0%E5%AF%B9%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="记录背景"><a href="#记录背景" class="headerlink" title="记录背景"></a>记录背景</h3><p>image 标签中包含不同的码，在各个平台中是具有不同的交互体验。<br>可能会随着微信版本更新，展示效果会有不同。<br>将目前的情况记录下来为后续开发时避坑。</p>
<a id="more"></a>

<h3 id="具体表现"><a href="#具体表现" class="headerlink" title="具体表现"></a>具体表现</h3><table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">企业微信(长按图片)</th>
<th align="center">企业微信(preview)</th>
<th align="center">微信(长按图片)</th>
<th align="center">微信(preview)</th>
<th align="center">微信 H5(长按图片)</th>
<th align="center">微信 H5(preview)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通微信二维码</td>
<td align="center">无反应 ❌</td>
<td align="center">预览黑屏 ❌</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
</tr>
<tr>
<td align="center">公众号二维码</td>
<td align="center">无反应 ❌</td>
<td align="center">预览黑屏 ❌</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
</tr>
<tr>
<td align="center">网址二维码</td>
<td align="center">无反应 ❌</td>
<td align="center">预览黑屏 ❌</td>
<td align="center">无法识别 ❌</td>
<td align="center">无法识别 ❌</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
</tr>
<tr>
<td align="center">小程序太阳码</td>
<td align="center">无反应 ❌</td>
<td align="center">预览黑屏 ❌</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
</tr>
<tr>
<td align="center">企微名片二维码</td>
<td align="center">无反应 ❌</td>
<td align="center">预览黑屏 ❌</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
</tr>
<tr>
<td align="center">企微群二维码</td>
<td align="center">无反应 ❌</td>
<td align="center">预览黑屏 ❌</td>
<td align="center">无法识别 ❌</td>
<td align="center">无法识别 ❌</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
</tr>
<tr>
<td align="center">企微群二维码(失效)</td>
<td align="center">无反应 ❌</td>
<td align="center">预览黑屏 ❌</td>
<td align="center">无法识别 ❌</td>
<td align="center">无法识别 ❌</td>
<td align="center">可识别 ✅</td>
<td align="center">可识别 ✅</td>
</tr>
</tbody></table>
<blockquote>
<p>注：微信 H5 长按图片识别码功能。如果屏幕内有很多码，长按没有完整展示在屏幕内的码，进行识别的时候，可能会识别出是屏幕其他码的信息。（疑似是微信的自身 bug）</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/image.html" target="_blank" rel="noopener">1. 官方文档 image 标签 <code>show-menu-by-longpress</code> 属性介绍</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewImage.html" target="_blank" rel="noopener">2. 官方文档 wx.previewImage 方法介绍</a></li>
</ul>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>6.记录修改Redux后没有触发渲染的问题</title>
    <url>/2020/06/30/6-%E8%AE%B0%E5%BD%95%E4%BF%AE%E6%94%B9Redux%E5%90%8E%E6%B2%A1%E6%9C%89%E8%A7%A6%E5%8F%91%E6%B8%B2%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h3><p>由于刚开始熟悉Taro + Redux + Hook的技术栈，<br>开发过程中有时候用的还很蹩脚，<br>出现了很多问题，也踩了许多坑。<br>今天就遇到这么个问题，<br>页面是根据Redux中的数据来渲染的，<br>可是明明已经修改了Redux的数据，<br>而且redux-logger也打印出来日志了，<br>页面却没有重新刷新渲染。  </p>
<a id="more"></a>

<h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>由于技术栈的不熟悉，想过了很多可能性，<br>比如：需要主动触发刷新函数、Hook的底层实现不一样等等……<br>疯狂的确认constants、reducers、actions这一流程的书写方式。<br>也尝试调用其他可以实现渲染有效的actions来找异同点。<br>最终还是通过日志发现了一些端倪。  </p>
<p><strong>不渲染的日志</strong><br>本意是将两个数组长度从5,2 改变成4,3。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">action POP_MODULE_SETTING_INFO</span><br><span class="line">prev state</span><br><span class="line">ModuleSettingInfo: &#123;</span><br><span class="line">  ...</span><br><span class="line">  arrShowModuleInfo: <span class="built_in">Array</span>(<span class="number">4</span>), </span><br><span class="line">  arrHideModuleInfo: <span class="built_in">Array</span>(<span class="number">3</span>),</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">action</span><br><span class="line">type: <span class="string">"POP_MODULE_SETTING_INFO"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">next state</span><br><span class="line">ModuleSettingInfo: &#123;</span><br><span class="line">  ...</span><br><span class="line">  arrShowModuleInfo: <span class="built_in">Array</span>(<span class="number">4</span>), </span><br><span class="line">  arrHideModuleInfo: <span class="built_in">Array</span>(<span class="number">3</span>),</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可是日志记录的是从4,3 改变成4,3。<br>那么是不是因为数据没有变化，所以没有触发渲染。<br>可是数据又是什么时候被改成4,3了呢？  </p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>代码此处的逻辑是，<br>通过Hook的useSelector，<br>来获取到Redux中的ModuleSettingInfo。<br>对取到的ModuleSettingInfo直接修改后，<br>使之作为参数再执行了action。  </p>
<p>简单的来说，我修改了两次。<br>第一次是直接因为浅拷贝，引用到那块内存给修改了，<br>第二次是使用Redux的action，通过正规操作又修改一次。<br>也是因为这次action日志被打印出来了，<br>不过因为第二次修改的时候，数值已经被修改过了，<br>所以日志的prev state和next state数值是一样的。<br>这样即使执行了action，因为数值没有变化，所以就没有触发页面的渲染。  </p>
<p><strong>错误的代码</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 找到移出项将其剔除</span><br><span class="line">const arrItemTmp &#x3D; arrShowModuleInfo.splice(nModuleItemIndex, 1); </span><br><span class="line">&#x2F;&#x2F; 将移出项塞入隐藏列表数组</span><br><span class="line">arrHideModuleInfo.unshift(arrItemTmp[0]);</span><br><span class="line">&#x2F;&#x2F; 结果存入redux并渲染</span><br><span class="line">popModuleSettingInfo(&#123;</span><br><span class="line">  arrShowModuleInfo,</span><br><span class="line">  arrHideModuleInfo</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>修改后的代码</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将Redux取到的对象深拷贝</span><br><span class="line">const arrShowModuleInfoTmp &#x3D; JSON.parse(JSON.stringify(arrShowModuleInfo));</span><br><span class="line">const arrHideModuleInfoTmp &#x3D; JSON.parse(JSON.stringify(arrHideModuleInfo));</span><br><span class="line">&#x2F;&#x2F; 找到移出项将其剔除</span><br><span class="line">const arrItemTmp &#x3D; arrShowModuleInfoTmp.splice(nModuleItemIndex, 1); </span><br><span class="line">&#x2F;&#x2F; 将移出项塞入隐藏列表数组</span><br><span class="line">arrHideModuleInfoTmp.unshift(arrItemTmp[0]);</span><br><span class="line">&#x2F;&#x2F; 结果存入redux并渲染</span><br><span class="line">popModuleSettingInfo(&#123;</span><br><span class="line">  arrShowModuleInfo: arrShowModuleInfoTmp,</span><br><span class="line">  arrHideModuleInfo: arrHideModuleInfoTmp</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h3><p>今天在做代码review的时候，<br>发现了一个很好的办法，<br>就是通过引用 <strong>immer</strong> 这个库。<br>Immer是mobx的作者写的一个immutable库，<br>核心实现是利用ES6的proxy，<br>几乎以最小的成本实现了js的不可变数据结构。  </p>
<p>简单的来说就是，想要修改一个对象，<br>如果直接修改，就会修改对象本身，<br>如果深拷贝之后再修改，就比较影响性能。<br>那么Immer的神奇之处就是只会对有变化的数值做深拷贝，<br>而没有变的地方还依然保持旧的引用，<br>以这种巧妙的方式杜绝了修改引用的副作用。  </p>
<p>引用网上的一个很透彻的说法，<br>“immer的copy-on-write是一个非常有意思的技术。它的思想在于当某个资源被多个实例使用，仅仅在改变值的时候，才copy出一个副本，否则都引用原始对象。”  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i --save immer</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">'immer'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不影响原来obj对象，且还能返回修改后的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funTest</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> produce(obj, <span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">    draft.x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> draft</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这个问题，总得来说还是对Taro、Redux、Hook的一些东西不熟悉。<br>这就让在定位问题的时候比较浪费时间，<br>怀疑自身Hook的使用方法、怀疑Redux的写法、<br>怀疑Hook底层实现、怀疑小程序的实现机制、<br>怀疑Taro的版本更新不靠谱等等……<br>结果，却是因为自身的Redux用法错误。  </p>
<p>好在最后终于找到问题，并且解决了。<br>附上正确的日志做个纪念。  </p>
<p><strong>实现渲染的日志</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">action POP_MODULE_SETTING_INFO</span><br><span class="line">prev state</span><br><span class="line">ModuleSettingInfo: &#123;</span><br><span class="line">  ...</span><br><span class="line">  arrShowModuleInfo: Array(5), </span><br><span class="line">  arrHideModuleInfo: Array(2),</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">action</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"POP_MODULE_SETTING_INFO"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">next state</span><br><span class="line">ModuleSettingInfo: &#123;</span><br><span class="line">  ...</span><br><span class="line">  arrShowModuleInfo: Array(4), </span><br><span class="line">  arrHideModuleInfo: Array(3),</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
        <tag>Hook</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>39.自己瞎捉摸之CSS动画实现</title>
    <url>/2022/09/21/39-%E8%87%AA%E5%B7%B1%E7%9E%8E%E6%8D%89%E6%91%B8%E4%B9%8BCSS%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="琢磨原因"><a href="#琢磨原因" class="headerlink" title="琢磨原因"></a>琢磨原因</h3><p>自己也是做过一些项目，<br>总感觉自己写出来的项目，<br>跟日常我们使用的应用 App 相比较，<br>总是有那么点说不清道不明的差距。<br>抽象讲就是粗糙，可是往细了说也说不出来到底差了哪里。<br>我琢磨了一段时间，感觉可能就是差在了动画上面。</p>
<a id="more"></a>

<h3 id="常见动画"><a href="#常见动画" class="headerlink" title="常见动画"></a>常见动画</h3><p>一个友好的动画反馈，可以让页面的元素不是那么突兀。<br>比如点击按钮，有一个微弱的放大后还原的动画过程，这样就比较有爱。<br>这样就会给用户一个反馈，<br>否则用户都无法感知，不知道是因为自己没有点到，还是因为页面卡住没有反应了，就会有焦虑的感觉。</p>
<p>比如需求需要弹出一个弹层，这个弹层如果从屏幕边缘出现或者屏幕中间从小到大缩放出现，<br>肯定是要比突然闪现在屏幕上要更好一些，<br>因为这样比较符合自然的规律，让用户有一个时间更容易接受这个弹层的交互。</p>
<p>比如说一个个性化的 loading，肯定要比早已经看腻了的转圈圈要有趣俏皮的多，<br>这个有趣的 loading 也能让用户有新鲜感，分散一下他的注意力，缓解等待页面数据加载时候的焦虑。</p>
<h3 id="CSS-实现"><a href="#CSS-实现" class="headerlink" title="CSS 实现"></a>CSS 实现</h3><p>目前 CSS 想要实现动画，通过两个属性是都可以实现的，<br>具体选择哪一种就可以通过具体的需求来使用对应的属性。</p>
<p>我个人认为 <code>transition</code>适用于两个状态的相互切换，<br>只要设置好 transition 相关属性，然后设置好元素的<code>初始状态</code>和<code>结束状态</code>，即可实现动画的样式。</p>
<p>而<code>animation</code>更实用于对于动画的复杂变化，对于动画的可控制程度更高，<br>比如一个动画周期的对应几个时间节点实现对应的样式，做好对应的<code>关键帧(keyframe)</code>，<br>然后通过 animation 的相关属性去绑定这些关键帧，即可实现动画的样式。</p>
<p>粗糙的总结一下，<br>如果简单的动画我会选择使用<code>transition</code>，<br>如果需要复杂控制的动画我会选择使用<code>animation</code></p>
<p>具体的动画的属性如下表所示：</p>
<ol>
<li>transition</li>
</ol>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
<th align="center">可使用值(第一个为默认值)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">transition-property</td>
<td align="left">规定设置过渡效果的 CSS 属性的名称</td>
<td align="center">none | all | property</td>
</tr>
<tr>
<td align="left">transition-duration</td>
<td align="left">规定完成过渡效果需要多少秒或毫秒</td>
<td align="center">0 | time</td>
</tr>
<tr>
<td align="left">transition-timing-function</td>
<td align="left">规定速度效果的速度曲线</td>
<td align="center">linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(n,n,n,n);</td>
</tr>
<tr>
<td align="left">transition-delay</td>
<td align="left">定义过渡效果何时开始</td>
<td align="center">0 | time</td>
</tr>
</tbody></table>
<p>参考示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demoTransition</span> &#123;</span><br><span class="line">  <span class="attribute">transition-property</span>: all;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">0.5s</span>;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">transition-delay</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>animation</li>
</ol>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
<th align="center">可使用值(第一个为默认值)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">animation-name</td>
<td align="left">规定需要绑定到选择器的 keyframe 名称</td>
<td align="center">keyframename | none</td>
</tr>
<tr>
<td align="left">animation-duration</td>
<td align="left">规定完成动画所花费的时间，以秒或毫秒计</td>
<td align="center">0 | time</td>
</tr>
<tr>
<td align="left">animation-timing-function</td>
<td align="left">规定动画的速度曲线</td>
<td align="center">linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(n,n,n,n);</td>
</tr>
<tr>
<td align="left">animation-delay</td>
<td align="left">规定在动画开始之前的延迟</td>
<td align="center">0 | time</td>
</tr>
<tr>
<td align="left">animation-iteration-count</td>
<td align="left">规定动画应该播放的次数</td>
<td align="center">1 | n | infinite</td>
</tr>
<tr>
<td align="left">animation-direction</td>
<td align="left">规定是否应该轮流反向播放动画</td>
<td align="center">normal | alternate</td>
</tr>
</tbody></table>
<p>参考示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demoAnimation</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: press;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">0.5s</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">animation-direction</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> press &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>可能平时开发过程中，<br>产品和 UI 只是把东西的功能说清楚了，<br>具体的交互细节就没有一个很标准的验收结果，<br>再加上评估工时紧张，前端开发同学也是只能完成需求基本功能开发。<br>（如果还有空自己给加动画实现，是不是说明了工作量不饱和 😈）<br>自然而然就会产生这种廉价粗糙之嫌。<br>再加上 CSS 动画的适配再各个端可能也会有坑，也可能会对性能有些影响，<br>那么抱着多一事不如少一事的态度，就只能把需求的功能完成就是万事大吉了，<br>再者说，万一加个动画说不定能加出来一大坨 bug，<br>所以在产品不特意要求的情况下，也就自然不愿意给自己加戏了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.w3school.com.cn/cssref/pr_transition.asp" target="_blank" rel="noopener">1. CSS transition 属性</a></li>
<li><a href="https://www.w3school.com.cn/cssref/pr_animation.asp" target="_blank" rel="noopener">2. CSS animation 属性</a></li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>44.浅谈微信小程序订阅消息交互体现</title>
    <url>/2023/06/07/44-%E6%B5%85%E8%B0%88%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%E4%BA%A4%E4%BA%92%E4%BD%93%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="记录背景"><a href="#记录背景" class="headerlink" title="记录背景"></a>记录背景</h3><p>订阅消息也是用了许久，不过总是懒得把各种场景整理一遍。<br>以至于每次产品问到我的时候，都是有些模棱两可的回答。<br>这次终于是下定决心要把各种情况整理好，这样再问到我的时候，直接把这篇文章丢过去就好了。</p>
<a id="more"></a>

<h3 id="情况总结"><a href="#情况总结" class="headerlink" title="情况总结"></a>情况总结</h3><ol>
<li>无法判断是点击什么按钮，也无法判断订阅弹窗是否曝光。通过微信 api 的回调返回值，只能知道用户操作后各个模板的允许或拒绝状态。</li>
<li>勾选“总是保持以上选择”，点击取消，返回结果上述订阅都为”reject”，但是下次还是可以拉取弹窗的。</li>
<li>用户发生点击行为或者发起支付回调后，才可以调起订阅消息界面，否则会报错 fail 如下所示</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"errMsg"</span>: <span class="string">"requestSubscribeMessage:fail can only be invoked by user TAP gesture."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>一次性订阅、长期订阅混用模板 tmplIds 不能混用，否则会报错 fail 如下所示</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"errCode"</span>: <span class="number">20002</span>,</span><br><span class="line">  <span class="string">"errMsg"</span>: <span class="string">"requestSubscribeMessage:fail Templates type must be same"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>tmplIds 值传空数组 []/非法值，会报错 fail 如下所示</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"errCode"</span>: <span class="number">10001</span>,</span><br><span class="line">  <span class="string">"errMsg"</span>: <span class="string">"requestSubscribeMessage:fail TmplIds can't be empty"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果消息订阅操作中选择了“总是保持以上选择”或者“全部拒绝，不再询问”，那么这个账号将再也不会拉起对应模板 id 的授权弹窗了，不过可以通过右上角设置页面对其修改“接收”或者“不接收”状态。</li>
<li>部分交互只有真机状态才能看出来。</li>
</ol>
<h3 id="结果示例"><a href="#结果示例" class="headerlink" title="结果示例"></a>结果示例</h3><ol>
<li>只选中一个，点击允许</li>
</ol>
<p>返回结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"VCXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"reject"</span>,</span><br><span class="line">  <span class="string">"QJXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"accept"</span>,</span><br><span class="line">  <span class="string">"errMsg"</span>: <span class="string">"requestSubscribeMessage:ok"</span>,</span><br><span class="line">  <span class="string">"B0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"reject"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>点击“全部拒绝，不再询问”，多条订阅消息，一个选中，一个不选中，也为全部拒绝。</li>
</ol>
<p>返回结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"errMsg"</span>: <span class="string">"requestSubscribeMessage:ok"</span>,</span><br><span class="line">  <span class="string">"I7XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"reject"</span>,</span><br><span class="line">  <span class="string">"xCXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"reject"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续则再也不会弹出授权框，直接返回同上面一样的结果（即为全部拒绝）。</p>
<ol start="3">
<li>多条订阅消息，一个选中，一个不选中，勾选“总是保持以上选择”，点击确定。</li>
</ol>
<p>结果返回如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"T9XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"reject"</span>,</span><br><span class="line">  <span class="string">"errMsg"</span>: <span class="string">"requestSubscribeMessage:ok"</span>,</span><br><span class="line">  <span class="string">"xcXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"accept"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续则再也不会弹出授权框，直接返回同上面一样的结果（即为一个允许，一个拒绝）。</p>
<ol start="4">
<li>多条订阅消息。</li>
</ol>
<p>其中一条消息为曾经选择了“总是保持以上选择”，<br>一条消息为层级选择了“全部拒绝，不再询问”，<br>一条消息为新的模板消息，则会弹窗授权框，<br>且只有那一条新的模板消息可操作，点击确定。<br>结果返回如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"T9XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"reject"</span>,</span><br><span class="line">  <span class="string">"ArXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"accept"</span>,</span><br><span class="line">  <span class="string">"errMsg"</span>: <span class="string">"requestSubscribeMessage:ok"</span>,</span><br><span class="line">  <span class="string">"xCXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>: <span class="string">"reject"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html" target="_blank" rel="noopener">1. 微信小程序调起客户端小程序订阅消息界面官方文档</a></li>
</ul>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>8.解决Taro里面滚动穿透的问题</title>
    <url>/2020/07/05/8-%E8%A7%A3%E5%86%B3Taro%E9%87%8C%E9%9D%A2%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h3><p>最近的项目在用Taro重构代码，<br>接到个令人头秃的交互，通过拖拽栏目来改变排序顺序。<br>好在小程序和Taro框架，<br>已经封装了<strong>MovableArea</strong>和<strong>MovableView</strong>这俩标签，能降低点难度。<br>不过还是需要通过计算来定位位置，让我这个学酥瑟瑟发抖。  </p>
<p>结果实现到最后的时候，遇到了个大坑，<br>就是滚动穿透的问题。<br>效果就是，当这边拖拽着栏目的时候，结果页面也跟着一起滚动。<br>也是醉了。  </p>
<a id="more"></a>

<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>首先，想到的就是事件拦截，<br>比如阻止事件冒泡，结果拦截也木有用，<br>或者用原生小程序catchtouchmove来绑定事件，<br>结果直接语法报错，一脸懵逼。  </p>
<p>其次，就百度谷歌，<br>网上也有一些解决方法，<br>不过在我这里唯一生效的方法，就是靠样式生生阻止了滚动，<br>虽然感觉这个方法有些奇葩，<br>但是目前也就先采用这个方案了。  </p>
<p>最后，就是禁用iOS系统特有的屏幕滚动特效。<br>不禁用采取默认值的话，<br>iOS机型的屏幕依旧滚动的很魔性。  </p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>在最外层的View增加样式，<br>通过是否处于点击状态变量标识，来改变样式。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View className&#x3D;&#123;&#96;$&#123;isTouch ? &#39;scroll-lock&#39;: &#39;scroll-unlock&#39;&#125;&#96;&#125;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.scroll-lock</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>; </span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scroll-unlock</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>; </span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>禁用iOS系统特有的屏幕滚动特效。<br>页面级新建文件 ./index.config.ts  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  disableScroll: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>话说Taro论坛也没有相关的介绍，<br>感觉这个问题应该是比较常见啊。<br>不知道是不是我找错位置了。  </p>
<p>而且，另外有种感觉就是React系框架写东西很吃力，<br>也是自己不太熟悉的原因吧。  </p>
<p>如果让我比喻的话（狗头保命勿喷），<br>Vue系的框架，像是一盘快餐，像是自动挡的车，<br>可以快速的满足需求，很多都是傻瓜式操作，<br>框架默认帮助自己做了很多东西，<br>这样缺点就是会导致代码可优化空间也会很有限，<br>当项目做大会觉得后继无力。  </p>
<p>React系的框架，像是一顿正餐，像是手动挡的车，<br>煎炸烹煮都可以开发者自由的选择，<br>自由度高，可操作性比较复杂，<br>正因为如此，<br>导致项目差异会很大，想充分驾驭React就需要更多的知识储备，<br>高手和菜鸟写出来的东西完全是两种效果。  </p>
<p>前端就是一个这样的生态环境吧，<br>框架迭代频繁，<br>逆水行舟，不进则退。<br>每天只有不断地学习，才能不会被后浪拍在沙滩上吧。  </p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title>5.阻止Taro框架中的事件冒泡</title>
    <url>/2020/06/22/5-%E9%98%BB%E6%AD%A2Taro%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h3 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h3><p>在书写Taro的一个弹窗组件的时候，<br>在弹窗按钮和蒙层分别绑定了点击事件。<br>结果点击按钮的时候，<br>蒙层事件也被触发了。<br>这个就是事件冒泡很正常的事情，  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.stopPropagation();</span><br></pre></td></tr></table></figure>
<p>本以为阻止一下就可以了，<br>结果发现并不好用。  </p>
<a id="more"></a>

<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>网上找了很多文档都是这么说的，<br>后来在一条评论下面找到了答案。<br>原因是我绑定事件的写法不对。<br>正确的写法应该是。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onClick&#x3D;&#123;this.handleMaskClick.bind(this)&#125;</span><br></pre></td></tr></table></figure>
<p>参考代码  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 点击蒙板</span><br><span class="line">handleMaskClick (e: Event) &#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  console.log(&#39;handleMaskClick&#39;);</span><br><span class="line">  this.setShow(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击登录按钮</span><br><span class="line">handleLoginClick (e: Event) &#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  console.log(&#39;handleLoginClick&#39;);</span><br><span class="line">  this.setShow(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      m_isShow</span><br><span class="line">    &#125; &#x3D; this.state;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;View className&#x3D;&#39;login-dialog-wrap&#39;&gt;</span><br><span class="line">        &lt;View </span><br><span class="line">          className&#x3D;&#39;login-dialog-mask&#39;</span><br><span class="line">          onClick&#x3D;&#123;this.handleMaskClick.bind(this)&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;View className&#x3D;&#123;classNames(m_isShow ? </span><br><span class="line">                                      &#39;fade-in-from-btottom login-dialog-content&#39; : </span><br><span class="line">                                      &#39;fade-out-from-btottom login-dialog-content&#39;)&#125;</span><br><span class="line">          &gt;</span><br><span class="line">              &lt;View className&#x3D;&#39;content-text&#39;&gt;</span><br><span class="line">                登录后即可体验更多服务</span><br><span class="line">              &lt;&#x2F;View&gt;</span><br><span class="line">              &lt;Button </span><br><span class="line">                className&#x3D;&#39;content-button&#39;</span><br><span class="line">                openType&#x3D;&#39;getUserInfo&#39;</span><br><span class="line">                onClick&#x3D;&#123;this.handleLoginClick.bind(this)&#125;</span><br><span class="line">              &gt;</span><br><span class="line">                微信登录</span><br><span class="line">              &lt;&#x2F;Button&gt;</span><br><span class="line">            &lt;&#x2F;View&gt;</span><br><span class="line">        &lt;&#x2F;View&gt;</span><br><span class="line">      &lt;&#x2F;View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>虽然Taro是一个能够多端开发，跨平台的优秀框架，<br>不过不知道是不是菜鸟手生的缘故，<br>总是感觉遇到了很多奇奇怪怪的坑。<br>比如这个阻止事件冒泡，<br>还有不能使用修饰方法的装饰器什么的，<br>反正踩着踩着，<br>也就习惯了。  </p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title>7.Shell脚本之实现微信小程序本地自动打包上传</title>
    <url>/2020/07/05/7-Shell%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%AC%E5%9C%B0%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h3 id="背景痛点"><a href="#背景痛点" class="headerlink" title="背景痛点"></a>背景痛点</h3><p>在开发流程中的测试阶段，<br>当测试完一批 bug 单，就需要去打一个最新版的体验码，<br>来配合测试去检验新的一批 bug 单。<br>打体验码的话，需要那个人现将写到一半的代码 git stash，<br>开始编译打包。</p>
<p>在持续集成系统没有搭建完毕的时候，<br>可以临时写一个脚本，来完成繁琐的打包上传工作。</p>
<a id="more"></a>

<h3 id="脚本功能"><a href="#脚本功能" class="headerlink" title="脚本功能"></a>脚本功能</h3><p>通过 shell 脚本来实现平台版和专属版小程序自动打包的功能。<br>只需要在拉取最新代码后，执行脚本，输入版本号/版本备注，<br>即可实现一键对平台版/专属版，两套代码的自动编译，<br>利用微信 cli 接口来实现打包上传。<br>每次打体验码时间大概可以控制在 5 分钟以内。</p>
<h3 id="脚本思路"><a href="#脚本思路" class="headerlink" title="脚本思路"></a>脚本思路</h3><ol>
<li>校验入参合法性。版本号的规则正则校验。</li>
<li>兼容 Window 和 mac 系统，适配两个系统的路径。</li>
<li>修改小程序标识位，设置为专属版标识。</li>
<li>编译代码。</li>
<li>修改开发者工具 appid。</li>
<li>上传代码</li>
<li>重复 3-6 步骤，将小程序标识位设置为平台版。</li>
</ol>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ol>
<li><p>macOS:<br>&lt;安装路径&gt;/Contents/MacOS/cli</p>
</li>
<li><p>Windows:<br>配置环境变量 WECHAT_DEVTOOL_PATH_CLI: &lt;安装路径&gt;/cli.bat<br>※ 确保安装路径不能有空格！<br>重启电脑以应用环境变量<br>配置 nodejs / npm 环境</p>
</li>
<li><p>微信开发者工具配置:<br>设置 -&gt; 安全设置 -&gt; 服务端口<br>设置为：开启</p>
</li>
</ol>
<h3 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h3><ol>
<li>目前脚本只是调用写死的 APPID，未来可以优化动态读取小程序的 APPID。</li>
</ol>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="../../../../assets/assets_7_1.sh">小程序本地自动打包脚本</a></p>
]]></content>
      <categories>
        <category>projects</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>45.简单聊聊Chrome开发者工具调试</title>
    <url>/2023/06/10/45-%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8AChrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h3 id="简单聊聊"><a href="#简单聊聊" class="headerlink" title="简单聊聊"></a>简单聊聊</h3><p>作为一个尊贵的前端开发工程师，<br>每天都在跟浏览器打交道。<br>而现代化浏览器配套的开发者工具不应该只是输出日志的终端。<br>那么今天就抽空把自己了解或者用过的功能整理一下。</p>
<a id="more"></a>

<h3 id="开发者工具-Devtool"><a href="#开发者工具-Devtool" class="headerlink" title="开发者工具 Devtool"></a>开发者工具 Devtool</h3><p>想要在浏览器中打开开发者工具可以通过下面 3 种方式：</p>
<ol>
<li>菜单… =&gt; 更多工具 =&gt; 开发者工具</li>
<li>页面上右键 =&gt; 检查</li>
<li>快捷键。MacOS: command + option + I ， Windows: F12</li>
</ol>
<p>打开之后大概工具页面分为了几个区域，如下图所示：<br><img src="../../../../images/image_45_1.jpg" alt="开发者工具 Devtool 视图1"></p>
<p>下面就详细说一下各个区域部分的功能和作用。</p>
<h3 id="a、为通过鼠标滑过页面快速定位到指定元素进行检查对应的-html-css。"><a href="#a、为通过鼠标滑过页面快速定位到指定元素进行检查对应的-html-css。" class="headerlink" title="a、为通过鼠标滑过页面快速定位到指定元素进行检查对应的 html/css。"></a>a、为通过鼠标滑过页面快速定位到指定元素进行检查对应的 html/css。</h3><p>当想要定位出现问题的元素的时候，可以用到该功能。<br>快捷键为 MacOS: command + shift + C ， Windows: ctrl + shift + C</p>
<h3 id="b、显示-隐藏设备工具栏"><a href="#b、显示-隐藏设备工具栏" class="headerlink" title="b、显示/隐藏设备工具栏"></a>b、显示/隐藏设备工具栏</h3><p>当激活的时候为模拟移动端设备的屏幕样式。如下图所示：<br><img src="../../../../images/image_45_2.jpg" alt="显示/隐藏设备工具栏"></p>
<h4 id="a-当前模拟设备的名称"><a href="#a-当前模拟设备的名称" class="headerlink" title="a) 当前模拟设备的名称"></a>a) 当前模拟设备的名称</h4><p>点击此处可以弹出下拉设备切换弹窗，用以切换模拟设备。</p>
<h4 id="b-当前模拟设备的屏幕尺寸"><a href="#b-当前模拟设备的屏幕尺寸" class="headerlink" title="b) 当前模拟设备的屏幕尺寸"></a>b) 当前模拟设备的屏幕尺寸</h4><p>正常情况下此处尺寸为只读。只有当设备选择为 Responsive （自定义） 时，此处可以自由修改屏幕尺寸。</p>
<h4 id="c-当前模拟设备缩放比例"><a href="#c-当前模拟设备缩放比例" class="headerlink" title="c) 当前模拟设备缩放比例"></a>c) 当前模拟设备缩放比例</h4><p>建议屏幕能展示完整的情况下，尽量保持设置为 100%。<br>目测在非 100%的情况下，有些交互偶现不能正常模拟出来。<br>比如：页面点击无反应，overflow: auto;区域无法滑动等奇葩情况。</p>
<h4 id="d-模拟设备的其他操作"><a href="#d-模拟设备的其他操作" class="headerlink" title="d) 模拟设备的其他操作"></a>d) 模拟设备的其他操作</h4><p>比如：展示/隐藏媒体查询，展示/隐藏标尺线，截屏，重置设置等。</p>
<h4 id="e-设备切换-Responsive-类型设备"><a href="#e-设备切换-Responsive-类型设备" class="headerlink" title="e) 设备切换 Responsive 类型设备"></a>e) 设备切换 Responsive 类型设备</h4><p>可以自由修改屏幕尺寸的类型。</p>
<h4 id="f-设备切换自定义类型设备"><a href="#f-设备切换自定义类型设备" class="headerlink" title="f) 设备切换自定义类型设备"></a>f) 设备切换自定义类型设备</h4><p>此处可以选择之前我们配置保存好的设备。<br>比如此处我曾经配置了两个设备。<br>一个名字是 micromessenger ios，这个是模拟了 ios 手机微信内置浏览器的设备环境。<br>一个名字是 webview，这个是模拟了微信小程序 webview 的设备环境。</p>
<p>只需我们将对应的尺寸和 user agent 配置好一次，后续我们想要模拟这种设备场景，那么就可以直接使用了。</p>
<h4 id="g-设备切换浏览器内置类型设备"><a href="#g-设备切换浏览器内置类型设备" class="headerlink" title="g) 设备切换浏览器内置类型设备"></a>g) 设备切换浏览器内置类型设备</h4><p>此处可以选择浏览器内置一些主流类型设备。<br>不用我们每种设备都自己去配置了， 可以优先看一下此处，<br>如果是有了内置的对应的类型设备，<br>那就省事了直接使用即可。</p>
<h4 id="h-编辑类型设备"><a href="#h-编辑类型设备" class="headerlink" title="h) 编辑类型设备"></a>h) 编辑类型设备</h4><p>此处点击即可弹出右侧的设备编辑面板。<br>即可对设备切换弹窗列表里的设备进行编辑。</p>
<h4 id="i-新增自定义类型设备"><a href="#i-新增自定义类型设备" class="headerlink" title="i) 新增自定义类型设备"></a>i) 新增自定义类型设备</h4><p>点击即可弹出<code>2.11</code>的新增/编辑设备面板</p>
<h4 id="j-编辑-删除自定义类型设备"><a href="#j-编辑-删除自定义类型设备" class="headerlink" title="j) 编辑/删除自定义类型设备"></a>j) 编辑/删除自定义类型设备</h4><p>点击分别为编辑/删除对应的自定义类型设备</p>
<h4 id="k-新增-编辑自定义设备面板"><a href="#k-新增-编辑自定义设备面板" class="headerlink" title="k) 新增/编辑自定义设备面板"></a>k) 新增/编辑自定义设备面板</h4><p>此处可以对自定义设备的各项参数进行调整。<br>比如：设备名，设备屏幕宽高尺寸，useragent 等。</p>
<p>设备参数修改完毕后点击对应”Add”、”Save”按钮即可保存，<br>记得要将设备前面的蓝色复选框勾选中，<br>这样才能将这个设备展示到<code>2.6</code>下拉设备切换弹窗的自定义类型设备列表中。</p>
<h4 id="l-浏览器内置类型设备列表"><a href="#l-浏览器内置类型设备列表" class="headerlink" title="l) 浏览器内置类型设备列表"></a>l) 浏览器内置类型设备列表</h4><p>因为浏览器内置的设备比较多，<br>此处只需要勾选中自己平时开发所需的几种类型设备即可，<br>这样勾选中的设备就会展示到<code>2.7</code>下拉设备切换弹窗的内置类型设备列表中。</p>
<h3 id="c、tab-区域【核心功能】"><a href="#c、tab-区域【核心功能】" class="headerlink" title="c、tab 区域【核心功能】"></a>c、tab 区域【核心功能】</h3><h4 id="Element（元素）"><a href="#Element（元素）" class="headerlink" title="Element（元素）"></a>Element（元素）</h4><p>该 tab 项主要为展示页面的节点元素信息。</p>
<h5 id="a-网页的-html-结构"><a href="#a-网页的-html-结构" class="headerlink" title="a) 网页的 html 结构"></a>a) 网页的 html 结构</h5><p>此处可以看到渲染网页出来的对应 html 结构，<br>这里可以与<code>command + shift + C</code>中的快速定位到指定元素功能配合使用。<br>根据 DOM 树的情况，来方便快速定位问题。<br>同时，此处面板也支持对 DOM 的直接修改，<br>比如新增属性、修改 html 结构、删除节点等，如下图所示：</p>
<p><img src="../../../../images/image_45_3.jpg" alt="网页的 html 结构修改"></p>
<h5 id="b-网页的-css-样式"><a href="#b-网页的-css-样式" class="headerlink" title="b) 网页的 css 样式"></a>b) 网页的 css 样式</h5><p>此处可以看到渲染网页出来的对应 css 样式，<br>比如当我们开发完毕之后，发现页面样式并没有生效，<br>那么我们就可以通过此处面板对元素进行定位后，<br>查看应用到元素的 css 样式是被其他优先级更高的样式覆盖了，还是样式本身书写有问题。<br>同时，此处面板也支持对 css 直接修改，页面就会更新刚刚书写后的 css 样式。<br>这样一来，节约了每次修改代码，编译打包，再看效果的时间，提升了修改样式的开发效率。<br>另外，css 面板也可以在本地去秀一些操作，<br>比如可以将页面上的这张新闻图片变为黑白图片，以及将直角改为了圆角等等，如下图所示：</p>
<p><img src="../../../../images/image_45_4.jpg" alt="网页的 css 样式修改"></p>
<h4 id="Console（控制台）"><a href="#Console（控制台）" class="headerlink" title="Console（控制台）"></a>Console（控制台）</h4><p>该 tab 项主要为展示日志输出以及调试信息。<br>PS: 此处开始翻译不太动了，吃了口饭继续肝，想想干脆切换成汉化页面了。<br>具体页面如下图所示：</p>
<p><img src="../../../../images/image_45_5.jpg" alt="Console页面板"></p>
<h5 id="a-展开-收起左侧日志筛选栏"><a href="#a-展开-收起左侧日志筛选栏" class="headerlink" title="a) 展开/收起左侧日志筛选栏"></a>a) 展开/收起左侧日志筛选栏</h5><h5 id="b-清空控制台数据"><a href="#b-清空控制台数据" class="headerlink" title="b) 清空控制台数据"></a>b) 清空控制台数据</h5><h5 id="c-查看控制台信息纬度"><a href="#c-查看控制台信息纬度" class="headerlink" title="c) 查看控制台信息纬度"></a>c) 查看控制台信息纬度</h5><p>当页面中还嵌套 iframe 的时候，<br>想要查看 iframe 嵌套的日志信息。<br>那么就可以在此处切换为对应 iframe 的名字。</p>
<h5 id="d-监听变量-表达式"><a href="#d-监听变量-表达式" class="headerlink" title="d) 监听变量/表达式"></a>d) 监听变量/表达式</h5><p>点击小眼睛就会新增一个监听项。<br>该监听项可以是一个变量，也可以是一个表达式。<br>那么在程序运行过程中，会动态的展示对应的数据变化。</p>
<h5 id="e-日志过滤器"><a href="#e-日志过滤器" class="headerlink" title="e) 日志过滤器"></a>e) 日志过滤器</h5><p>如果日志过多的时候，<br>可以通过该过滤器输入关键字，<br>那么下方输出日志的时候就只会输出包含该关键字的日志。</p>
<h5 id="f-展开-收起控制台设置"><a href="#f-展开-收起控制台设置" class="headerlink" title="f) 展开/收起控制台设置"></a>f) 展开/收起控制台设置</h5><p>通过该齿轮来切换是否展示下方的控制台设置面板。</p>
<h5 id="g-控制台设置面板"><a href="#g-控制台设置面板" class="headerlink" title="g) 控制台设置面板"></a>g) 控制台设置面板</h5><p>具体功能可对应汉字内容。<br>值得注意的是，<code>保留日志</code>功能较为常用。<br>比如，我们有场景是进入一个 A 页面，而 A 页面指定条件需要重定向到另一个 B 页面，<br>那么如果<code>保留日志</code>如果没有勾选上，那么就会只存在 B 页面的日志，而无法看到 A 页面的日志。<br>所以勾选之后，就可以方便 A 页面打印日志也可以看得到了。</p>
<h5 id="h-左侧日志筛选栏"><a href="#h-左侧日志筛选栏" class="headerlink" title="h) 左侧日志筛选栏"></a>h) 左侧日志筛选栏</h5><p>根据日志的输出等级，来对日志进行筛选。</p>
<ul>
<li>debug: 可以在全部消息、用户消息、详细消息中展示。</li>
<li>info: 可以在全部消息、用户消息、信息中展示。</li>
<li>log: 可以在全部消息、用户消息、信息中展示。</li>
<li>warn: 可以在全部消息、用户消息、警告中展示。</li>
<li>error: 可以在全部消息、用户消息、错误中展示。</li>
</ul>
<h5 id="i-控制台手写命令：正常计算"><a href="#i-控制台手写命令：正常计算" class="headerlink" title="i) 控制台手写命令：正常计算"></a>i) 控制台手写命令：正常计算</h5><p>可以正常输出的数值计算。（js 会有精度丢失问题）</p>
<h5 id="j-控制台手写命令：正常调用-api"><a href="#j-控制台手写命令：正常调用-api" class="headerlink" title="j) 控制台手写命令：正常调用 api"></a>j) 控制台手写命令：正常调用 api</h5><p>可以正常调用 js 的 api 方法。</p>
<h5 id="k-控制台手写命令：查看对象拥有的方法"><a href="#k-控制台手写命令：查看对象拥有的方法" class="headerlink" title="k) 控制台手写命令：查看对象拥有的方法"></a>k) 控制台手写命令：查看对象拥有的方法</h5><p>可以正常查看 window.location 对象都拥有哪些方法，哪些属性。</p>
<h5 id="l-控制台手写命令：正常调用弹窗"><a href="#l-控制台手写命令：正常调用弹窗" class="headerlink" title="l) 控制台手写命令：正常调用弹窗"></a>l) 控制台手写命令：正常调用弹窗</h5><p>可以正常调用弹窗方法。</p>
<h5 id="m-控制台手写命令：浏览器内置语句"><a href="#m-控制台手写命令：浏览器内置语句" class="headerlink" title="m) 控制台手写命令：浏览器内置语句"></a>m) 控制台手写命令：浏览器内置语句</h5><p>此处的<code>$0</code>，并不是 jQuery 的方法，<br>而是借助浏览器<code>command + shift + C</code>中的快速定位到指定元素功能。<br>将<code>$0</code>指代为最近选中的元素节点。</p>
<h5 id="n-控制台手写命令：浏览器内置语句示例"><a href="#n-控制台手写命令：浏览器内置语句示例" class="headerlink" title="n) 控制台手写命令：浏览器内置语句示例"></a>n) 控制台手写命令：浏览器内置语句示例</h5><p>此处即为上次通过定位元素定位的是这个按钮元素，<br>那么控制台<code>$0</code>输出的其实就是这个按钮元素的节点。</p>
<h5 id="o-控制台手写命令：console-table"><a href="#o-控制台手写命令：console-table" class="headerlink" title="o) 控制台手写命令：console.table"></a>o) 控制台手写命令：console.table</h5><p>console 不仅可以支持输出普通的文本。</p>
<ul>
<li>他可以输出表格，如代码所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出一个表格</span></span><br><span class="line"><span class="built_in">console</span>.table([</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"张三"</span>,</span><br><span class="line">    age: <span class="number">53</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"李四"</span>,</span><br><span class="line">    age: <span class="number">48</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<ul>
<li>他也可以输出带样式的问题，如代码所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出一行文字，</span></span><br><span class="line"><span class="comment">// "Hello" 字号为20px，黄色字，蓝色背景</span></span><br><span class="line"><span class="comment">// " Baidu" 字号为36px，红色字</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">"%cHello%c Baidu"</span>,</span><br><span class="line">  <span class="string">"color: yellow; font-size: 20px; background-color: blue"</span>,</span><br><span class="line">  <span class="string">"color: red; font-size: 36px;"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="p-日志搜索栏"><a href="#p-日志搜索栏" class="headerlink" title="p) 日志搜索栏"></a>p) 日志搜索栏</h5><p>如果日志过多的时候，<br>也可以通过<code>Ctrl + F</code> 或者<code>command + F</code>对日志进行搜索。<br>如何条件的部分会高亮现实，并且可以快速匹配位置。</p>
<h4 id="Sources（源代码）"><a href="#Sources（源代码）" class="headerlink" title="Sources（源代码）"></a>Sources（源代码）</h4><p>该 tab 项主要浏览器下载到本地的 js 等文件。<br>可以通过这个这个 tab 来对页面的 js 的逻辑进行断点、调试。<br>具体页面如下图所示：</p>
<p><img src="../../../../images/image_45_6.jpg" alt="Sources页面板"></p>
<h5 id="a-左侧资源树栏"><a href="#a-左侧资源树栏" class="headerlink" title="a) 左侧资源树栏"></a>a) 左侧资源树栏</h5><h5 id="b-代码格式化按钮"><a href="#b-代码格式化按钮" class="headerlink" title="b) 代码格式化按钮"></a>b) 代码格式化按钮</h5><p>很有可能我们拿到的 js 代码是经过压缩混淆过的，<br>所有代码都在一行，对我们阅读代码非常不利，<br>那么此时可以点击这个按钮，对代码进行格式化，<br>虽然变量名没办法还原，不过最起码可以看懂大概的代码结构。<br>方便我们梳理代码逻辑，以及定位问题。</p>
<h5 id="c-断点区域"><a href="#c-断点区域" class="headerlink" title="c) 断点区域"></a>c) 断点区域</h5><p>跟其他的编译器相似，代码的做的区域为断点区域，<br>如果在代码前面打标，即为此处设置断点，<br>如果代码再次执行到这个位置，就会被停住，<br>然后方便我们来查看此时的变量状态，<br>以及后续代码是如何执行的。</p>
<h5 id="d-断点操作区域"><a href="#d-断点操作区域" class="headerlink" title="d) 断点操作区域"></a>d) 断点操作区域</h5><p>跟其他编译器相似，<br>拥有继续放开执行，一步步调试执行，进入函数内部，消除所有断点等功能。<br>此处不再赘述。</p>
<h5 id="e-监听变量面板"><a href="#e-监听变量面板" class="headerlink" title="e) 监听变量面板"></a>e) 监听变量面板</h5><p>我们可以在此处面板，如果点击<code>+</code>，<br>手动录入想要监听的关键变量名称，<br>那么就可以随时看到这个变量的状态，<br>方便我们定位问题。</p>
<h5 id="f-各维度变量面板"><a href="#f-各维度变量面板" class="headerlink" title="f) 各维度变量面板"></a>f) 各维度变量面板</h5><p>我们可以在此处面板，查看各纬度的变量数据。<br>比如作用域内，闭包内，全局变量等。</p>
<h5 id="g-调用堆栈"><a href="#g-调用堆栈" class="headerlink" title="g) 调用堆栈"></a>g) 调用堆栈</h5><p>我们可以在此处面板，查看方法堆栈的调用情况。<br>比如图中所示，<br>即为断点此处代码，为名字叫<code>createRandThreeBall</code>的方法调用，<br>而<code>createRandThreeBall</code>方法，是被<code>_runActions</code>的方法调用，<br>以此类推，根据函数的调用情况，<br>也可以协助我们定位问题。</p>
<h4 id="NetWork（网络）"><a href="#NetWork（网络）" class="headerlink" title="NetWork（网络）"></a>NetWork（网络）</h4><p>该 tab 项主要为展示网络通讯的接口信息。<br>如果我们跟后端调试接口的阶段，就会基本都是再跟这个 tab 页打交道了。</p>
<p>具体页面如下图所示：</p>
<p><img src="../../../../images/image_45_7.jpg" alt="NetWork页面板"></p>
<h5 id="a-录制-关闭接口通讯情况"><a href="#a-录制-关闭接口通讯情况" class="headerlink" title="a) 录制/关闭接口通讯情况"></a>a) 录制/关闭接口通讯情况</h5><h5 id="b-清除之前所以得接口通讯情况"><a href="#b-清除之前所以得接口通讯情况" class="headerlink" title="b) 清除之前所以得接口通讯情况"></a>b) 清除之前所以得接口通讯情况</h5><h5 id="c-保留日志"><a href="#c-保留日志" class="headerlink" title="c) 保留日志"></a>c) 保留日志</h5><p>其功能与控制台的保留日志相似</p>
<h5 id="d-停用缓存"><a href="#d-停用缓存" class="headerlink" title="d) 停用缓存"></a>d) 停用缓存</h5><p>有些资源的请求如果请求到之后，<br>会在本地浏览器进行缓存的。<br>如果再次请求的时候服务器时，服务器返回的信息是资源没有变化直接取本地缓存就好，<br>那么这样的话就不会去拿服务器的资源，而是直接就取本地之前的缓存资源。<br>而这一项勾选之后，就不会再用缓存。</p>
<h5 id="e-网络节流模式"><a href="#e-网络节流模式" class="headerlink" title="e) 网络节流模式"></a>e) 网络节流模式</h5><p>通过该功能可以本地模拟各种网络状况。<br>浏览器内部内置了<code>高速3G</code>、<code>低速3G</code>、<code>离线</code>三种模式，<br>那么如果这三种模式不能满足项目需求，<br>我们也可以通过设置页面对节流策略进行设置，<br>配置网络上行、下行速度，以及延迟情况。<br>设置好后自定义好模式名称，就可以在此处直接应用了。</p>
<h5 id="f-展开-收起网络详细配置面板"><a href="#f-展开-收起网络详细配置面板" class="headerlink" title="f) 展开/收起网络详细配置面板"></a>f) 展开/收起网络详细配置面板</h5><p>比如：缓存、网络节流模式、用户代理、接受的 Content-Encoding。</p>
<h5 id="g-展开-收起网络其他配置面板"><a href="#g-展开-收起网络其他配置面板" class="headerlink" title="g) 展开/收起网络其他配置面板"></a>g) 展开/收起网络其他配置面板</h5><p>比如：使用大量请求行、按框架分组、显示概览、截取屏幕截图。</p>
<h5 id="h-接口过滤器"><a href="#h-接口过滤器" class="headerlink" title="h) 接口过滤器"></a>h) 接口过滤器</h5><p>如果接口过多的时候，<br>可以通过该过滤器输入关键字，<br>那么下方输出接口信息的时候就只会输出包含该关键字的接口请求。</p>
<h5 id="i-类型过滤器"><a href="#i-类型过滤器" class="headerlink" title="i) 类型过滤器"></a>i) 类型过滤器</h5><p>如果接口过多的时候，<br>可以通过该过滤器选择请求类型，<br>对接口请求信息进行过滤。<br>比如：只查看 Fetch/XHR 请求，或者只查看请求的 js 文件等。</p>
<h5 id="j-瀑布图过滤器"><a href="#j-瀑布图过滤器" class="headerlink" title="j) 瀑布图过滤器"></a>j) 瀑布图过滤器</h5><p>可以看到所有接口请求的一个瀑布图。<br>每一条即为一条请求。<br>条的长度越长即为请求的时间越长。<br>如果同一个时间段有好几条线，那说明这几个请求时并行进行请求的。<br>那么我们也可以对指定时间段进行过滤。<br>比如说，我只想看到 5s-10s 内的接口请求数据，<br>可以鼠标在瀑布图上，将这个时间段选中，下方的接口请求数据，即为这个时间段的请求接口。</p>
<h5 id="k-接口请求详表"><a href="#k-接口请求详表" class="headerlink" title="k) 接口请求详表"></a>k) 接口请求详表</h5><p>在这个表格内可以查看到接口请求的全部信息。<br>比如请求接口 url、状态码、返回结构体大小、请求时间等信息。<br>以及当我们定位到我们想要查看的接口的时候，<br>我们可以左键点击这个接口，就会看到这个接口更为详细的信息。<br>比如：header、body、require、response 等信息。</p>
<h4 id="Performance（性能）"><a href="#Performance（性能）" class="headerlink" title="Performance（性能）"></a>Performance（性能）</h4><p>该 tab 项主要为检测页面加载、交互等操作进行录制，<br>然后分析这段时间浏览器交互渲染的耗时情况，<br>进而定位那些耗时高的操作是哪些，来针对性的进行优化，<br>从而达到提高性能，优化用户体验的目的。</p>
<h4 id="Memory（内存）"><a href="#Memory（内存）" class="headerlink" title="Memory（内存）"></a>Memory（内存）</h4><p>该 tab 项看起来应该是内存相关，没太用过。<br>后面如果有机会用到了再来完善这部分介绍。</p>
<h4 id="Application（应用）"><a href="#Application（应用）" class="headerlink" title="Application（应用）"></a>Application（应用）</h4><p>该 tab 项主要是查看应用缓存，比如说我们最常用的。</p>
<ul>
<li>local storage 本地永久缓存</li>
<li>session storage 本地会话缓存</li>
<li>Cookie</li>
</ul>
<p>其他功能没太用过。<br>后面如果有机会用到了再来完善这部分介绍。</p>
<h4 id="Security（安全）"><a href="#Security（安全）" class="headerlink" title="Security（安全）"></a>Security（安全）</h4><p>该 tab 项看起来应该是安全相关，没太用过。<br>后面如果有机会用到了再来完善这部分介绍。</p>
<h4 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h4><p>该 tab 项看起来不知道是个啥，没太用过。<br>后面如果有机会用到了再来完善这部分介绍。</p>
<h4 id="（记录器）"><a href="#（记录器）" class="headerlink" title="（记录器）"></a>（记录器）</h4><p>该 tab 项看起来不知道是个啥，没太用过。<br>后面如果有机会用到了再来完善这部分介绍。</p>
<h4 id="（性能数据分析）"><a href="#（性能数据分析）" class="headerlink" title="（性能数据分析）"></a>（性能数据分析）</h4><p>该 tab 项看起来不知道是个啥，没太用过。<br>后面如果有机会用到了再来完善这部分介绍。</p>
<h3 id="d、Devtool-的相关设置"><a href="#d、Devtool-的相关设置" class="headerlink" title="d、Devtool 的相关设置"></a>d、Devtool 的相关设置</h3><h4 id="Preferences-（偏好配置）"><a href="#Preferences-（偏好配置）" class="headerlink" title="Preferences （偏好配置）"></a>Preferences （偏好配置）</h4><p>此处就是一般工具都会有的通用设置面板。<br>比如面板使用的主题：跟随系统、浅色、深色。<br>比如工具上使用的语言：英文、中文等。</p>
<p>值得注意的是，此处有个 Disable JavaScript 勾选框，<br>默认是不被勾选的，意味着允许浏览器运行 js。</p>
<p>那么比如说遇到一些不让复制的网站想要复制些文本的时候，<br>而屏蔽复制的功能大部分都是由 js 来实现的，<br>那么就可以简单的利用一下这个功能。<br>把 js 关闭后，在对文本进行复制，然后再重新开启 js 即可。<br>（仅适合绕过简单限制，有些网站也会在文本里放入各种隐形字符来防止我们非法复制）</p>
<h4 id="Workspace-（工作区）"><a href="#Workspace-（工作区）" class="headerlink" title="Workspace （工作区）"></a>Workspace （工作区）</h4><p>看起来是个工作区的什么东西，没太用过。<br>后面如果有机会用到了再来完善这部分介绍。</p>
<h4 id="Experiments-（实验）"><a href="#Experiments-（实验）" class="headerlink" title="Experiments （实验）"></a>Experiments （实验）</h4><p>看起来不知道是个啥，没太用过。<br>后面如果有机会用到了再来完善这部分介绍。</p>
<h4 id="Ignore-List-（忽略列表）"><a href="#Ignore-List-（忽略列表）" class="headerlink" title="Ignore List （忽略列表）"></a>Ignore List （忽略列表）</h4><p>看起来不知道是个啥，没太用过。<br>后面如果有机会用到了再来完善这部分介绍。</p>
<h4 id="Devices-（模拟设备）"><a href="#Devices-（模拟设备）" class="headerlink" title="Devices （模拟设备）"></a>Devices （模拟设备）</h4><p>用来配置模拟设备编辑面板，上述<code>2.8</code>讲过，不再赘述。</p>
<h4 id="Throttling-（节流）"><a href="#Throttling-（节流）" class="headerlink" title="Throttling （节流）"></a>Throttling （节流）</h4><p>用来配置网络自定义节流策略编辑面板。</p>
<h4 id="Locations-（自定义位置）"><a href="#Locations-（自定义位置）" class="headerlink" title="Locations （自定义位置）"></a>Locations （自定义位置）</h4><p>用来配置定位自定义策略编辑面板。</p>
<h4 id="Shortcuts-（快捷键）"><a href="#Shortcuts-（快捷键）" class="headerlink" title="Shortcuts （快捷键）"></a>Shortcuts （快捷键）</h4><p>用来配置相关的快捷键。</p>
<h3 id="e、Devtool-的其他功能"><a href="#e、Devtool-的其他功能" class="headerlink" title="e、Devtool 的其他功能"></a>e、Devtool 的其他功能</h3><p>如：各个面板的布局调整等。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实这样细致的过了一遍所有的面板功能之后，<br>发现自己还是有很大一部分功能都没有使用过，<br>用过的功能有些还没有太用透，<br>em…路漫漫其修远兮，吾将上下而求索，<br>看样子要学习的东西还是很多。<br>本篇文章剩余的残卷部分，<br>我会后续有新的理解感悟之后，再继续更新完善。</p>
]]></content>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>9.关于Taro中常用Hook的用法</title>
    <url>/2020/07/09/9-%E5%85%B3%E4%BA%8ETaro%E4%B8%AD%E5%B8%B8%E7%94%A8Hook%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="关于-Hook"><a href="#关于-Hook" class="headerlink" title="关于 Hook"></a>关于 Hook</h3><p>Hook 这个特性，是 React16.8 中新增的，<br>随着小程序框架 Taro 对 React 的支持，<br>让 Taro 也能开始使用，<br>甚至在 Taro3.0.0 开始，在底层 api 做了代理，<br>让 Hook 方法直接可以从 React 包中引用。<br>值得注意的是，<br>Hook 的方法，只能在函数组件的主体内部调用。</p>
<a id="more"></a>

<h3 id="React-系的-Hook"><a href="#React-系的-Hook" class="headerlink" title="React 系的 Hook"></a>React 系的 Hook</h3><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>由于函数式组件每次渲染都会执行一次函数，<br>那么函数内的变量是无法被保存住的。<br>所以如果想要将数据保存住的话，<br>需要使用这个 Hook，来将数据存储起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [nCount, setCount] &#x3D; useState&lt;number&gt;(0);</span><br><span class="line">&#x2F;&#x2F; 使用nCount</span><br><span class="line">console.log(&quot;nCount&quot;, nCount);</span><br><span class="line">&#x2F;&#x2F; 更新Count</span><br><span class="line">setCount(nCount++);</span><br></pre></td></tr></table></figure>

<h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>这个 Hook 可谓是最常用的方法，<br>同时也是一个很危险的 Hook，<br>因为他可以模拟出来 3 种以类方式 React 的声明周期。</p>
<ul>
<li>可以模拟刚加载页面或者组件的声明周期 <strong>componentsDidMount</strong></li>
<li>可以模拟销毁页面或者组件的声明周期 <strong>componentsWillUnmount</strong></li>
<li>如果有依赖项 <strong>deps</strong> 的时候，那么就会监听 <strong>deps</strong> 中的数据，一旦数据有变化，则也会执行一次函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; componentsDidMount</span><br><span class="line">  &#x2F;&#x2F; componentsDidUpdate</span><br><span class="line">  return () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; componentsWillUnmount</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [deps]);</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<br>正因为会检测数值变化，就会执行一次函数，<br>所以如果在函数内又修改了该数值，<br>就会很容易产生死循环，<br>所以要谨慎的对书写函数内的逻辑。</p>
<p>那么，你也应该发现了，<br>这个函数也是一个闭包，内部的数据存在于独立的存储空间，<br>内部的数据永远都只会是第一次创建时候的数据。<br>如果需要跟外接数据同步，就需要将想同步的变量加入依赖 <strong>deps</strong> 中，<br>这样变量发生变化一次之后，内部闭包函数重新调用一次以更新数据。</p>
<h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><h4 id="useCallBack"><a href="#useCallBack" class="headerlink" title="useCallBack"></a>useCallBack</h4><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>将数据绑定到页面节点之上，<br>该数据的范围提升到一个页面级的纬度。<br>同时也可以帮助父组件拿到子组件属性。</p>
<h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h4><p>父组件的数据传递给子组件。<br>先要 createContext,<br>通过 Provider 标签传递 value，<br>在子组件里 useContext 拿到传递下来的 value。</p>
<hr>
<h3 id="Taro-系（小程序专用）的-Hook"><a href="#Taro-系（小程序专用）的-Hook" class="headerlink" title="Taro 系（小程序专用）的 Hook"></a>Taro 系（小程序专用）的 Hook</h3><p>这些 Hook 对开发过小程序的小伙伴应该是非常友好的了。</p>
<h4 id="useDidShow"><a href="#useDidShow" class="headerlink" title="useDidShow"></a>useDidShow</h4><p>页面再度激活，<br>返回或者切回前台的生命周期，<br>等同于 <strong>onShow(componentDidShow)</strong></p>
<h4 id="useDidHide"><a href="#useDidHide" class="headerlink" title="useDidHide"></a>useDidHide</h4><p>切到后台，页面隐藏的生命周期，<br>等同于 <strong>onHide(componentDidHide)</strong></p>
<h4 id="usePullDownRefresh"><a href="#usePullDownRefresh" class="headerlink" title="usePullDownRefresh"></a>usePullDownRefresh</h4><p>下拉刷新的生命周期，<br>等同于 <strong>onPullDownRefresh</strong></p>
<h4 id="useReachBottom"><a href="#useReachBottom" class="headerlink" title="useReachBottom"></a>useReachBottom</h4><p>页面拉到底部的生命周期，<br>等同于 <strong>onReachBottom</strong></p>
<h4 id="usePageScroll"><a href="#usePageScroll" class="headerlink" title="usePageScroll"></a>usePageScroll</h4><p>页面发生滚动的生命周期，<br>等同于 <strong>onPageScroll</strong></p>
<h4 id="useResize"><a href="#useResize" class="headerlink" title="useResize"></a>useResize</h4><p>页面尺寸发生变化的生命周期，<br>等同于 <strong>onResize</strong></p>
<h4 id="useShareAppMessage"><a href="#useShareAppMessage" class="headerlink" title="useShareAppMessage"></a>useShareAppMessage</h4><p>分享的生命周期，<br>等同于 <strong>onShareAppMessage</strong></p>
<h4 id="useRouter"><a href="#useRouter" class="headerlink" title="useRouter"></a>useRouter</h4><p>获取路由信息。<br>等同于 <strong>getCurrentInstance().router</strong></p>
<h4 id="useReady"><a href="#useReady" class="headerlink" title="useReady"></a>useReady</h4><p>页面节点加载完毕的生命周期，<br>等同于 <strong>onReady</strong></p>
<h3 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h3><h4 id="useXXXX"><a href="#useXXXX" class="headerlink" title="useXXXX"></a>useXXXX</h4><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实，我自身对 Hook 的语法也是刚刚接触，<br>可能有些理解不是很深刻，也比较懵懂。<br>那么随着自身对这些 Hook 的理解，<br>我也会对这篇文章的内容不断更新。</p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>46.说点最近研究express的那点事</title>
    <url>/2024/03/05/46-%E8%AF%B4%E7%82%B9%E6%9C%80%E8%BF%91%E7%A0%94%E7%A9%B6express%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="只是开头"><a href="#只是开头" class="headerlink" title="只是开头"></a>只是开头</h3><p>服务器到手之后,<br>前端项目部署完,<br>就开始手痒痒想要研究研究后端接口咋实现的.<br>想起了 N 年前摆弄过的 express,<br>果断的开始折腾起来.</p>
<a id="more"></a>

<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>虽然说是用野路子搭建一个后端项目,<br>不过尽量还是模拟成平时在项目中应用的那种感觉.</p>
<ol>
<li>首先需要具备多环境</li>
</ol>
<ul>
<li>PROD 环境用以生产使用</li>
<li>UAT 环境用以开发使用</li>
</ul>
<ol start="2">
<li>安全性: 搞一套 JWT 身份认证</li>
</ol>
<ul>
<li>JWT（JSON Web Token）是一种在网络中以 JSON 格式安全地传输信息的令牌.</li>
<li>Token 令牌用于身份认证. 由于 HTTP 请求是无状态的, 所以需要通过 token 来获取每次请求的用户信息.</li>
</ul>
<p>token 可以通过 jsonwebtoken 三方库来生成,<br>后端对一个用户身份验证通过后,<br>会将这个用户非敏感的信息,<br>经过秘钥签名算法进行编码,<br>进而生成一个 token 并返回给客户端.</p>
<p>而用户在后续请求的时候,<br>需要携带这个 token,<br>服务器处理请求的时候,<br>可以通过携带的 token 经过秘钥签名算法下进行解码,<br>进而得知当前用户的身份信息.</p>
<ol start="3">
<li>安全性: 签名验证</li>
</ol>
<p>为了防止一些恶意抓包, 修改请求数据欺骗服务器的情况,<br>服务器和客户端要设计一套加密算法.<br>两边将相同的变量以某种固定的格式进行 md5 加密,<br>如果两边得出的结果相同即为合法请求,否则会认为是非法请求进行.</p>
<p>像是某些比较敏感的重要请求,<br>比如增加积分, 奖励等操作, 则需要请求 id 做重复校验.<br>即为同一个请求 id 只能操作一次,否则就会非法报错.</p>
<ol start="4">
<li>规范性: 遵循 Restful API 接口规范</li>
</ol>
<ul>
<li>路由携带版本号.</li>
</ul>
<blockquote>
<p>/xxx/v1/xxx/xxx<br>/xxx/v2/xxx/xxx</p>
</blockquote>
<ul>
<li>使用 http 状态码定义 api 执行结果.</li>
</ul>
<p>主要分为 5 类:</p>
<ul>
<li>信息响应(1xx)</li>
<li>成功响应(2xx)</li>
<li>重定向(3xx)</li>
<li>客户端错误(4xx)</li>
<li>服务器错误(5xx)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">状态码 code</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">成功</td>
</tr>
<tr>
<td align="center">301</td>
<td align="center">请求资源永久转移</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">请求资源临时转移</td>
</tr>
<tr>
<td align="center">400</td>
<td align="center">客户端请求语法错误</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">用户身份认证错误</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">无法找到请求资源</td>
</tr>
<tr>
<td align="center">405</td>
<td align="center">method 方法不匹配</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">服务器意料之外的错误</td>
</tr>
</tbody></table>
<ul>
<li>使用 method 对应不同的请求动作.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">请求方式 method</th>
<th align="center">请求说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="center">查询操作</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">新增操作</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">更新操作</td>
</tr>
<tr>
<td align="center">PATCH</td>
<td align="center">部分更新操作</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">删除操作</td>
</tr>
</tbody></table>
<ol start="5">
<li>规范性: 搞一个通用的可配置的必填参数校验</li>
</ol>
<p>每个接口暴露出来一个对象,<br>对象中将该接口所需的必传参数 key 暴露出来.</p>
<p>然后在接口的外层统一拦截器对其进行校验判断,<br>如果没有传入该字段, 即不会走入到业务逻辑中,<br>直接返回 400 报错.</p>
<ol start="6">
<li>规范性: 统一一个报错枚举表</li>
</ol>
<p>单独维护一个配置文件,<br>将所有报错枚举统计出来,<br>后续接口业务逻辑中的所有报错枚举,<br>都需要在这个表里取值.</p>
<ol start="7">
<li>规范性: 支持不同格式请求体/返回体</li>
</ol>
<ul>
<li><p>常规场景<br>json 格式</p>
</li>
<li><p>上传文件场景<br>支持 file 文件格式</p>
</li>
<li><p>AI 会话场景<br>stream 格式返回</p>
</li>
</ul>
<ol start="8">
<li>规范性: 跨域配置 CORS</li>
</ol>
<p>服务器端定义跨域请求规则.</p>
<ol start="9">
<li>链接数据库, 且支持事务回滚(未实现)</li>
</ol>
<p>数据库选型选择了 mongodb.<br>好处是在于接入方便, 容易扩展, 简单易上手.<br>缺点在于数据量到达一定量级之后性能会急剧下降.(估计也达不到)</p>
<p>事务回滚指的是:<br>即为当一个请求操作的时候,<br>需要后端服务器多个表进行读写.</p>
<p>在多个写入操作中如果其中一个报错,<br>那么之前操作过得所有记录都需要恢复.</p>
<p>选型的 mongodb 在 4.0 版本之后才支持事务,<br>而且想要支持事务回滚, mongodb 还需要配置副本集.<br>配置过程中各种花式报错,<br>裂开了…<br>研究好久没搞出来,先搁置吧…</p>
<ol start="9">
<li>缓存层(未实现)</li>
</ol>
<p>目前代码直接对数据库进行读写,<br>频繁的对数据库进行 I/O 操作肯定是影响性能.</p>
<p>由于目前体量较小,<br>业务也不复杂,<br>勉强跑着.</p>
<p>后续如果体量变大之后,<br>需要考虑搞一个缓存层, 如: Redis,<br>减少对数据库的直接操作.</p>
<ol start="10">
<li>伸缩性(未实现)</li>
</ol>
<p>这个说远了, 实在能力有限了,<br>真要是有一天发达了,<br>用户数量需要用到集群才能解决的时候,<br>要么就干脆直接托管云服务了,<br>要么就已经抱住了强力大腿了.</p>
<ol start="11">
<li>搞一个可视化接口文档</li>
</ol>
<ul>
<li>借助 express-swagger-generator 三方库来实现.</li>
</ul>
<p>在每个接口上,<br>这个库支持以注释的方式书写接口的 route/group/header/params 等信息,<br>那么在项目运行的时候,<br>就会自动生成出一套 swagger 在线接口文档.</p>
<p><a href="https://www.orz2.online/apiuat/smart/swagger">目前已经实现</a></p>
<p>同时这个在线接口文档也支持发起接口请求,<br>方便开发的时候调试.<br>(有的时候懒得特意再起 Postman)</p>
<ol start="12">
<li>实现自动生成 CURD 脚本(待实现)</li>
</ol>
<p>创建表之后, 自动生成对该表进行增删改查的 4 个常用接口.</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>现在已经初步能实现了一些小功能,<br>后面随着功能的增加,<br>业务需求的需要,<br>会慢慢继续完善自己的这个 express 项目.</p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>47.配置mongodb副本集的翻车笔记</title>
    <url>/2024/09/26/47-%E9%85%8D%E7%BD%AEmongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E7%9A%84%E7%BF%BB%E8%BD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="聊聊起源"><a href="#聊聊起源" class="headerlink" title="聊聊起源"></a>聊聊起源</h3><p>在自己练手的小玩具功能不断复杂之后,<br>开始出现一个请求需要操作多个表的场景.</p>
<p>面对这个情况,<br>考虑到如果操作一个数据库的时候失败报错, 那之前操作的还需要手动恢复,<br>感觉会给业务代码里面掺杂很多复杂逻辑.<br>不利于后续开发,</p>
<p>经过研究之后, 发现事务回滚机制正好试用这个场景,<br>那高低研究一波.</p>
<a id="more"></a>

<h3 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建会话</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="keyword">await</span> mongoose.startSession();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 开始会话</span></span><br><span class="line">  session.startTransaction();</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">  <span class="comment">// const resTry = await funTry?.();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交会话</span></span><br><span class="line">  <span class="keyword">await</span> session.commitTransaction();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resTry;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 会话报错终止, 该会话内操作开始回滚</span></span><br><span class="line">  session.abortTransaction();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do catch something...</span></span><br><span class="line">  <span class="comment">// const resCatch = await funCatch?.(error);</span></span><br><span class="line">  <span class="keyword">return</span> resCatch;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 会话结束</span></span><br><span class="line">  session.endSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码改造后测试了一下,<br>当抛出异常, 代码也执行了 <code>session.abortTransaction</code>,<br>不过之前写入数据库的数据并没有撤销.<br>经过查询资料之后发现,<br>mongodb 想要事务回滚必须要设置为副本集模式.</p>
<h3 id="配置改造"><a href="#配置改造" class="headerlink" title="配置改造"></a>配置改造</h3><p>登录服务器执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 创建一个名为 <span class="string">"mongodbnet"</span> 的 Docker 网络，可以将多个容器连接到同一个网络中，使它们能够相互通信。</span><br><span class="line">docker network create mongodbnet</span><br><span class="line"></span><br><span class="line">// 查看 Docker 中的所有网络</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line">// 创建 conf/mongod.keyfile （为副本集共用）</span><br><span class="line">openssl rand -base64 756 &gt; /usr/<span class="built_in">local</span>/mongo/conf/mongod.keyfile</span><br><span class="line"></span><br><span class="line">// 创建 conf/mongod.conf （为副本集共用）</span><br><span class="line">vim /usr/<span class="built_in">local</span>/mongo/conf/mongod.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">authorization: enabled</span><br><span class="line">keyFile: /conf/mongod.keyfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">replSetName: rs0</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">port: 27017</span><br><span class="line">bindIp: 127.0.0.1</span><br><span class="line"></span><br><span class="line">// 创建 mongod.conf.orig（为副本集共用）</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">authorization: enabled</span><br><span class="line">keyFile: /conf/mongod.keyfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">replSetName: rs0</span><br><span class="line"></span><br><span class="line">// 放开权限</span><br><span class="line">chmod 600 /usr/<span class="built_in">local</span>/mongo/conf/mongod.keyfile</span><br><span class="line"></span><br><span class="line">// 启动容器</span><br><span class="line">docker run \</span><br><span class="line">--name mongo1 \</span><br><span class="line">--net mongodbnet \</span><br><span class="line">-p 27001:27017 \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/mongod.conf.orig:/etc/mongod.conf.orig \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/conf/mongod.conf:/conf/mongod.conf \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/conf/mongod.keyfile:/conf/mongod.keyfile \</span><br><span class="line">-v /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime \</span><br><span class="line">-e MONGO_INITDB_ROOT_USERNAME=yourusername \</span><br><span class="line">-e MONGO_INITDB_ROOT_PASSWORD=yourpassword \</span><br><span class="line">-d --restart=always mongo:4.2 \</span><br><span class="line">--replSet rs0 \</span><br><span class="line">--auth</span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">--name mongo2 \</span><br><span class="line">--net mongodbnet \</span><br><span class="line">-p 27002:27017 \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/mongod.conf.orig:/etc/mongod.conf.orig \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/conf/mongod.conf:/conf/mongod.conf \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/conf/mongod.keyfile:/conf/mongod.keyfile \</span><br><span class="line">-v /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime \</span><br><span class="line">-e MONGO_INITDB_ROOT_USERNAME=yourusername \</span><br><span class="line">-e MONGO_INITDB_ROOT_PASSWORD=yourpassword \</span><br><span class="line">-d --restart=always mongo:4.2 \</span><br><span class="line">--replSet rs0 \</span><br><span class="line">--auth</span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">--name mongo3 \</span><br><span class="line">--net mongodbnet \</span><br><span class="line">-p 27003:27017 \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/mongod.conf.orig:/etc/mongod.conf.orig \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/conf/mongod.conf:/conf/mongod.conf \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/conf/mongod.keyfile:/conf/mongod.keyfile \</span><br><span class="line">-v /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime \</span><br><span class="line">-e MONGO_INITDB_ROOT_USERNAME=yourusername \</span><br><span class="line">-e MONGO_INITDB_ROOT_PASSWORD=yourpassword \</span><br><span class="line">-d --restart=always mongo:4.2 \</span><br><span class="line">--replSet rs0 \</span><br><span class="line">--auth</span><br><span class="line"></span><br><span class="line">// 考虑关闭三个 mongodb 容器，然后按照先开启主节点容器、再开启父节点容器的顺序启动。(选做)</span><br><span class="line">docker stop mongo3 mongo2 mongo1</span><br><span class="line"></span><br><span class="line">docker restart mongo1</span><br><span class="line">docker restart mongo2</span><br><span class="line">docker restart mongo3</span><br><span class="line"></span><br><span class="line">// 进入主 mongo 容器</span><br><span class="line">docker <span class="built_in">exec</span> -it mongo1 bash</span><br><span class="line"></span><br><span class="line">chmod 600 /conf/mongod.keyfile</span><br><span class="line"></span><br><span class="line">// 查看通用配置文件</span><br><span class="line">cat etc/mongod.conf.orig</span><br><span class="line"></span><br><span class="line">// 进入 mongo 数据库</span><br><span class="line">mongo -u yourusername -p yourpassword --authenticationDatabase admin</span><br><span class="line"></span><br><span class="line">// 初始化副本集</span><br><span class="line"></span><br><span class="line">&gt; rs.initiate()</span><br><span class="line">&gt; rs.initiate(&#123; \_id: <span class="string">"rs0"</span>, members: [ &#123; _id: 0, host: <span class="string">"mongo1:27017"</span> &#125;, &#123; _id: 1, host: <span class="string">"mongo2:27017"</span> &#125;, &#123; _id: 2, host: <span class="string">"mongo3:27017"</span> &#125; ]&#125;)</span><br><span class="line"></span><br><span class="line">rs0:PRIMARY&gt; rs.status()</span><br><span class="line">rs0:PRIMARY&gt; rs.isMaster()</span><br><span class="line"></span><br><span class="line">// 关联副本</span><br><span class="line">rs0:PRIMARY&gt; rs.add(<span class="string">"mongo2:27017"</span>)</span><br><span class="line">rs0:PRIMARY&gt; rs.add(<span class="string">"mongo3:27017"</span>)</span><br><span class="line"></span><br><span class="line">// ===== 备份操作 =====</span><br><span class="line">// 启动容器</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/conf/mongod.conf:/conf/mongod.conf \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/mongo/mongod.conf.orig:/etc/mongod.conf.orig \</span><br><span class="line">--keyFile /conf/mongod.keyfile \</span><br><span class="line">--config /conf/mongod.conf \</span><br><span class="line"></span><br><span class="line">// 矫正时区</span><br><span class="line">docker cp /usr/share/zoneinfo/Asia/Shanghai mongo1:/etc/localtime</span><br><span class="line">docker cp /usr/share/zoneinfo/Asia/Shanghai mongo2:/etc/localtime</span><br><span class="line">docker cp /usr/share/zoneinfo/Asia/Shanghai mongo3:/etc/localtime</span><br><span class="line"></span><br><span class="line">// 容器内操作配置</span><br><span class="line">mongo --config /conf/mongod.conf --keyFile /conf/mongod.keyfile --replSet rs0</span><br><span class="line"></span><br><span class="line">// 需要携带账号密码么？</span><br><span class="line">rs.add(<span class="string">"mongo2:27017"</span>, &#123; username: <span class="string">"yourusername"</span>, password: <span class="string">"yourpassword"</span>, authenticationDatabase: <span class="string">"admin"</span> &#125;)</span><br><span class="line">// =================</span><br></pre></td></tr></table></figure>

<p>库库一顿配置,<br>不好使…<br>裂开了,<br>后面再说吧</p>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>后面如果副本集配置好之后,<br>那么就需要将旧的数据库数据迁移到新的副本集数据库之中.<br>操作待学习…</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>事务回滚的优先级不是那么高,<br>先暂时搁置一波了,<br>太浪费时间了.<br>真在实际中遇到这种问题,<br>到时候再抱住运维大哥大腿好了.<br>那么再完善这个机制好了.</p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>48.浅聊一下最近研究github action些许感悟</title>
    <url>/2025/01/02/48-%E6%B5%85%E8%81%8A%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91%E7%A0%94%E7%A9%B6github-action%E4%BA%9B%E8%AE%B8%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<h3 id="聊聊起源"><a href="#聊聊起源" class="headerlink" title="聊聊起源"></a>聊聊起源</h3><p>最近自己在随便折腾项目的时候，发现自己每次都需要手动部署网站实在是太麻烦了，<br>每次都是一样的操作流程：本地构建、上传资源、重启服务…<br>这一系列重复性的工作着实让人头大。</p>
<p>随着项目越来越多，这种重复性工作更是增加了不少负担。<br>于是想着能不能将这些流程自动化起来，<br>一番调研后发现了 GitHub Actions 这个神器，<br>决定好好研究一番，解放双手。</p>
<a id="more"></a>

<h3 id="简单-workflows"><a href="#简单-workflows" class="headerlink" title="简单 workflows"></a>简单 workflows</h3><p>Actions 的工作流程文件（workflow）需要存放在项目的 <code>.github/workflows</code> 目录下，<br>使用 YAML 格式定义。一个最基础的 workflow 如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Basic</span> <span class="string">Workflow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> <span class="string">[</span> <span class="string">main</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">'16.x'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">project</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure>

<p>这个简单的 workflow 会在每次推送到 main 分支时触发，<br>执行检出代码、安装 Node.js、安装依赖和构建项目的步骤。<br>非常简单，但已经能够满足很多基础需求了。</p>
<p>在实践中，我发现这些简单的 workflow 能够帮我解决约 80% 的自动化需求，<br>比如自动运行测试、自动构建等。</p>
<h3 id="使用-secrets-的-workflows"><a href="#使用-secrets-的-workflows" class="headerlink" title="使用 secrets 的 workflows"></a>使用 secrets 的 workflows</h3><p>当需要在 workflow 中使用敏感信息（如服务器账号密码、API 密钥等）时，<br>直接在 workflow 文件中明文编写这些信息显然是不安全的。<br>这时候，GitHub 提供的 secrets 功能就派上用场了。</p>
<p>首先在项目的 Settings -&gt; Secrets and variables -&gt; Actions 中添加需要的密钥，<br>然后在 workflow 中通过 <code>secrets</code> 上下文来访问：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">    <span class="attr">with:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_SSH_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">/path/to/project</span></span><br><span class="line">        <span class="string">git</span> <span class="string">pull</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure>

<p>这样就能在不暴露敏感信息的情况下，<br>实现自动部署到服务器的功能，真的很方便。</p>
<h3 id="可以页面主动触发的-workflows"><a href="#可以页面主动触发的-workflows" class="headerlink" title="可以页面主动触发的 workflows"></a>可以页面主动触发的 workflows</h3><p>有时候，我们需要手动触发 workflow，而不是等待代码推送或其他事件。<br>GitHub Actions 提供了 <code>workflow_dispatch</code> 事件类型，允许从 GitHub 页面手动触发 workflow：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line">    <span class="attr">inputs:</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">'部署环境'</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">default:</span> <span class="string">'staging'</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">choice</span></span><br><span class="line">        <span class="attr">options:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">staging</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">production</span></span><br></pre></td></tr></table></figure>

<p>这样配置后，在 GitHub 仓库的 Actions 标签页中就能看到手动触发按钮，<br>还可以传入自定义参数，非常灵活。</p>
<p>我发现这个功能特别适合那些不需要频繁执行，<br>但偶尔需要手动触发的任务，比如将测试环境的代码部署到生产环境。</p>
<h3 id="封装公共-workflows"><a href="#封装公共-workflows" class="headerlink" title="封装公共 workflows"></a>封装公共 workflows</h3><p>随着使用的深入，我发现很多项目的 workflow 有大量相似之处。<br>为了避免重复编写，GitHub Actions 提供了复用机制：composite actions 和 reusable workflows。</p>
<ol>
<li>Composite Actions<br>将一组常用的步骤打包成一个可复用的 action：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .github/actions/build-and-test/action.yml</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">'Build and Test'</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'构建并测试项目'</span></span><br><span class="line"><span class="attr">runs:</span></span><br><span class="line">  <span class="attr">using:</span> <span class="string">"composite"</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">      <span class="attr">shell:</span> <span class="string">bash</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">tests</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">shell:</span> <span class="string">bash</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Reusable Workflows<br>创建可在多个仓库间共享的 workflow：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .github/workflows/reusable-build.yml</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Reusable</span> <span class="string">build</span> <span class="string">workflow</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">workflow_call:</span></span><br><span class="line">    <span class="attr">inputs:</span></span><br><span class="line">      <span class="attr">node-version:</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">default:</span> <span class="string">'16.x'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># ...build steps</span></span><br></pre></td></tr></table></figure>

<p>通过这种方式，我成功将多个项目中重复的 CI/CD 流程统一起来，<br>大大减少了维护成本，也保证了各项目间 CI/CD 实践的一致性。</p>
<h3 id="如何本地调试-workflows"><a href="#如何本地调试-workflows" class="headerlink" title="如何本地调试 workflows"></a>如何本地调试 workflows</h3><p>GitHub Actions 的一大痛点是无法在本地直接调试，<br>每次修改都需要提交到远程仓库才能看到效果，效率比较低。</p>
<p>经过一番探索，我找到了两种本地调试的方法：</p>
<ol>
<li>使用 <a href="https://github.com/nektos/act" target="_blank" rel="noopener">act</a> 工具<br>这是一个能在本地运行 GitHub Actions 的开源工具：<br>(个人尝试失败了, 还得本地安装 Docker, 安装镜像啥的, 电脑硬盘太小了, 只能算了.)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">brew install act</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在项目根目录运行</span></span><br><span class="line">act</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 GitHub Actions 的 step debug 日志<br>在仓库中添加 secret <code>ACTIONS_STEP_DEBUG</code> 并设为 <code>true</code>，<br>这样 workflow 运行时会输出更详细的日志，有助于排查问题。</li>
</ol>
<p>虽然这些方法无法完全替代远程运行，<br>但在开发阶段可以帮助我们快速发现并解决一些基本问题，<br>避免过多的远程测试提交。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>通过使用 GitHub Actions，我将很多原本需要手动操作的工作流程自动化了，<br>极大地提高了开发效率，也减少了人为操作带来的错误。</p>
<p>从最初的简单构建部署，tar直接拽到服务器上；到现在的跨仓库复用、条件执行、手动触发等高级用法，<br>GitHub Actions 为我提供了一个强大而又灵活的 CI/CD 工具。</p>
<p>当然，使用过程中也遇到了不少问题，比如运行时间限制、复杂工作流调试困难等，<br>但总体来说，投入产出比非常高，值得每一位开发者去学习和使用。</p>
<p>最后分享一个小技巧：GitHub Actions 的 marketplace 有大量现成的 actions，<br>很多常见需求都能找到对应的解决方案，不必重复造轮子。<br>比如部署到 GitHub Pages、发布 npm 包、发送通知等，都有对应的 actions 可以直接使用。</p>
]]></content>
      <tags>
        <tag>CI/CD</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>49.关于被Next.js强行洗脑的二三事</title>
    <url>/2025/02/15/49-%E5%85%B3%E4%BA%8E%E8%A2%ABNext-js%E5%BC%BA%E8%A1%8C%E6%B4%97%E8%84%91%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>前端时间，想用 React 重构一下我的工具官网，<br>正好看看 19 有啥新的黑科技，<br>结果官网直接把 Create React App 取缔了，<br>心中无限羊驼翻腾，这 React 是不想干了么，<br>定睛一看推荐使用框架使用(这 Next.js 绝对是给 React 塞钱了)，</p>
<p>作为一个习惯了传统 React SPA 开发的前端工程师，<br>我对这种”新潮”的开发方式充满了疑惑和不适应。<br>今天就来聊聊这强行被 Next.js 洗脑二三事。</p>
<a id="more"></a>

<h3 id="接触-Next-js"><a href="#接触-Next-js" class="headerlink" title="接触 Next.js"></a>接触 Next.js</h3><p>简单看了一下 Next.js 的文档，感觉自己又成为了一名初学者，<br>从 13 版本开始，App Router、Server Components、React Server Components…<br>这些概念仿佛一夜之间填满了我的技术雷达。</p>
<p>不过如果针对官网类型的业务，<br>我们的应用需要更好的首屏加载速度和搜索引擎优化，<br>传统的 SPA 应用确实已经无法满足需求。<br>选择使用 Next.js 也确实是一个很好的选择。( Next.js 也支持 SSG 模式)</p>
<p>一开始的感受是：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 心理活动</span></span><br><span class="line"><span class="string">"这不就是 React 加了点服务端功能吗？有什么了不起的..."</span></span><br><span class="line"><span class="string">"为什么我要把数据获取写在 getServerSideProps 里？直接在组件里用 useEffect 多好"</span></span><br><span class="line"><span class="string">"路由配置这么复杂，还不如 React Router 直观"</span></span><br></pre></td></tr></table></figure>

<p>但随着深入使用，我开始逐渐理解 Next.js 的设计理念和优势。</p>
<h3 id="App-Router-的冲击"><a href="#App-Router-的冲击" class="headerlink" title="App Router 的冲击"></a>App Router 的冲击</h3><p>Next.js 13 (目前已经是 15) 推出 App Router 后，我的认知再次被颠覆。</p>
<p>从 Pages Router 的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pages&#x2F;blog&#x2F;[slug].js</span><br><span class="line">export async function getServerSideProps(context) &#123;</span><br><span class="line">  const &#123; slug &#125; &#x3D; context.params;</span><br><span class="line">  const post &#x3D; await fetchPost(slug);</span><br><span class="line">  return &#123; props: &#123; post &#125; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function BlogPost(&#123; post &#125;) &#123;</span><br><span class="line">  return &lt;div&gt;&#123;post.title&#125;&lt;&#x2F;div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到 App Router 的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;blog&#x2F;[slug]&#x2F;page.tsx</span><br><span class="line">export default async function BlogPost(props: &#123;</span><br><span class="line">  children: React.ReactNode;</span><br><span class="line">  params: Promise&lt;&#123; locale: string &#125;&gt;;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  const post &#x3D; await fetchPost(params.slug);</span><br><span class="line">  return &lt;div&gt;&#123;post.title&#125;&lt;&#x2F;div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看起来更简洁了，但我一时无法接受组件函数居然可以是 async 的！<br>这打破了我对 React 组件的认知 —— 组件不是应该是纯函数吗？</p>
<p>更让我困惑的是 Server Components 和 Client Components 的区分：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">ServerComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fetchData(); <span class="comment">// 直接在组件中获取数据</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端组件</span></span><br><span class="line"><span class="string">'use client'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ClientComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这种混合使用的方式让我一开始很不适应，<br>但慢慢地，我发现这种模式确实能解决很多传统 React 应用的痛点。</p>
<h3 id="意外收获"><a href="#意外收获" class="headerlink" title="意外收获"></a>意外收获</h3><p>在经过几个项目的实践后，我发现 Next.js 带来了一些意想不到的好处：</p>
<ol>
<li><p><strong>代码组织更合理</strong><br>App Router 的文件系统路由让项目结构更加清晰，<br>相关的组件、样式、API 处理都可以放在同一个目录下。</p>
</li>
<li><p><strong>性能提升明显</strong><br>服务端渲染 + 自动静态优化 + 增量静态再生成，<br>这些技术组合起来，网站性能有了质的飞跃。<br>最直观的感受是 Lighthouse 分数从 70 多分蹭蹭往上涨。</p>
</li>
<li><p><strong>开发体验改善</strong><br>数据获取直接写在组件中，不再需要复杂的状态管理模式，<br>很多时候甚至不需要用到 Redux 或者 MobX。</p>
</li>
<li><p><strong>全栈开发更自然</strong><br>Next.js 的 API Routes 和数据获取功能，<br>让我这个前端开发者也能轻松处理后端逻辑，<br>不再需要单独搭建后端服务。</p>
</li>
</ol>
<h3 id="概念转变"><a href="#概念转变" class="headerlink" title="概念转变"></a>概念转变</h3><p>使用 Next.js 最大的改变是我的思维方式：</p>
<p>从”一切都在客户端处理”到”服务端能做的就交给服务端”。<br>这种转变不仅仅是技术层面的，更是对整个 Web 应用架构认知的提升。</p>
<p>我开始思考每段代码最合适的执行位置：</p>
<ul>
<li>数据获取？服务端更安全、更快</li>
<li>用户交互？客户端处理</li>
<li>敏感操作？服务端 API 封装</li>
<li>静态内容？构建时生成</li>
</ul>
<p>这种思考方式让我的应用架构更加合理，性能和用户体验也随之提升。</p>
<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><p>当然，学习过程中也踩了不少坑：</p>
<ol>
<li><p><strong>Server Components 限制多</strong><br>不能使用 useState、useEffect、浏览器 API 等，<br>这点刚开始很难适应，经常忘记给组件添加 ‘use client’ 指令。</p>
</li>
<li><p><strong>部署复杂度增加</strong><br>与单纯的静态网站相比，Next.js 应用需要 Node.js 环境或专门的服务，<br>部署和运维成本有所提高。</p>
</li>
<li><p><strong>调试体验变差</strong><br>服务端渲染的代码调试比客户端复杂，<br>报错提示只会提示水合错误，一开始真的是一头雾水。<br>有时候出了问题很难定位到具体原因。</p>
</li>
</ol>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>经过一段时间的摸索，我总结了一些个人觉得好用的实践：</p>
<ol>
<li><p><strong>合理划分 Server 和 Client 组件</strong><br>默认使用 Server Components，只在需要交互、钩子或浏览器 API 时才使用 Client Components。</p>
</li>
<li><p><strong>善用 React Cache</strong><br>使用 React Cache 可以在不同组件之间共享数据请求，减少重复请求。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cache &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getUser = cache(<span class="keyword">async</span> (id) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">`/api/user/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> res.json();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模块化 API 处理</strong><br>将 API 处理逻辑单独提取到服务函数中，方便在多个组件和路由处理程序中复用。</p>
</li>
<li><p><strong>混合渲染策略</strong><br>根据页面性质选择不同的渲染策略：静态内容用 Static Generation，<br>动态但不频繁更新的内容用 ISR，实时性要求高的用 SSR。</p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>回顾整个学习过程，我从最初的抵触到现在的接受甚至推崇，<br>这种转变让我意识到技术更新迭代永远是行业常态，<br>保持开放的心态去学习新事物非常重要。</p>
<p>Next.js 的思想确实”洗脑”了我，<br>改变了我对前端开发的认知和实践方式。<br>当然，它并不是万能的，对于简单的单页应用或纯静态网站来说，<br>Next.js 可能是”杀鸡用牛刀”。</p>
<p>选择合适的技术栈仍然是最重要的，<br>但不管怎样，Next.js 代表的全栈式 React 框架方向，<br>很可能是未来前端开发的主流趋势。<br>学会它，对技术视野的拓展和职业发展都会有所裨益。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://nextjs.org/docs" target="_blank" rel="noopener">1. Next.js</a></p>
<p><a href="https://next-intl.dev/docs/getting-started" target="_blank" rel="noopener">2. next-intl</a></p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>Next.js</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>50.菜鸡浅尝SEO踩坑小记</title>
    <url>/2025/03/28/50-%E8%8F%9C%E9%B8%A1%E6%B5%85%E5%B0%9DSEO%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>作为一名前端开发者，我日常工作主要专注于实现功能和优化体验，<br>对 SEO（搜索引擎优化）这块一直是知道个大概，但没有深入了解过。</p>
<p>最近公司新项目要求提高网站在搜索引擎中的排名，<br>于是这个任务就落到了我的头上，<br>从零开始学习 SEO，一路踩坑，积累了不少经验，<br>今天就来分享一下这段学习历程。</p>
<a id="more"></a>

<h3 id="SEO-基础概念"><a href="#SEO-基础概念" class="headerlink" title="SEO 基础概念"></a>SEO 基础概念</h3><p>在开始具体优化前，有必要了解一下 SEO 的基本概念。</p>
<p>SEO 即搜索引擎优化（Search Engine Optimization），<br>简单来说就是通过了解搜索引擎的工作原理，对网站进行调整和优化，<br>使其在搜索引擎中获得更好的排名，从而带来更多的自然流量。</p>
<p>SEO 主要分为两大类：</p>
<ol>
<li><p><strong>技术 SEO（Technical SEO）</strong>：<br>确保网站能被搜索引擎正确抓取和索引，包括网站结构、加载速度、移动适配等。</p>
</li>
<li><p><strong>内容 SEO（Content SEO）</strong>：<br>优化网站内容以匹配用户搜索意图，包括关键词研究、内容质量、内链外链等。</p>
</li>
</ol>
<h3 id="技术-SEO-踩坑记录"><a href="#技术-SEO-踩坑记录" class="headerlink" title="技术 SEO 踩坑记录"></a>技术 SEO 踩坑记录</h3><h4 id="1-网站爬虫可访问性"><a href="#1-网站爬虫可访问性" class="headerlink" title="1. 网站爬虫可访问性"></a>1. 网站爬虫可访问性</h4><p>一开始我天真地认为只要网站能正常访问，搜索引擎就能正常抓取。<br>然而实际情况却不是这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是我曾经写的代码，导致搜索引擎无法抓取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"noindex, nofollow"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码直接告诉搜索引擎不要索引我的网页，也不要跟踪页面上的链接。<br>这段代码是从一个旧项目中复制过来的，我完全没注意到它的存在！</p>
<p>还有一次，我们的网站使用了大量 JavaScript 动态加载内容，<br>结果 Google 无法正确抓取这些动态加载的内容，导致索引不完整。</p>
<p><strong>解决方法</strong>：</p>
<ol>
<li>移除了错误的 robots 元标签</li>
<li>对重要页面实施服务端渲染或预渲染</li>
<li>创建并提交了详细的站点地图（sitemap.xml）</li>
<li>检查并优化了 robots.txt 文件</li>
</ol>
<h4 id="2-页面加载速度"><a href="#2-页面加载速度" class="headerlink" title="2. 页面加载速度"></a>2. 页面加载速度</h4><p>我一直知道网站速度对用户体验很重要，但没想到它对 SEO 的影响也这么大。</p>
<p>做完第一版做完之后，用 devtool 的 Lighthouse 测了一下，分数直接红色叹号</p>
<p>主要问题是：</p>
<ul>
<li>图片没有优化（格式随意、原图太大、没有懒加载）</li>
<li>button 标签没有无障碍提示</li>
<li>JavaScript 文件阻塞渲染</li>
<li>没有使用浏览器缓存</li>
<li>服务器响应时间过长</li>
<li>页面由于使用指定字体，字体文件会跳动</li>
</ul>
<p><strong>解决方法</strong>：</p>
<ol>
<li>图片压缩、转换成 WebP 格式、实现懒加载</li>
<li>button 等可操作标签增加 aria-label 属性</li>
<li>拆分打包 JavaScript，实现代码 chunk 分割</li>
<li>配置合理的缓存策略</li>
<li>使用 CDN 加速资源</li>
<li>字体文件预加载</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 图片优化示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"small-placeholder.jpg"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-src</span>=<span class="string">"actual-image.jpg"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">loading</span>=<span class="string">"lazy"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">"详细的描述文字"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 批量处理图片的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> lazyImages = <span class="built_in">document</span>.querySelectorAll(<span class="string">"img[data-src]"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      entries.forEach(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (entry.isIntersecting) &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">const</span> img = entry.target;</span></span><br><span class="line">          img.src = img.dataset.src;</span><br><span class="line">          observer.unobserve(img);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    lazyImages.forEach(<span class="function">(<span class="params">img</span>) =&gt;</span> observer.observe(img));</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-移动适配"><a href="#3-移动适配" class="headerlink" title="3. 移动适配"></a>3. 移动适配</h4><p>现在 Google 使用移动优先索引，这意味着它主要使用网站的移动版本来确定排名。</p>
<p>检查我们的网站，发现移动端存在严重问题：</p>
<ul>
<li>文字太小，用户需要捏放才能阅读</li>
<li>点击目标（按钮等）太小且过于紧凑</li>
<li>内容宽度没有适配屏幕，需要水平滚动</li>
</ul>
<p><strong>解决方法</strong>：</p>
<ol>
<li>使用响应式设计，确保所有设备都有良好体验</li>
<li>增加触摸目标尺寸，提高可点击区域</li>
<li>优先显示移动端重要内容</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 确保触摸目标足够大 */</span></span><br><span class="line"><span class="selector-class">.button</span>,</span><br><span class="line"><span class="selector-class">.link</span>,</span><br><span class="line"><span class="selector-class">.nav-item</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用媒体查询适配不同屏幕 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none; <span class="comment">/* 在小屏幕上隐藏不重要内容 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.main-content</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="comment">/* 确保文字大小合适 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内容-SEO-踩坑记录"><a href="#内容-SEO-踩坑记录" class="headerlink" title="内容 SEO 踩坑记录"></a>内容 SEO 踩坑记录</h3><h4 id="1-关键词研究与使用"><a href="#1-关键词研究与使用" class="headerlink" title="1. 关键词研究与使用"></a>1. 关键词研究与使用</h4><p>一开始，我对关键词的理解非常浅显：</p>
<blockquote>
<p>“我想排名什么词，就在页面上多写几次这个词就好了”</p>
</blockquote>
<p>这种做法不仅没效果，还可能被视为关键词堆砌，反而降低排名。</p>
<p><strong>解决方法</strong>：</p>
<ol>
<li>使用专业工具（如 Google Keyword Planner、SEMrush）进行关键词研究</li>
<li>注重长尾关键词（更具体、竞争更少的词组）</li>
<li>关键词自然融入内容，注意语义相关性</li>
<li>重要关键词合理出现在标题（H1）、副标题、URL、元描述等位置</li>
</ol>
<h4 id="2-内容质量与结构"><a href="#2-内容质量与结构" class="headerlink" title="2. 内容质量与结构"></a>2. 内容质量与结构</h4><p>我们最初的内容存在几个问题：</p>
<ul>
<li>文章结构混乱，没有清晰的标题层级</li>
<li>段落冗长，不易阅读</li>
<li>缺乏有价值的原创内容</li>
<li>没有使用富媒体（图片、视频等）增强内容</li>
</ul>
<p><strong>解决方法</strong>：</p>
<ol>
<li>使用正确的 HTML 语义化标签，建立清晰的标题层级（H1、H2、H3…）</li>
<li>分割长段落，增加可读性</li>
<li>创建有深度、能解决用户问题的内容</li>
<li>添加相关的图片、视频、表格等多媒体元素</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 优化前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>如何优化网站速度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  网站速度很重要。可以提高用户体验，减少跳出率，增加转化率。下面介绍几种提高网站速度的方法...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 优化后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>如何优化网站速度：提升用户体验的实用指南<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>网站速度直接影响用户体验，数据显示，加载时间每增加1秒，转化率可能下降7%。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>为什么网站速度对SEO至关重要<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Google官方确认，页面加载速度是排名因素之一。慢速网站不仅会降低用户满意度，还会影响您的搜索排名。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>提升网站速度的5个实用技巧<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>1. 优化图片<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>大尺寸图片是影响加载速度的主要因素之一。通过以下方法优化图片：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>压缩图片大小<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>使用现代图片格式如WebP<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>实现懒加载<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-meta-标签书写"><a href="#3-meta-标签书写" class="headerlink" title="3. meta 标签书写"></a>3. meta 标签书写</h4><p>在优化初期，我简单地添加了标题和描述元标签，却忽略了它们的重要性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 初期的简单设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>我的网站 - 首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"这是一个关于XXX的网站"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>后来通过研究，发现 meta 标签在 SEO 中扮演着关键角色，影响着搜索结果的展示和点击率。</p>
<p><strong>元标签优化</strong>：</p>
<ol>
<li><strong>标题标签（Title Tag）</strong>：<ul>
<li>每个页面使用独特的标题，包含主要关键词</li>
<li>控制长度在 50-60 个字符内，避免截断</li>
<li>品牌名放在末尾，重要关键词放在前面</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 优化后的标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网站速度优化指南：提升用户体验与SEO排名 | 品牌名<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>描述元标签（Meta Description）</strong>：<ul>
<li>包含核心关键词，准确概括页面内容</li>
<li>添加行动号召（CTA），吸引用户点击</li>
<li>控制在 150-160 个字符内</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 优化后的描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"description"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"通过本指南学习5个网站速度优化技巧，包括图片压缩、代码分割等方法。提升加载速度可显著改善用户体验和SEO排名。立即了解如何加速您的网站！"</span> </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>规范标签（Canonical Tag）</strong>：<ul>
<li>解决内容重复问题，告诉搜索引擎哪个URL是首选版本</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"canonical"</span> <span class="attr">href</span>=<span class="string">"https://example.com/post/website-speed-optimization"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>国际化相关标签</strong>：</p>
<p>这部分是我们完全忽略的。对于多语言网站，正确的语言标记至关重要：</p>
<ol>
<li><strong>声明页面语言</strong>：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简体中文页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 英文页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en-US"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>提供语言替代版本</strong>：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告诉搜索引擎页面的其他语言版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">hreflang</span>=<span class="string">"en-US"</span> <span class="attr">href</span>=<span class="string">"https://example.com/en/page"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">hreflang</span>=<span class="string">"zh-CN"</span> <span class="attr">href</span>=<span class="string">"https://example.com/zh/page"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">hreflang</span>=<span class="string">"x-default"</span> <span class="attr">href</span>=<span class="string">"https://example.com/"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Open Graph 与社交分享优化</strong>：</p>
<p>社交媒体分享也是流量来源，但我们之前完全没考虑这点。添加 Open Graph 协议标签后，分享效果大幅提升：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基础 Open Graph 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:title"</span> <span class="attr">content</span>=<span class="string">"网站速度优化完全指南"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:description"</span> <span class="attr">content</span>=<span class="string">"学习如何提升网站加载速度，改善用户体验和SEO排名"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:image"</span> <span class="attr">content</span>=<span class="string">"https://example.com/images/speed-optimization.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:url"</span> <span class="attr">content</span>=<span class="string">"https://example.com/post/website-speed-optimization"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:type"</span> <span class="attr">content</span>=<span class="string">"article"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:site_name"</span> <span class="attr">content</span>=<span class="string">"技术博客"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Twitter 卡片标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"twitter:card"</span> <span class="attr">content</span>=<span class="string">"summary_large_image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"twitter:title"</span> <span class="attr">content</span>=<span class="string">"网站速度优化完全指南"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"twitter:description"</span> <span class="attr">content</span>=<span class="string">"学习如何提升网站加载速度，改善用户体验和SEO排名"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"twitter:image"</span> <span class="attr">content</span>=<span class="string">"https://example.com/images/speed-optimization.jpg"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>其他重要 meta 标签</strong>：</p>
<ol>
<li><strong>视口设置</strong>：确保在移动设备上正确显示</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>机器人控制</strong>：精细控制搜索引擎行为</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 允许索引并跟踪链接（默认行为） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index, follow"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 特定页面不希望被索引（如后台页面） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"noindex, nofollow"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>页面刷新或重定向</strong>：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 5秒后重定向到新页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"5;url=https://example.com/new-page"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>完善 meta 标签后，我们不仅在搜索结果中展示更吸引人，社交分享效果也大幅提升，点击率比之前提高了约 25%。</p>
<p><strong>踩坑教训</strong>：meta 标签看似简单，却是 SEO 的重要基石，每一个页面都应该有精心优化的元标签设置。</p>
<h4 id="4-内链与外链"><a href="#4-内链与外链" class="headerlink" title="4. 内链与外链"></a>4. 内链与外链</h4><p>链接策略是我们之前完全忽视的一个方面。内链可以帮助搜索引擎理解网站结构和页面关系，外链则是投票机制，表明其他网站对我们内容的认可。</p>
<p><strong>解决方法</strong>：</p>
<ol>
<li>建立合理的内链结构，重要页面获得更多内链</li>
<li>使用描述性锚文本（而不是”点击这里”）</li>
<li>确保重要页面距离首页点击次数不超过 3 次</li>
<li>尝试获取高质量相关网站的反向链接</li>
</ol>
<h3 id="度量与分析"><a href="#度量与分析" class="headerlink" title="度量与分析"></a>度量与分析</h3><p>仅仅实施优化是不够的，我们需要测量效果并持续改进。</p>
<p>一开始，我们没有设置正确的跟踪机制，无法评估优化效果。</p>
<p><strong>解决方法</strong>：</p>
<ol>
<li>正确配置 Google Analytics 和 Google Search Console</li>
<li>定期监控关键指标：<ul>
<li>搜索排名变化</li>
<li>自然流量趋势</li>
<li>页面加载速度</li>
<li>跳出率和停留时间</li>
<li>转化率</li>
</ul>
</li>
</ol>
<p>通过这些数据，我们能够识别问题并进行针对性优化。</p>
<h3 id="踩坑教训总结"><a href="#踩坑教训总结" class="headerlink" title="踩坑教训总结"></a>踩坑教训总结</h3><ol>
<li><p><strong>不要过度优化</strong><br>过度优化（如关键词堆砌）可能导致搜索引擎惩罚。SEO 应该是自然的，以用户为中心。</p>
</li>
<li><p><strong>技术与内容并重</strong><br>技术 SEO 确保搜索引擎能抓取和理解网站，内容 SEO 确保内容有价值并符合用户需求。两者缺一不可。</p>
</li>
<li><p><strong>SEO 是一场马拉松，不是短跑</strong><br>不要期望立即见效，SEO 是长期战略，需要持续投入和优化。</p>
</li>
<li><p><strong>移动端优先</strong><br>随着移动搜索占比越来越高，移动端体验已经成为 SEO 的核心。</p>
</li>
<li><p><strong>使用正确的工具</strong><br>有很多优秀的 SEO 工具可以帮助分析和优化，如 Screaming Frog、Ahrefs、SEMrush 等。</p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>通过这次 SEO 优化实践，我不仅学到了许多 SEO 知识，更重要的是改变了思维方式：</p>
<p>从单纯考虑”如何实现功能”转变为”如何实现对用户和搜索引擎都友好的功能”。</p>
<p>虽然我还是 SEO 领域的”菜鸡”，但这次经历让我明白，SEO 不是什么神秘的技术，而是一套系统的方法论，通过不断学习和实践，人人都能掌握。</p>
<p>最后，分享一句曾经看到过的话：</p>
<blockquote>
<p>“优化网站不仅是为了搜索引擎，更是为了用户。当你真正以用户为中心设计和开发网站时，SEO 自然会水到渠成。”</p>
</blockquote>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://cloud.tencent.com/developer/inventory/21006/article/1937182" target="_blank" rel="noopener">1. Website SEO optimization</a></p>
<p><a href="https://pagespeed.web.dev/" target="_blank" rel="noopener">2. Google PageSpeed Insights</a></p>
<p><a href="https://search.google.com/search-console" target="_blank" rel="noopener">3. Google search console</a></p>
<p><a href="https://analytics.google.com/analytics/web/provision/?hl=zh-cn#/provision" target="_blank" rel="noopener">4. Google Analytics</a></p>
<p><a href="https://www.xml-sitemaps.com/validate-xml-sitemap.html" target="_blank" rel="noopener">5. Validate xml sitemap</a></p>
]]></content>
      <tags>
        <tag>SEO</tag>
        <tag>前端优化</tag>
      </tags>
  </entry>
</search>
