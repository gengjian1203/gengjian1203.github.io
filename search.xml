<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.欢迎来到我的博客</title>
    <url>/2020/06/15/1-%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><p>时光如梭，感觉随着岁数增大，就开始想要回忆。<br>从大学最开始学习的turbo C，<br>到后来用的VC 6.0，再到后来visio studio。<br>从课程设计写的MFC，用过cocos引擎，玩过原生APP开发，<br>到后来进了公司去做脚本开发，寻基址，读内存，模拟交互。<br>再到后来被正规军收编在Ubuntu的Qt上做起了C++服务器开发。<br>直到现在做起来主攻微信小程序的前端开发。<br>这一路感觉又坎坷，又曲折。<br>有时候真的很迷惑，自己东一下西一下，<br>最后到底收获了什么。<br>都说没有目标的努力，都是在耍流氓。<br>没想到接近而立之年，竟然一直都是在耍流氓。<br>都说，<br>“种一棵树最好的时间，是十年前，其次就是现在。”<br>恩，买房也是。<br>好吧，古人云，知耻而后勇，<br>既然十年前不曾努力，那就从现在开始。<br>更新频率不用太快，不过我希望我能一直坚持下去！</p>
<a id="more"></a>

<h3 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h3><p>在很久之前，在同学小虎的安利下，<br>曾经布置过一次博客，不过那个博客基本都用来秀美食了。<br>最近心血来潮，觉得应该每隔一段时间，<br>应该复盘一下自身的技术栈，<br>不仅是技术的积累，<br>也能在以后遇到同样问题的时候，也能及时找到解决方法。<br>所以，轻车熟路之下，<br>重新有搭建了个纯技术的博客。<br>这次还是用熟悉的hexo来搭建，<br>不过新尝试了 Travis CI 来做持续集成，<br>以及使用了好评超高的 Next 来做主题。</p>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>因为hexo的源码，和发布代码是不一样的。<br>而建立两个项目，每次push两次，又显得特别的别扭。<br>所以为了想要同时保留两份代码，在网上找到了解决方案。<br>使用 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 持续集成。<br>大致的思路是这样。<br>github的page功能，之能应用在master主分支上。<br>那么master就用来存放发布后的代码。<br>我们在项目中另外建立个hexo-source分支，去存放我们编写时候的源码。<br>而我们每次只需要push到hexo-source分支上去，<br>然后通过持续集成，项目编译之后，在把发布代码push到master上去，<br>这样就完成了提交一次代码，github能存放两套代码的功能。  </p>
<p>而Travis CI直接通过github账号登录即可，<br>然后再github中授权Travis CI访问自己的项目。<br>不知道是不是自身网速的原因，<br>感觉每次访问Travis CI和github都会很卡。<br>耐着性子一点点登录，授权之后，<br>在项目中新增允许操作的Key，然后再Travis CI配置好Key值即可。  </p>
<p>具体的操作可以参考相关成熟的<a href="https://www.jianshu.com/p/5691815b81b6" target="_blank" rel="noopener">技术文章</a>。  </p>
<p>.travis.yml配置文件可参照如下：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># S: Build Lifecycle</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># before_script:</span></span><br><span class="line"><span class="comment">#  - npm install -g gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">  <span class="comment"># - gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"gengjian1203"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"gengjian1203@foxmail.com"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">"Update docs"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="string">master:master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># E: Build LifeCycle</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo-source</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"> <span class="attr">global:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/gengjian1203/gengjian1203.github.io</span></span><br></pre></td></tr></table></figure>

<h3 id="关于主题"><a href="#关于主题" class="headerlink" title="关于主题"></a>关于主题</h3><p>主题也是前后折腾了好多次。<br>从自带的landscape，到之前用过的yilia、cards，<br>直到现在用的<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a>。<br>确实不愧是Star最多的主题，也一直更新了下来。<br>虽然配置项比较多，不过用起来确实很舒爽。<br>比如几个常用的配置：  </p>
<ol>
<li>Next的子主题<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span> <span class="comment"># Muse Mist Pisces</span></span><br></pre></td></tr></table></figure></li>
<li>菜单设置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span> <span class="comment"># 首页</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span> <span class="comment"># 标签页</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/projects</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span>  <span class="comment"># 套用分类的功能，直接跳转到分类的子文件夹</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span> <span class="comment"># 关于</span></span><br></pre></td></tr></table></figure></li>
<li>菜单标识<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span> <span class="comment"># 菜单现实图标</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span> <span class="comment"># 显示内容的数量</span></span><br></pre></td></tr></table></figure></li>
<li>头像配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/head.jpg</span> <span class="comment"># 头像url</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span> <span class="comment"># 头像圆角</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span> <span class="comment"># 鼠标略过头像旋转</span></span><br></pre></td></tr></table></figure></li>
<li>外链配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span> <span class="comment"># Github链接</span></span><br><span class="line"><span class="attr">E-Mail:</span> <span class="string">mailto:yourname@qq.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span> <span class="comment"># 邮箱链接</span></span><br></pre></td></tr></table></figure></li>
<li>标签字号设置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tagcloud:</span></span><br><span class="line">  <span class="attr">min:</span> <span class="number">18</span> <span class="comment"># 标签最小字号</span></span><br><span class="line">  <span class="attr">max:</span> <span class="number">18</span> <span class="comment"># 标签最大字号</span></span><br><span class="line">  <span class="comment"># 话说Next主题没有抽出来颜色的变量，如果想要修改，就要改Next的源码，直接搜索tagcloud就能找得到对应CSS样式。</span></span><br></pre></td></tr></table></figure></li>
<li>评论配置<br>使用的是Valine，需要注册国内后端云服务提供商 LeanCloud 的账号。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开启</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">xxxxxxxxxx</span> <span class="comment"># LeanCloud 应用 appid</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">xxxxxxxxxx</span> <span class="comment"># LeanCloud 应用 appkey</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">随便说点什么吧~</span> <span class="comment"># 评论栏默认文字</span></span><br><span class="line">  <span class="attr">meta:</span> <span class="string">[nick,</span> <span class="string">mail,</span> <span class="string">link]</span> <span class="comment"># 客户提交的抬头信息</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># 评论每页条数</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-cn</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br></pre></td></tr></table></figure></li>
<li>本地搜索<br>采用的是hexo-generator-search。通过npm安装。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
将主题的配置项置为true。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实首页加载还是个问题，<br>第一次打开的时候会很慢，非常不好的体验。<br>不知道是不是受限于github的带宽限制，<br>有时候打开github都会很卡。<br>准备研究一下Travis CI如何搭配gulp去使用，<br>看看压缩代码之后，能不能让首屏加载速度有所提升。  </p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Travis CI</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>10.关于小程序中安卓与iOS的兼容适配坑</title>
    <url>/2020/07/10/10-%E5%85%B3%E4%BA%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%AE%89%E5%8D%93%E4%B8%8EiOS%E7%9A%84%E5%85%BC%E5%AE%B9%E5%9D%91/</url>
    <content><![CDATA[<h3 id="小程序兼容适配"><a href="#小程序兼容适配" class="headerlink" title="小程序兼容适配"></a>小程序兼容适配</h3><p>机型适配，安卓与iOS系统的兼容，<br>是做前端永恒不变的话题。<br>现在随着终端设备的五花八门，<br>系统繁杂，尺寸比各式各样，<br>导致前端的适配工作就是一个永远也填不完的神坑。<br>随即新建了这个文章，<br>用来记录一下自己踩过的兼容适配坑。</p>
<a id="more"></a>

<h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><h4 id="小程序中右滑返回"><a href="#小程序中右滑返回" class="headerlink" title="小程序中右滑返回"></a>小程序中右滑返回</h4><p>可能由于随着手机屏幕过大，<br>在返回交互上，手指够不到左上角的返回键，<br>新增了右滑返回的交互。<br>设计的初衷是好的，不过坑惨了前端开发人员。<br><a href="https://developers.weixin.qq.com/community/develop/doc/000868190489286620a8b27f156c01?highLine=disableSwipeBack" target="_blank" rel="noopener">“右滑手势返回”能力调整</a><br>微信7.0.5客户端版本之后，页面配置中的 <strong>disableSwipeBack</strong> 属性将不再生效。<br>同时也没有api能获取到右划返回的回调。  </p>
<p>目前能够想到的办法：  </p>
<ul>
<li>通过产品交互来回避这个返回坑。  </li>
<li>通过检测点击屏幕左边边缘，向右滑动这个动作来捕捉这个事件。（但是无法阻止返回上一页面的交互）  </li>
</ul>
<h4 id="Textarea标签"><a href="#Textarea标签" class="headerlink" title="Textarea标签"></a>Textarea标签</h4><p>关于输入表单，多行文本一般会使用Textarea组件。<br>这个时候在样式上，就有文本对齐的坑。<br>安卓机型：没有默认内边距，可以正常显示。<br>iOS机型：会有默认的padding偏移，且无法置0。<br>虽然在微信小程序官方文档中提到了，<br>基础库版本2.10.0以上，<br>新增disable-default-padding属性可以去掉iOS下的默认内边距。<br>不过实测之后，发现并没有用。  </p>
<p>像是vant这样的ui组件库，<br>对Textarea封装的Field组件，<br>在源码上是对ios机型上增加margin-top: -9rpx;样式<br>只能说是尽量抹除机型的差距。</p>
<h4 id="长机型的底部安全距离预留"><a href="#长机型的底部安全距离预留" class="headerlink" title="长机型的底部安全距离预留"></a>长机型的底部安全距离预留</h4><p>类似iphoneX长机型将样式填满屏幕的时候会有：  </p>
<ul>
<li>底部圆边被裁掉样式  </li>
<li>底部黑色长条遮挡样式  </li>
<li>误触发Home Indicator事件  </li>
</ul>
<p>这个时候就需要给底部留出安全的距离。<br>可以使用该样式来处理。  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.safe-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom); <span class="comment">/*兼容 IOS&lt;11.2*/</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);      <span class="comment">/*兼容 IOS&gt;11.2*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这个变量是iOS系统内核提供的，<br>安卓和开发者工具上用的chromium内核没有这个变量，<br>导致这个样式只支持iOS系统，对安卓系统还需要单独处理。  </p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>未完待续，随时新坑。  </p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>机型兼容适配</tag>
      </tags>
  </entry>
  <entry>
    <title>11.在项目中适配模式的使用</title>
    <url>/2020/07/13/11-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%80%82%E9%85%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h3><p>项目最近在用Taro重构，<br>在书写代码方面要求比较严格，<br>正好在跟老大调侃，<br>他偶尔看到我一筐switch…case…<br>给我指了指，<br>让我改用适配模式做一做。<br>本来项目任务都已经很紧了，<br>突然代码实现业务方式的改变，<br>让我有点猝不及防。<br>说实话本来是有点抗拒的，毕竟已经写了很多了，<br>不过后来琢磨了一下，产品的逻辑着实是乱的一批，<br>现在多写点代码，为了以后增改逻辑的时候，能少点坑，<br>看样子用上适配模式，也不失为一个好办法。  </p>
<a id="more"></a>

<h3 id="试用场景"><a href="#试用场景" class="headerlink" title="试用场景"></a>试用场景</h3><p>“适配模式”是比较常用的设计模式之一，<br>核心的概念是，<br>将若干个互不兼容的类，使他们能放到一起去工作。<br>目前的业务场景是这样的：<br>在设置权限模块中，根据设置不同权限类型，<br>对页面有不同的渲染，同时请求不同的数据。  </p>
<p>按照我平时的做法，都是会把几个权限，<br>每种权限分别抽象成一个标志字符，<br>另外将处理方式封成一个函数，<br>通过传入这个标志字符，来得出渲染结果以及所需的数据。  </p>
<p>如果是比较规规矩矩的交互，我的方法还是比较快捷的。<br>可是这次实在是每种权限的渲染差异很大，<br>有的是点一项勾选一个，<br>有的是点一项勾选两个，<br>有的是点一项收起/展示另外两项，<br>很难用一个通用的逻辑去解析这种交互。  </p>
<p>所以干脆写的透彻些，<br>用一个适配器，大大方方的去解决这个问题。<br>把每种权限，用一个类去清清爽爽的处理，<br>这样可以通过类实现物理隔离，不会有牵一发动全身的情况。<br>而且在以后维护的时候，只针对对应的类去修改就好。<br>代码量虽然会多，不过减少了维护成本。  </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象出来的父类</span></span><br><span class="line"><span class="keyword">interface</span> IPermissionAdaptor &#123;</span><br><span class="line">  support: <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">Boolean</span>;     <span class="comment">// 判断是否用该适配器</span></span><br><span class="line">  resolve: <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;;  <span class="comment">// 使用该适配器的逻辑处理方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  IPermissionAdaptor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AAAAA 类型权限</span></span><br><span class="line"><span class="keyword">class</span> NoticeAAAAAdaptor <span class="keyword">implements</span> IPermissionAdaptor&#123;</span><br><span class="line">  support = <span class="function">(<span class="params">objModuleItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> objModuleItem.type === <span class="string">'AAAA'</span></span><br><span class="line">  &#125;</span><br><span class="line">  resolve = <span class="function">(<span class="params">objModuleItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arrResult = []</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> arrResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BBBBB 类型权限</span></span><br><span class="line"><span class="keyword">class</span> NoticeBBBBBdaptor <span class="keyword">implements</span> IPermissionAdaptor&#123;</span><br><span class="line">  support = <span class="function">(<span class="params">objModuleItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> objModuleItem.type === <span class="string">'BBBBBB'</span></span><br><span class="line">  &#125;</span><br><span class="line">  resolve = <span class="function">(<span class="params">objModuleItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arrResult = []</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> arrResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 待遍历类的数组，如果以后权限多了，可以再次拓展</span></span><br><span class="line"><span class="keyword">const</span> ModulePermissionAdaptors = [</span><br><span class="line">  <span class="keyword">new</span> NoticeAAAAAdaptor(),</span><br><span class="line">  <span class="keyword">new</span> NoticeBBBBBdaptor(),</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AdaptorInvoker = &#123;</span><br><span class="line">  apply: <span class="function">(<span class="params">objModuleItem: PermissionResult</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arrResult = [];</span><br><span class="line">    <span class="comment">// 循环遍历，符合条件的适配器</span></span><br><span class="line">    <span class="comment">// 找到合适的就调用该适配器的逻辑实现方法，得到结果后，终止循环</span></span><br><span class="line">    ModulePermissionAdaptors.every(<span class="function">(<span class="params">adaptor</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (adaptor.support(objModuleItem)) &#123;</span><br><span class="line">        arrResult = adaptor.resolve(objModuleItem)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arrResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AdaptorInvoker;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="keyword">const</span> arrResult = PermissionViewAdaptor.apply(objModuleItem)</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>草草看来，<br>如果使用适配器模式的话，<br>代码量绝对是暴增，<br>但是这种写法很适合复杂的逻辑。  </p>
<p>面向过程的写法确实很快，<br>而且代码量也不会看起来这么多。<br>可是，思路无法做到这么清晰，  </p>
<p>以维护的角度来说，<br>如果两个月后找人再来维护这段代码。<br>面向过程那个面条式的逻辑，绝对会让你捋上半天。<br>说不定增加个功能，还得波及到其他的东西。<br>而这个适配器模式，让人很清除要在哪里修改，<br>也不会有该一处，波及其他逻辑的风险。  </p>
<p>另外，我想说的是，有时候设计模式该用就得大胆去用，<br>多用才能对这个模式能有更深的理解。<br>多多利用公司重构代码的机会，<br>锻炼一下自身的架构思想。  </p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>12.关于小程序开发的一些杂谈</title>
    <url>/2020/08/01/12-%E5%85%B3%E4%BA%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<h3 id="书写背景"><a href="#书写背景" class="headerlink" title="书写背景"></a>书写背景</h3><p>从接触到开发小程序，<br>也有一段时间了。<br>想新建一个帖子，<br>借此总结复盘一下自己踩过的坑，<br>和含泪背锅的经历。</p>
<a id="more"></a>

<h3 id="背锅标签"><a href="#背锅标签" class="headerlink" title="背锅标签"></a>背锅标签</h3><ol>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/0006648cb5cd98d8efa9f2be15b000" target="_blank" rel="noopener">wx.previewImage 不能禁用用户保存图片</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000e2af7f08bc81a3a4738b0d59400?highLine=10003" target="_blank" rel="noopener">ios 播放音频偶尔会出现错误</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000e06415e8080732868e776f56000" target="_blank" rel="noopener">UploadTask.onProgressUpdate 进度回调不准确</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000868190489286620a8b27f156c01?highLine=disableSwipeBack" target="_blank" rel="noopener">“右滑手势返回”能力调整</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000402c311c1308f661aeed1d51800" target="_blank" rel="noopener">微信 7.0.12 调用 wx.scanCode 后无 path 返回</a></li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><p>每个页面尽量重新调用接口<br>这样做的好处是降低耦合，<br>页面与页面之间是一个非常脆弱的关联。<br>因为谁也说不准未来的需求，<br>会不会一时兴起要“空降”这个页面。<br>那么如果这个页面依赖于之前的缓存或者其他处获取 Redux 等全局的数据，<br>最后的结果肯定是惨痛的修修补补。</p>
</li>
<li><p>onLoad/ onShow 生命周期<br>onLoad 的声明周期只用来处理页面传参。<br>onShow 的声明周期用来调用接口初始化数据。<br>如果二者混用，那么绝逼会由于接口异步的调用，<br>导致某些数据依赖数据没获取到就执行下一步，<br>从而使程序出现一堆偶现且莫名其妙的错误。</p>
</li>
<li><p>自定义封装的顶部导航<br>关于自定义的导航有两点想说一下：<br>一是，fixed 样式兼容。<br>当处于 fixed 样式的时候，<br>最好能实现个空格高度来占位文档流。<br>这样可以兼容用 fixed 的页面和不用 fixed 的页面。<br>有了占位之后，可以保证 fixed 的页面不会被搞垮掉。<br>另外也没必要让每个页面都要特意做个 padding-top。<br>这个 padding-top 还需要根据机型来判断高度。<br>所以最好还是都封装在顶部导航组件里来处理这个脏活是最好了。<br>二是，返回按钮劫持事件。<br>由于微信版本的更新，<br>在真机使用小程序时候，<br>可以通过右划左屏幕边缘，来完成快捷返回上一页的交互。<br>这个交互且无法关闭。<br>（可能为了照顾大屏手机 or 最小化小程序交互？）<br>这样相当于跨过了点返回按钮才返回的交互。<br>如果再点击返回按钮时候做了逻辑处理，<br>那么就很容易给未来的自己挖坑。<br>所以，最好还是通过 <strong>重定向</strong> 的跳转方式，<br>稳定的来维护我们的路由堆栈。</p>
</li>
<li><p>关于接口参数的传递<br>比如封装接口，需要传值的时候，<br>需要多少参数，就给封装函数参数设置多少个变量。<br>举个例子。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queryAppInfo = <span class="keyword">async</span> (</span><br><span class="line">  memberId?: <span class="built_in">string</span>,</span><br><span class="line">  appId?: <span class="built_in">string</span>,</span><br><span class="line">  timestamp?: <span class="built_in">string</span></span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> params = &#123;</span><br><span class="line">    memberId,</span><br><span class="line">    appId,</span><br><span class="line">    timestamp,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> CloudFetch.callFunction(<span class="string">"fetchAppInfo"</span>, params);</span><br><span class="line">  <span class="keyword">return</span> res.data.data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而有些参数是可选传参。比如我们不需要传递 appId 的时候，<br>外部调用的时候就会很难看</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">queryAppInfo(<span class="string">"007"</span>, , <span class="string">'123'</span>);</span><br></pre></td></tr></table></figure>

<p>那么，个人认为还是在调用接口的地方处理好参数对象，<br>直接将参数对象传入封装的函数中，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> param = &#123;</span><br><span class="line">  memberId: <span class="string">"007"</span>,</span><br><span class="line">  timestamp: <span class="string">"123"</span>,</span><br><span class="line">&#125;;</span><br><span class="line">queryAppInfo(param);</span><br></pre></td></tr></table></figure>

<p>这样看起来比较规范，数据也会比较安全。</p>
</li>
<li><p>弹出弹窗效果的实现<br>无论是模态对话框，还是弹出提示性的对话框。<br>虽然看起来只是弹出个对话框。<br>不过最好底部加一层蒙板，</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mask</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是透明或者有颜色。<br>这样不仅可以在蒙板上完成，阻止事件冒泡。<br>也可以在蒙板上完成，点击其他部分关闭提示对话框。</p>
</li>
<li><p>应用系的组件，要清晰回调函数<br>比如：登录、授权组件，回传事件需要明确。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">&#125;;</span><br><span class="line">fail: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证性能，谨慎接口调用<br>如果说前端都可以判断到，条件是不符合的，<br>那么无需做无用功，去再调用接口。</p>
</li>
<li><p>公共组件内的数据建议还是通过组件传值来取<br>如果过度依赖 Redux 中的数据，<br>就会导致该模块只能适用当前模块。<br>以至于后期其他模块无法复用。</p>
</li>
<li><p>Html 模板内尽可能的使用自闭合标签<br>在多方因素的作用下：<br>面条型的代码量的增加，<br>个别情况下的书写习惯，<br>线上 bug 临时写一笔赶工，<br>代码过长，缩进捋不清除。<br>在这种情况下，是很容易将一些代码混进标签内，<br>进而引发一些莫名其妙的错误，而且很难定位具体问题。<br>所以尽量使用自闭合标签来避免这些问题。</p>
</li>
<li><p>JSON.parse 的坑<br>JSOM.stringify 和 JSON.parse 是对序列化很有效的方法。<br>可供使用的场景也非常频繁。<br>JSOM.stringify 还好说，转换为字符串问题都不是很大。<br>JSON.parse 相对而言就要谨慎使用。<br>将一个 JSON 字符串转换为对象，<br>可是如果参数传入一个非 JSON 字符串的话，就会导致报错。<br>所以在使用 JSON.parse 的时候，一定要有一层保护。<br>即使传入的参数不是个正经值的时候，<br>传入个’{}’默认字符串以保证程序不至于报错。</p>
</li>
<li><p>wx.scanCode() 返回结果的坑。<br>调用微信小程序官方 API<br>wx.scanCode() 返回值的 path 字段，<br>竟然有时候存在，有时候就没有。<br>对照官方文档之后，看到官方给出的说法是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当所扫的码为当前小程序二维码时，会返回此字段，内容为二维码携带的 path</span><br></pre></td></tr></table></figure>

<p>不过有的时候也没有，只能通过 result 字段存储两份数据。<br>在扫码成功后，能读取成功哪个字段就取哪个字段的数据。</p>
</li>
<li><p>微信小程序 scroll-view 组件实现横向滚动的坑<br>经过测试，<br>发现要想实现横向滚动，不仅在组件设置对应属性字段，<br>还需要 CSS 中满足两个条件：</p>
<ol>
<li>外部 scroll-view 容器设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure></li>
<li>每个滚动子项需要设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>如果后续有想到的会随时更新。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>13.在循环中key值的作用是什么</title>
    <url>/2020/08/21/13-%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%ADkey%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在日常开发过程中，<br>当使用循环渲染的时候就一定要为循环项设置 key 属性，<br>那么为什么循环项就一定要有 key 呢？<br>如果 key 直接用 index 或者 random 赋值会有什么问题呢？</p>
<a id="more"></a>

<h3 id="究其根本"><a href="#究其根本" class="headerlink" title="究其根本"></a>究其根本</h3><p>无论是 Vue 还是 React 在每次触发渲染重绘的时候，<br>都会执行 diff 算法。<br>来判断新旧节点是否相同 sameVnode 的方法。</p>
<ol>
<li>如果认为节点相同</li>
</ol>
<p>递归 patchVnode 方法，<br>去处理新旧节点的 children，<br>根据新旧节点的 children 情况，<br>来对应 updateChildren、removeChildren 处理。</p>
<ol start="2">
<li>如果认为节点不同。</li>
</ol>
<p>则直接销毁旧节点，创建新节点。</p>
<h3 id="如果判断节点相同"><a href="#如果判断节点相同" class="headerlink" title="如果判断节点相同"></a>如果判断节点相同</h3><blockquote>
<p>源码位置：src/core/vdom/patch.js</p>
</blockquote>
<p>那么是如何判断节点相同的。<br>如果排列组合去对比两套节点，<br>那么时间复杂度将会是 O(n^3)。<br>这种情况是没办法应用于生产环境的。<br>所以无奈之下，<br>想到了一个巧妙且折中的办法：</p>
<ol>
<li>只会做同级的判断</li>
<li>只判断两个节点的 tag 和 key (还会判断 input 的 type)</li>
</ol>
<p>这样虽然可能还是会有一些误判的可能性，<br>不过这样就可以将时间复杂度降低为 O(n)，<br>且误判的造成资源浪费的情况是在我们可接受的范围内的，<br>所以这种方法还是可以应用生产环境的。</p>
<h3 id="key-如何赋值"><a href="#key-如何赋值" class="headerlink" title="key 如何赋值"></a>key 如何赋值</h3><p>那么回到我们最初的问题，应该如何科学的对 key 赋值？<br>最正确的方法就是在设计数据结构的时候，<br>给数组的每一项都设置唯一的 ID（UUID）。<br>将这个 id 赋值给 key。</p>
<p>那么如果给 key 赋值 index 或者 random 会有什么问题呢？</p>
<ol>
<li>如果给 key 赋值 index</li>
</ol>
<p>那么在列表数据没有改变的时候，是没有问题的。<br>可是如果对数据有插入操作，问题将会出现。<br>比如在数组的 3 位置上插入新的数据。<br>那么再次触发渲染。3 位置上的新旧两个节点 tag 和 key 都相同。<br>sameVnode 会返回是 true 认为是相同节点。<br>接下来开始判断这个“相同节点”内部的 children。<br>结果就会发现内部是完全不一样的。<br>那么每个子节点都需要销毁再全部新建。<br>不仅如此，在 3 位置以后的节点也都会出现如此问题。<br>这样销毁再重建，<br>失去了优化 DOM 操作的初衷。</p>
<ol start="2">
<li>如果给 key 赋值 random</li>
</ol>
<p>那么每次触发渲染刷新的时候，<br>sameVnode 永远都会返回是 false。<br>新旧节点都会认为是不同的节点。<br>所以每次渲染都会全部销毁，<br>再全部新建，<br>也同样失去了优化 DOM 操作的初衷。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>key 值的作用主要就是为了优化 diff 算法，<br>进而高效的更新虚拟 DOM。<br>其原理就是通过 key 值来精准判断新旧节点是否为相同节点。<br>从而避免去频繁更新 DOM 元素，<br>使得整个 patch 过程更加高效，减少 DOM 操作，提升性能。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>14.关于useState的函数式更新</title>
    <url>/2020/08/21/14-%E5%85%B3%E4%BA%8EuseState%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h3 id="关于-useState"><a href="#关于-useState" class="headerlink" title="关于 useState"></a>关于 useState</h3><p>useState 可谓是在 Taro 的开发过程中最常用的一个 hook。<br>由于函数式组件每次渲染都会执行一次函数，<br>他的作用就是在函数内保存一个变量，并且这个变量能够保存的住。<br>可以通过对应 setXXX 函数来对这个变量进行修改。<br>那么如果变量是一个对象或者一个数组，<br>我只想修改其中一个元素的时候，很容易因为闭包的情况误伤其他元素。<br>这个时候我们可以用到 useState 函数式更新。</p>
<a id="more"></a>

<h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>比如我再页面中声明了这样一个变量。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IImageType &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  isUpload: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [arrImageList, setImageList] = useState&lt;<span class="built_in">Array</span>&lt;IImageType&gt;&gt;([]);</span><br></pre></td></tr></table></figure>

<p>这是一个图片列表，而每个图片上传成功后，我会把每个元素的标志位置 isUpload 再置为 true。<br>如果用普通最直接的方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">onUploadSuccess: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arrImageListTmp = deepClone(arrImageList);</span><br><span class="line">  <span class="keyword">const</span> nIndex = arrImageListTmp.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.id === res.id;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (nIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    arrImageListTmp[nIndex].isUpload = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  setImageList(arrImageListTmp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个时候，由于闭包的存在，导致每个异步回调函数都是闭塞的。<br>不知道 arrImageList 的即时状态。<br>在图片上传成功回调的时候，<br>其 arrImageList 的状态还是执行上传图片时候的状态。<br>效果是，每一个新的图片状态被改变，他同时也会将其他图片状态还原。<br>最后的结果是，只有最后上传成功的图片 isUpload 标志位为 true，<br>其他已经上传成功的图片 isUpload 标志位又被改回了 false。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>这个问题究其根本就是闭包的原因。<br>并且因为这个可爱可憎闭包，<br>也将会在未来 Taro 的开发过程中，不小心就会留下很多坑。<br>那么，面对刚刚的问题，<br>使用 useState 的函数式更新就能很优雅的解决这个问题。<br>只需要在上传成功回调函数中改为以下方法实现：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">onUploadSuccess: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  setImageList(<span class="function">(<span class="params">pervImageList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arrImageListTmp = deepClone(pervImageList);</span><br><span class="line">    <span class="keyword">const</span> nIndex = arrImageListTmp.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.id === res.id;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (nIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arrImageListTmp[nIndex].isUpload = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrImageListTmp;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样一来，<br>每次被深拷贝的 ImageList，<br>都会是当前最新状态的 ImageList。<br>所以，也就不会有之前的问题了。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>解决这个问题的时候，<br>真的是抓心挠肝，想了很多奇葩的方法。<br>尝试 useCallback， useRef，<br>不仅绕路，而且会让代码逻辑导致混乱不堪，没有使用。<br>也想到一种方式是利用 Redux 来存储状态，这样也是可以实现的。<br>不过折腾了一圈，最后从官方文档处发现了解决方法。<br>真是，<br>众里寻他千百度，<br>蓦然回首，<br>那人却在灯火阑珊处。</p>
<p><a href="https://taro-docs.jd.com/taro/docs/hooks#usestate" target="_blank" rel="noopener">官方文档</a>原文是这么写的：<br><strong>函数式更新</strong><br>如果新的 state 需要通过使用先前的 state 计算得出，<br>那么可以将函数传递给 setState。<br>该函数将接收先前的 state，并返回一个更新后的值。<br>下面的计数器组件示例展示了 setState 的两种用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter(&#123; initialCount &#125;) &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(initialCount);</span><br><span class="line">  return (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount(initialCount)&#125;&gt;Reset&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount((prevCount) &#x3D;&gt; prevCount + 1)&#125;&gt;+&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setCount((prevCount) &#x3D;&gt; prevCount - 1)&#125;&gt;-&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后也说明了</p>
<blockquote>
<p><code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p>
</blockquote>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>React</tag>
        <tag>Taro</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>15.flex布局下文字超出宽度后省略号不起作用解决方法</title>
    <url>/2020/08/21/15-flex%E5%B8%83%E5%B1%80%E4%B8%8B%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E5%AE%BD%E5%BA%A6%E5%90%8E%E7%9C%81%E7%95%A5%E5%8F%B7%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="需求情况"><a href="#需求情况" class="headerlink" title="需求情况"></a>需求情况</h3><p>在项目开发过程中，<br>曾经遇到过这样一个样式需求。<br>在一行中，分为三个部分。<br>左右部分固定宽度，<br>中间部分适配机型宽度，<br>如果中间的文字超出宽度则以省略号显示。</p>
<p>当时没有觉得很复杂，<br>结果在实现的时候，兜兜转转踩了好多坑，<br>其实这个应该算是比较常见的样式吧，<br>决定把他记录下来，防止以后忘记。</p>
<a id="more"></a>

<h3 id="关于省略号"><a href="#关于省略号" class="headerlink" title="关于省略号"></a>关于省略号</h3><p>其实，文本超出范围以省略号显示，这个样式还是很常见的。<br>一行文本超出宽度以省略号显示。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-ellipsis</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 固定宽度 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">/* 超出部分隐藏 */</span></span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis; <span class="comment">/* 超出部分文本以省略号显示 */</span></span><br><span class="line">  <span class="attribute">white-space</span>: nowrap; <span class="comment">/* 文本禁止换行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多行文本超出宽度以省略号显示。（只能适配 webkit 浏览器和移动端）</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.textarea-ellipsis</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box; <span class="comment">/* 对象作为弹性伸缩盒子模型显示 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical; <span class="comment">/* 设置或检索伸缩盒对象的子元素的排列方式 */</span></span><br><span class="line">  <span class="attribute">-webkit-line-clamp</span>: <span class="number">3</span>; <span class="comment">/* 展示行数 */</span></span><br><span class="line">  <span class="comment">/* 如果多行文本内有可能存在长单词英文，那么需要对长单词英文进行打断 */</span></span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word; <span class="comment">/* 是否允许在单词内进行断句 */</span></span><br><span class="line">  <span class="attribute">word-break</span>: break-all; <span class="comment">/* 可以在任何位置断句 */</span></span><br><span class="line">  <span class="comment">/* 让多行文字两端对齐 */</span></span><br><span class="line">  <span class="attribute">text-align</span>: justify; <span class="comment">/* 多行文本样式最好加上：文本两端对齐 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚刚上述的需求里面。<br>通过 flex 布局，左右宽度固定，中间宽度自适应。<br>那么在中间的模块里面，<br>直接使用 text-ellipsis 的样式是不生效的。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"module-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"module-left"</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"module-mid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid-text text-ellipsis"</span>&gt;</span>abcabcabcabcabcabcabcabcabc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"module-right"</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.module-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.module-left</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">120px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.module-mid</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>; <span class="comment">/* 此处的宽度为关键 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.text-ellipsis</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: block;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">      <span class="attribute">overflow</span>: hidden;</span><br><span class="line">      <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">      <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.module-right</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">120px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实这个问题之前遇到过一次，<br>当时为了解决线上问题，<br>就那么默默的划过去了。</p>
<p>不过前几天正巧又遇到了这个样式的需求，<br>只记得当初是这么做过，<br>不记得具体怎么实现的了。<br>结果又是重复的踩了一轮坑。</p>
<p>吸取教训，及时复盘，<br>将这个 CSS 样式整理出来，引以为戒。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>16.关于setState、setData后数值不及时更新的问题</title>
    <url>/2020/11/22/16-%E5%85%B3%E4%BA%8EsetState%E3%80%81setData%E5%90%8E%E6%95%B0%E5%80%BC%E4%B8%8D%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在开始写 setState 的时候，<br>都会有这个疑问。<br>为什么我已经对 state 的数值赋值了，<br>可是我接下来去用这个值的时候，却不是刚刚赋值过的数据。<br>其实原因很简单。</p>
<blockquote>
<p>Because, setState is asynchronously.</p>
</blockquote>
<a id="more"></a>

<h3 id="为什么要异步赋值"><a href="#为什么要异步赋值" class="headerlink" title="为什么要异步赋值"></a>为什么要异步赋值</h3><p>那么为什么要把赋值功能设置成异步，<br>做成同步难道不香么？<br>如果做成了同步的功能，<br>我们的每次 set 操作，<br>就去触发一次页面的渲染也是一件很可怕的事情。<br>更多时候我们只是要一个结果，<br>而不是把每次数据变化精准的展示给用户。<br>而异步赋值的好处就是可以整合我们的操作。<br>这样在主线程之内无论我们一个数组 push 多少次，<br>那么实际上只是会渲染一次。</p>
<h3 id="关于-nexttick"><a href="#关于-nexttick" class="headerlink" title="关于 nexttick"></a>关于 nexttick</h3><p>所谓 nexttick 就是当 DOM 渲染结束之后的一个回调函数。<br>我们可以在 nexttick 的回调函数中获得最新的数值。</p>
<p>要知道我们所有同步任务都是在主线程上执行的。<br>所有异步任务有了运行结果就会在任务队列中放置一个事件。<br>直到主线程的任务结束完毕，<br>就会去查看任务队列，将已完成的异步事件处理完毕。</p>
<p>而 nexttick 就是一个这样的异步任务。<br>在主线程的任务完成后，<br>就会开始执行更新渲染 DOM。<br>直到 DOM 渲染完毕，<br>这样 nexttick 就获取到了改变后的 DOM。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>之所以异步赋值也是为了优化性能，尽量减少 DOM 操作而考虑的。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>17.关于虚拟节点VNode</title>
    <url>/2020/11/25/17-%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9VNode/</url>
    <content><![CDATA[<h3 id="何为-VNode"><a href="#何为-VNode" class="headerlink" title="何为 VNode"></a>何为 VNode</h3><p>在开发过程中，或许总会听到有人提到过虚拟节点，<br>那么这个究竟是个什么东西？<br>首先我们要有一个认知，<br>那就是 js 的操作的执行速度是远远高于 DOM 的操作的。<br>基于这个认知，为了提升页面的性能，<br>我们宁可多执行一些 js 操作，也要减少对 DOM 的操作（重绘、回流）次数。<br>所以需要用 js 以对象的形式来模拟 DOM 节点，<br>那么经过 js 的计算，只照着最后的结果去操作 DOM 渲染到页面即可。<br>而这个数据结构就是虚拟节点 VNode。</p>
<a id="more"></a>

<h3 id="VNode-的数据结构"><a href="#VNode-的数据结构" class="headerlink" title="VNode 的数据结构"></a>VNode 的数据结构</h3><p>正常的 html 标签一共可以分为三部分：</p>
<ol>
<li>标签名</li>
<li>标签属性</li>
<li>子元素标签</li>
</ol>
<p>那么 VNode 同样可以用一个对象的结构模拟这样的结构：</p>
<ol>
<li>tag</li>
<li>props</li>
<li>children</li>
</ol>
<p>具体可以用这个例子来展示将这个 html 转换成 VNode：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">"ul"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">"list-wrap"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      className: <span class="string">'list-item'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: <span class="string">'AAA'</span></span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      className: <span class="string">'list-item'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: <span class="string">'BBB'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VNode-的作用"><a href="#VNode-的作用" class="headerlink" title="VNode 的作用"></a>VNode 的作用</h3><p>那么我们将 html 转换成一个对象之后对我们的性能优化能起到什么帮助呢？</p>
<ol>
<li>数据驱动视图</li>
</ol>
<p>不用自己手动操作 DOM。<br>只要写好 VM 的代码逻辑，<br>即可通过响应式，来实现数据-视图的绑定。<br>让我们将关注点更多的放在数据上，<br>从而能够实现更复杂的开发业务。</p>
<ol start="2">
<li>精准更新节点</li>
</ol>
<p>可以通过 diff 算法，<br>将有改变的节点进行处理（销毁、新建、更新），<br>而不变的节点则可以不去处理。<br>比起手动粗暴的操作 DOM ，性能方面会更有优势。</p>
<ol start="3">
<li>可以整理合并我们的操作</li>
</ol>
<p>比如我们多次增加节点，<br>如果每次增加一个节点都渲染一次页面做很多无用功，<br>实际上我们想要的就是在多次增加节点后，<br>把最后的一个结果在页面上渲染出来即可。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>VNode 拥有这么多优势，<br>但是还是有几个问题需要我们去想通的。</p>
<ol>
<li>如何将 html 转换为 VNode，然后再将 VNode 转换为 html？</li>
<li>当我们 useData 之后，Vue 是如何知道数值改变了呢？</li>
<li>当页面需要重新渲染的时候，新旧节点是如何去对比的？（13 中有提到部分）</li>
</ol>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>18.浅尝VSCode插件开发(Code Maker)</title>
    <url>/2020/12/17/18-%E6%B5%85%E5%B0%9DVSCode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91(Code%20Maker)/</url>
    <content><![CDATA[<h3 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h3><p>工作中写前端的业务代码，说白了也就是写好“页面”和“组件”。（也可以说就是只有“组件”）<br>而在项目结构上，每个组件就是一个文件或者文件夹。<br>每次新写组件的时候，都需要新建文件，<br>然后开始依次写好 import、template、style、data、methods、生命周期、render 等等……<br>为了应对这样重复的工作，<br>我甚至单独建立一套空的模板，每次都是复制一下改个名字，并窃喜于自己的机智。<br>直到遇到了 VSCode 插件，才给我打开一扇新世界的大门。<br>且 VSCode 插件给我带来的惊喜不仅仅于此。</p>
<a id="more"></a>

<h3 id="需求痛点"><a href="#需求痛点" class="headerlink" title="需求痛点"></a>需求痛点</h3><ol>
<li>每次新建页面，新建组件都需要复制一套空模板，可以一键生成空页面、空组件。(可用命令实现)</li>
<li>常用组件、常用 API 、可以通过简短命令自动实现引用。（可用代码片段实现）</li>
<li>页面 import、template、style、data、methods、生命周期、render 有固定顺序。</li>
<li>通过插件配置页面<code>settings.json</code>，可支持自定义开关支持框架（如：Vue、React、Wepy、Taro 等）。(可用配置自定义变量实现)</li>
<li>发布 VSCode 插件市场，可供大家使用。</li>
</ol>
<h3 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h3><p>项目结构如下所示（带*文件为实现重要功能）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGELOG.md &#x2F;&#x2F; 版本更新日志</span><br><span class="line">├── README.md &#x2F;&#x2F; 插件说明</span><br><span class="line">├── cli.js &#x2F;&#x2F; 自动化生成 VSCode 插件命令的 CLI 工具</span><br><span class="line">├── code-maker-1.0.7.vsix &#x2F;&#x2F; VSCode 打包后文件，通过该文件可本地安装或发布线上插件</span><br><span class="line">├── images</span><br><span class="line">│   └── icon.png &#x2F;&#x2F; 插件 icon</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json &#x2F;&#x2F; 核心配置文件*</span><br><span class="line">├── snippets &#x2F;&#x2F; 代码片段*</span><br><span class="line">│   └── mapx.json</span><br><span class="line">├── src &#x2F;&#x2F; 代码实现*</span><br><span class="line">│   ├── command &#x2F;&#x2F; 命令*</span><br><span class="line">│   │   ├── index.ts &#x2F;&#x2F; 命令索引</span><br><span class="line">│   │   ├── taroqmCreateComponent.ts</span><br><span class="line">│   │   ├── taroqmCreatePage.ts</span><br><span class="line">│   │   ├── taroqmEditComponent.ts</span><br><span class="line">│   │   └── taroqmEditPage.ts</span><br><span class="line">│   ├── extension.ts &#x2F;&#x2F; 程序入口*</span><br><span class="line">│   ├── test</span><br><span class="line">│   │   ├── runTest.ts</span><br><span class="line">│   │   └── suite</span><br><span class="line">│   └── utils &#x2F;&#x2F; 公共方法</span><br><span class="line">│       ├── copyFile.ts</span><br><span class="line">│       ├── index.ts &#x2F;&#x2F; 方法索引</span><br><span class="line">│       └── openFile.ts</span><br><span class="line">├── template &#x2F;&#x2F; 模板文件*</span><br><span class="line">│   ├── TaroQmComponent</span><br><span class="line">│   │   ├── less.tmp</span><br><span class="line">│   │   └── tsx.tmp</span><br><span class="line">│   ├── TaroQmPage</span><br><span class="line">│   │   ├── less.tmp</span><br><span class="line">│   │   └── tsx.tmp</span><br><span class="line">│   └── VSCodeCommand</span><br><span class="line">│       └── ts.tmp</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── vsc-extension-quickstart.md</span><br></pre></td></tr></table></figure>

<p>通过<code>package.json</code>文件配置字段：</p>
<ol>
<li>activationEvents - 注册命令</li>
<li>contributes.snippets - 代码片段</li>
<li>contributes.commands - 命令名称</li>
<li>contributes.menus - 配置菜单</li>
<li>contributes.configuration - 配置自定义变量</li>
</ol>
<p>根据<code>开闭原则</code>，为方便以后拓展命令：<br>将每个命令单独建立文件，<br>在插件入口文件 extension.ts 逻辑内，<br>循环遍历由./src/command/index.ts 引用来的命令对象，进行命令注册。<br>这样好处在于，<br>再新增命令的时候，只需要新增加文件对其引用，而无需去修改注册逻辑。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>每次新建页面，新建组件都需要复制一套空模板，可以一键生成空页面、空组件。(可用命令实现)</p>
<p>首先，封装<code>拷贝文件</code>、<code>打开文件</code>的公共方法。<br>其次，通过<code>注册命令</code>、<code>修改命令名称</code>、<code>配置菜单</code>，生成一个命令文件。<br>然后，通过文档以及其他参考资料，找到<code>应用项目文件路径</code>和<code>模板文件路径</code>的字段。<br>最后，将模板文件复制过去，并将自动将模板名字改成所需的页面、组件名字。</p>
</li>
<li><p>常用组件、常用 API 、可以通过简短命令自动实现引用。（可用代码片段实现）<br>通过<code>代码片段</code>、生成一个代码片段文件。<br>即可再对应语言的文件内使用。</p>
</li>
<li><p>页面 import、template、style、data、methods、生命周期、render 有固定顺序。<br>待实现。</p>
</li>
<li><p>通过插件配置页面<code>settings.json</code>，可支持自定义开关支持框架（如：Vue、React、Wepy、Taro 等）。(可用配置自定义变量实现)<br>通过<code>配置自定义变量</code>，定义对应自定义变量。<br>在<code>package.json</code>文件内，可通过<code>when</code>字段对该字段进行使用。<br>在 js 文件内，可通过<code>vscode.workspace.getConfiguration(&#39;myExtension&#39;)</code>API 方法，取到对应自定义变量。</p>
</li>
<li><p>发布 VSCode 插件市场，可供大家使用。<br>全局安装<code>vsce</code>工具，并将 VSCode 插件打包成 vsix 文件。<br>另需要<code>Microsoft账号</code>、<code>Azure账号</code>。<br>在网页版<a href="https://marketplace.visualstudio.com/manage" target="_blank" rel="noopener">https://marketplace.visualstudio.com/manage</a>，将打包好的插件发布出去。</p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>成熟的开发工作应该如同流水线一般。<br>拥有完成的工具体系，而不是遇到需求都是一个人一个想法的自由发挥。<br>无论遇到什么需求都能够有一套对应的技术方案去应对。</p>
<p>以前端常见的业务场景来说：<br>比如：分页加载、分享溯源、详情页面加载、授权鉴权等等……<br>这些业务场景都是有迹可循，都可以套用模板去实现。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/gengjian1203/code-maker" target="_blank" rel="noopener">Code Maker</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window" target="_blank" rel="noopener">VSCode 插件英文文档</a></li>
<li><a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/api/README" target="_blank" rel="noopener">VSCode 插件中文文档（残卷）</a></li>
<li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html" target="_blank" rel="noopener">小茗同学的博客园-VSCode 插件开发全攻略</a></li>
<li><a href="https://segmentfault.com/a/1190000016641617" target="_blank" rel="noopener">有赞美业前端团队-VS Code 插件开发介绍</a></li>
<li><a href="https://github.com/microsoft/vscode-extension-samples" target="_blank" rel="noopener">VSCode 插件示例</a></li>
</ol>
]]></content>
      <categories>
        <category>projects</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>19.Node脚本之inquirer库的使用</title>
    <url>/2020/12/19/19-Node%E8%84%9A%E6%9C%AC%E4%B9%8Binquirer%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="inquirer-库是什么"><a href="#inquirer-库是什么" class="headerlink" title="inquirer 库是什么"></a>inquirer 库是什么</h3><p>这是一个可以实现用户与命令行交互的工具。<br>他封装了<code>一问一答</code>式更友好的输入、单选、多选的交互，<br>比如常见的 npm init、 Vue-cli 等脚手架工具都可以通过他来实现。<br>像是我在<code>18.浅尝VSCode插件开发(Code Maker)</code>一文中，提到的<code>自动化生成 VSCode 插件命令的 CLI 工具</code>也就是用他来实现的。</p>
<a id="more"></a>

<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>创建一个<code>index.js</code>搭建好脚本基本框架</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">"inquirer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体交互内容</span></span><br><span class="line"><span class="keyword">const</span> promptList = [</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">"input"</span>, <span class="comment">// input - 输入文本, confirm - (Y/N), list - 列表单选, rawlist - 输入数字单选列表, expand - key值快速选择列表, checkbox - 多选, password - 密文, editor - 编译器长文本</span></span><br><span class="line">    message: <span class="string">"请输入11位数字:"</span>, <span class="comment">// 提示文本</span></span><br><span class="line">    name: <span class="string">"number"</span>, <span class="comment">// 变量命名</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="string">"默认文本"</span>, <span class="comment">// 默认值</span></span><br><span class="line">    when: <span class="function">(<span class="params">answers</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 可通过answers获取刚刚回答的答案</span></span><br><span class="line">      <span class="comment">// 返回值为true的时候才会提问当前问题</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    validate: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 校验规则字段</span></span><br><span class="line">      <span class="keyword">if</span> (val.match(<span class="regexp">/\d&#123;11&#125;/g</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"请输入11位数字"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    filter: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用filter将答案字符串进行处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"tel:"</span> + val;</span><br><span class="line">    &#125;,</span><br><span class="line">    prefix: <span class="string">"前缀"</span>,</span><br><span class="line">    suffix: <span class="string">"后缀"</span>,</span><br><span class="line">    <span class="comment">// choices: [] // list 、rawlist、expand、checkbox会用到</span></span><br><span class="line">    <span class="comment">// pageSize: 2, //修改某些type类型下的渲染行数；</span></span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">inquirer.prompt(promptList).then(<span class="function">(<span class="params">answers</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(answers); <span class="comment">// 返回刚刚输入的结果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接下来只需要拓展 promptList 的元素即可实现自己想要的功能。<br>如果功能逻辑过于复杂的话，建议还是将功能实现通过文件拆分开来。</p>
<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node ./index.js</span><br></pre></td></tr></table></figure>

<p>即可看到刚刚自己所设计的交互了。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实，搭建 inquirer 以及使用还是很简单的。<br>真正复杂的部分应该是在得到刚刚交互结果之后，<br>所需要操作的功能实现。</p>
<p>参考资料：<br><a href="https://blog.csdn.net/qq_26733915/article/details/80461257" target="_blank" rel="noopener">inquirer.js —— 一个用户与命令行交互的工具</a><br><a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">inquirer - npm</a></p>
]]></content>
      <tags>
        <tag>Node脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>2.微信小程序BLE蓝牙连接智能硬件流程</title>
    <url>/2020/06/18/2-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FBLE%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="BLE蓝牙连接智能硬件流程"><a href="#BLE蓝牙连接智能硬件流程" class="headerlink" title="BLE蓝牙连接智能硬件流程"></a>BLE蓝牙连接智能硬件流程</h3><p>微信小程序蓝牙模块只支持BLE，通常说的蓝牙4.0（及以上版本）。<br>特点在于低功耗，高速率，距离短，数据量小，以字节流传输。  </p>
<p>可以通过手机下载对应APP应用来模拟被连接的硬件设备  </p>
<ul>
<li>iOS lightblue</li>
<li>Android BLE调试宝</li>
</ul>
<a id="more"></a>

<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.startBluetoothDevicesDiscovery.html" target="_blank" rel="noopener">微信小程序蓝牙官方文档</a></p>
<h3 id="通讯流程"><a href="#通讯流程" class="headerlink" title="通讯流程"></a>通讯流程</h3><ol>
<li>初始化蓝牙适配器。</li>
<li>搜索蓝牙设备获取设备UUID(deviceId)。（占用资源较多，不搜索要及时停止搜索）（另部分安卓机可能需要获取位置权限才能搜索到蓝牙设备）</li>
<li>配对绑定设备，建立连接。</li>
<li>通过设备UUID(deviceId)，获取该设备的设备所有服务(services)。</li>
<li>通过设备UUID(deviceId)、服务UUID(serviceId)，获取蓝牙设备指定服务的所有特征值(characteristic)。</li>
<li>通过特征值(characteristic)的属性，获取该特征值的读、写、广播权限。</li>
<li>通过设备UUID(deviceId)、服务UUID(serviceId)、特征值UUID(characteristicId)，来对该特征值进行读写操作。（传输类型只支持ArrayBuffer）</li>
<li>通过监听特征值的回调，获取特征值的变化情况。进而实现小程序蓝牙与智能硬件设备的通讯。</li>
<li>由于BLE低功耗蓝牙的连接非常不稳定。比如：比如刚连接上就断开、连接成功之后传输数据随机断开等情况。所以要做好断线重连等底层通讯异常的对应处理。</li>
</ol>
<h3 id="参数示意图"><a href="#参数示意图" class="headerlink" title="参数示意图"></a>参数示意图</h3><p><img src="/images/image_2_1.jpg" alt="参数示意图"></p>
<h3 id="蓝牙常用API及返回值"><a href="#蓝牙常用API及返回值" class="headerlink" title="蓝牙常用API及返回值"></a>蓝牙常用API及返回值</h3><ol>
<li>初始化蓝牙适配器<br>wx.openBluetoothAdapter  </li>
<li>开始搜寻附近的蓝牙外围设备<br>wx.startBluetoothDevicesDiscovery  </li>
<li>获取搜索发现到的蓝牙设备的具体信息<br>wx.onBluetoothDeviceFound<br>返回值：<br>信号强度：RSSI: number,<br>该设备启动服务的UUID：advertisServiceUUIDs: array,<br>设备UUID：deviceId: string,<br>设备名称：localName: string,<br>设备名称：name: string,<br>serviceData: array object  </li>
<li>通过设备UUID(deviceId)，来连接对应的设备。<br>wx.createBLEConnection<br>若小程序在之前已有搜索过某个蓝牙设备，并成功建立连接，可直接传入之前搜索获取的 deviceId 直接尝试连接该设备，无需进行搜索操作。  </li>
<li>通过设备UUID(deviceId)，获取指定蓝牙设备所有服务(service)<br>wx.getBLEDeviceServices<br>返回值：<br>设备UUID：deviceId: string,<br>开启的服务列表：service: array,    </li>
<li>通过设备UUID(deviceId)和服务UUID(serviceId)，获取蓝牙设备指定服务的所有特征值(characteristic)。<br>wx.getBLEDeviceCharacteristics<br>返回值：<br>设备UUID：deviceId: string,<br>服务UUID：serviceId: string,<br>特征值列表：characteristic: array object<br>特征值UUID：characteristic[0].uuid<br>该特征值是否支持read操作：characteristic[0].properties.read<br>该特征值是否支持write操作：characteristic[0].properties.write<br>该特征值是否支持notify操作：characteristic[0].properties.notify<br>该特征值是否支持indicate操作：characteristic[0].properties.indicate  </li>
<li>开启notify。必须先启用 notifyBLECharacteristicValueChange 接口才能接收到设备推送的 notification<br>wx.notifyBLECharacteristicValueChange  </li>
<li>监听低功耗蓝牙设备的特征值变化<br>wx.onBLECharacteristicValueChange<br>返回值：<br>设备UUID：deviceId: string,<br>服务UUID：serviceId: string,<br>特征值UUID：characteristicId: string,<br>特征值: value: ArrayBuffer,  </li>
<li>发送数据到设备中<br>wx.writeBLECharacteristicValue  </li>
<li>关闭蓝牙模块。<br>wx.closeBluetoothAdapter  </li>
<li>停止搜寻附近的蓝牙外围设备。<br>wx.stopBluetoothDevicesDiscovery  </li>
</ol>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="/assets/assets_2_1.wpy">基于Wepy的示例</a></p>
]]></content>
      <categories>
        <category>projects</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>20.前端工程化开发规范</title>
    <url>/2021/01/03/20-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="规范背景"><a href="#规范背景" class="headerlink" title="规范背景"></a>规范背景</h3><p>随着市面上的需求越来越复杂。<br>个人开发者已无法满足项目版本的开发速度。<br>那么团队开发是复杂项目的必然选择。<br>不过如何管理研发团队的开发风格，<br>确保每一行代码都像是<code>同一个人</code>编写的。<br>从而减少团队中代码的沟通成本。<br>这是团队开发中重要的一环。</p>
<a id="more"></a>

<h3 id="目录结构规范"><a href="#目录结构规范" class="headerlink" title="目录结构规范"></a>目录结构规范</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── client              <span class="comment">// 项目根路径</span></span><br><span class="line">    ├── config          <span class="comment">// webpack相关配置</span></span><br><span class="line">    └── src             <span class="comment">// 源码</span></span><br><span class="line">        ├── api         <span class="comment">// webapi接口</span></span><br><span class="line">        ├── assets      <span class="comment">// 静态资源</span></span><br><span class="line">        ├── components  <span class="comment">// 公共组件</span></span><br><span class="line">        ├── config      <span class="comment">// 项目配置：如环境</span></span><br><span class="line">        ├── hooks       <span class="comment">// 公共Hooks</span></span><br><span class="line">        ├── pages       <span class="comment">// 页面</span></span><br><span class="line">        ├── redux       <span class="comment">// redux</span></span><br><span class="line">        ├── scss        <span class="comment">// 公共样式、UI库样式、主题色、层级管理</span></span><br><span class="line">        ├── services    <span class="comment">// 封装管理器：接口请求器、缓存管理器、图片处理器等</span></span><br><span class="line">        └── utils       <span class="comment">// 公共方法</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>组件设计</p>
<p>每个组件都是一个文件夹。组件名即为文件夹名。<br>文件夹内包括 index.tsx 以及 index.less。<br>组件内尽量不要使用 redux。<br>所有依赖数据尽量使用 props 传值。<br>内部逻辑实现尽量抽象，不要依赖业务元素。<br>这样以保证其复用性。<br>组建内部尽量不要使用页面级生命周期。（待实践）</p>
<p>组件传入的每个参数都要注释其意义，以及是否必传。<br><code>公共组件</code>放到./client/src/components<br><code>局部组件</code>放到对应页面下的 components 文件夹内</p>
</li>
<li><p>页面设计</p>
<p>每个页面都是一个文件夹。页面名即为文件夹名。<br>文件夹内包括 components、index.tsx 、 index.less、 index.config.ts</p>
<p>页面传入的每个参数都要注释其意义，以及是否必传。</p>
</li>
</ol>
<h3 id="git-管理规范"><a href="#git-管理规范" class="headerlink" title="git 管理规范"></a>git 管理规范</h3><ol>
<li>保证 master 分支代码，是没有风险的，随时可以打包上线。</li>
<li>创建分支的时候，同时绑定该分支的版本号。同步书写该版本的文档。</li>
<li>可通过 gitlab runner 搭建 CI 持续集成。</li>
<li>按照一定语法去 commit，每一条 commit 由以下几部分构成。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">修改类型+(影响模块)+:+[bug单号]+问题描述</span></span><br><span class="line"><span class="section">如：fix(会员购买页面):[7405-7405]会员等级购买ios购买规避政策</span></span><br><span class="line">修改类型分为以下几种：</span><br><span class="line"><span class="section">feat: 开发新功能</span></span><br><span class="line"><span class="section">style: 调整样式</span></span><br><span class="line"><span class="section">fix: bug修复</span></span><br><span class="line"><span class="section">refactor: 代码重构</span></span><br><span class="line"><span class="section">merge: 代码合并</span></span><br><span class="line"><span class="section">doc: 书写文档</span></span><br><span class="line"><span class="section">config: 调整配置</span></span><br></pre></td></tr></table></figure>

<p>PS:<br> 定制版本过多的话，不建议以分支去隔离。<br> 随着业务分叉严重，版本更迭时间过长。<br> 合代码的时候，任务重，风险大。<br> 可考虑通过 webpack 打包不同文件后缀名，进行文件隔离。（待实践）</p>
<h3 id="代码编写规范"><a href="#代码编写规范" class="headerlink" title="代码编写规范"></a>代码编写规范</h3><ol>
<li><p>统一开发环境<br>建议 VSCode+Prettier 自动保存即格式化代码。</p>
</li>
<li><p>事件绑定函数命名<br>开头：固定使用 handle<br>中间模块名称：如：Cell、Item<br>尾部事件名称：如：Click、TouchMove<br>例：handleCellClick(e)</p>
</li>
<li><p>函数命名规范<br>通过函数名来知道意义。<br>校验类：check 开头<br>处理类：deal 开头<br>方法类： process 开头<br>渲染类： render 开头</p>
</li>
<li><p>组件命名规范<br>使用名词开头，后接形容词。<br>如：list-select、module-title、panel-bottom。</p>
</li>
<li><p>路由传值<br>由于路由传值都被转为 string 类型。传值 undefined，false，true 等歧义变量，很容易引发隐蔽性 bug。</p>
</li>
<li><p>封装方法传入的参数尽量是对象</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">dealDateInfo(params); <span class="comment">// good</span></span><br><span class="line">dealDateInfo(data, show, tip, success); <span class="comment">// bad</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数需要多个参数实现其逻辑，尽量将这些参数组成一个对象。<br>这样的好处在于：</p>
<ol>
<li>方便定义类型。</li>
<li>如果部分参数是非必传的情况，方便处理。</li>
<li>对于编译器减少 push 函数参数的操作</li>
</ol>
</li>
</ol>
<h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><ol>
<li><p>import 书写顺序</p>
<ol>
<li>优先引入三方库</li>
<li>次之引入绝对路径</li>
<li>最后引入相对路径</li>
</ol>
<p>而同级则以引入库的字母顺序排列。</p>
</li>
<li><p>类开发内书写顺序</p>
<ol>
<li><p>优先书写变量相关</p>
<ol>
<li>优先书写 构造函数：自定义变量</li>
<li>其次书写 state、data 的定义</li>
<li>次之书写 computed</li>
<li>最后书写 watch</li>
</ol>
</li>
<li><p>次之书写函数相关</p>
<ol>
<li>优先书写 methods</li>
<li>其次书写 events 等自定义事件</li>
<li>次之书写 生命周期</li>
<li>最后书写自定义函数</li>
</ol>
</li>
<li><p>如为 tsx 文件</p>
<ol>
<li>自定义 render 函数</li>
<li>返回的 render 函数</li>
</ol>
</li>
</ol>
</li>
<li><p>react hook 书写顺序（待实践）</p>
<ol>
<li>useRef</li>
<li>useMemo</li>
<li>useState</li>
<li>useRouter</li>
<li>useDidShow</li>
<li>useEffect</li>
</ol>
</li>
</ol>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ol>
<li>与视图层渲染无关的数据尽量不要放在  data  中，可以放在页面（组件）类的其他字段下。</li>
</ol>
<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><ol>
<li>通过 jsDoc 完善 api 文档</li>
<li>通过 jscpd 判断代码重复率</li>
<li>工具化代码 review 平台</li>
<li>项目管理系统平台</li>
<li>自动化测试</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本篇部分内容为实际项目已经用到且取得相应成效的方法。<br>部分内容为个人见解尚在理论部分，待实践。<br>项目规范是一个不断优化、不断完善的长期过程。<br>要做到因地制宜，慢慢尝试，找到最适合自己团队的方式，<br>这样才能真正提升团队开发效率。<br>我也会不断更新该篇文章。</p>
]]></content>
      <tags>
        <tag>工程化</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>22.公司产品同学的运营实践分享有感</title>
    <url>/2021/01/15/22-%E5%85%AC%E5%8F%B8%E4%BA%A7%E5%93%81%E5%90%8C%E5%AD%A6%E7%9A%84%E8%BF%90%E8%90%A5%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<h3 id="书写背景"><a href="#书写背景" class="headerlink" title="书写背景"></a>书写背景</h3><p>随着代码越写越多，<br>感觉要想成为一名合格的程序猿，<br>不能仅仅是一味低头的当一个“码农”，<br>偶尔也得尝试抬起头看看隔壁产品同学的日常。<br>搞清楚产品的工作思路，也能把握自身的代码开发方向。<br>（就好像要把握出题者的意图，答题才能更顺手的感觉~）<br>正逢赶上公司的产品大佬分享，<br>抽出身子过去赶紧学习一波。</p>
<a id="more"></a>

<h3 id="分享内容"><a href="#分享内容" class="headerlink" title="分享内容"></a>分享内容</h3><p>这次分享会，主要分享了四点内容：</p>
<ol>
<li><p>过往创业背景</p>
<p>讲述了大佬的的创业经历，从一个只有 2 个人的团队，做到拿到 A 轮融资 500w 的一个小企业的过程（需要有个好看的 PPT）。<br>其中也并不是产品一次成型，每个方向都在不断试探，不断试错。<br>将客户首先定位在大学生群体，外卖，兼职，帮帮等等，<br>最后针对招聘这个方向开始重点发力。</p>
</li>
<li><p>创业中产品工作问题&amp;解决</p>
<p>期间拒绝阿里的 B 轮融资方案。最后只把希望寄托在一个客户机构上，没有 plan B，最后由于意外，导致最后资金链断裂，失败落幕。<br>所得的经验教训就是不能把企业的生死存亡寄托在其他人身上，在没有实锤之前，都给自己留一条后路。</p>
</li>
<li><p>产品常见错误</p>
<p>大佬总结之下大概分为 6 点：</p>
<ol>
<li>自嗨。<br>产品在想需求的过程中，有时候会自我感觉良好。<br>灵光一闪想到个 idea，感觉有了这个玩法，产品瞬间可以逆风翻盘，感动自己。<br>其实越兴奋的时候，越要冷静。<br>正常来说，产品可以说是在部门里话语权优先级很高的。<br>如果不做深思熟虑，只是拍脑门之下，研发便投入开发，销售开始地推，<br>最后很可能客户反应冷淡，远远没有达到预期，无形浪费成本。</li>
<li>一言堂。<br>一般是有绝对话语权的人易犯的错误。<br>很可能其他人都不统一他的观点，<br>这个时候他声音大，<br>其他人抱着不想和他争，抱着要不做着看看效果的心态敷衍了事，<br>最后出来的效果也未必会好。</li>
<li>节奏感<br>产品要有自身的节奏感。<br>对于产品方向和思路的把控，这是一个合格产品应该具备的条件。<br>那么如何带出产品的节奏感，这个是一个优秀产品的必备条件。</li>
<li>龟毛<br>强迫症发作，过度于纠结细致的东西，却失去了把控大局的思路。<br>比如这个按钮的位置。<br>高几像素还是矮几像素不会太影响大局，客户不会因为这个按钮歪了一点就不去使用我们的产品。<br>客户只会因为这个产品不好用，没办法解决自身痛点而放弃使用产品。</li>
<li>脱离客户<br>由于客户的需求是一个动态的，甚至客户自身都不知道他需要什么。<br>所以就需要做到经常去跟客户沟通。<br>如果做不到两周跟客户有过沟通，那就意味着已经脱离了客户。<br>既然都不知道客户的最新需求，自然就没办法做出打动客户的产品。</li>
<li>经验主义<br>这是一般老产品会犯下的错误。<br>一看到有类似场景，那么直接就想起之前做过的案例。<br>拿出以前的方案，直接生搬硬套，没有做到因地制宜。<br>所以结果也不会很乐观的。</li>
</ol>
</li>
<li><p>产品运营紧密协同</p>
<p>产品需求设计过程中，不是一个单向的流动，应该是双向的，也是需要有反馈的。<br>通过对产品功能的埋点，进而对客户的行为数据收集分析，<br>推测客户行为，通过数据驱动，进而推出下一步的方案。<br>以产品推销 VIP 会员为例。<br>强制蒙层弹窗可能大部分人看都不看直接叉掉，销售效果未必好。<br>通过后台的客户行为分析，在用户观看较多的页面，放置对应会员 VIP 的广告，<br>以及分批发放试用 VIP。<br>观察有试用 VIP 与没有使用 VIP 客户的行为差别。<br>观察 VIP 是否能够让客户感受得到便利。<br>进而对 VIP 的付费内容，以及推广策略进行调整。</p>
</li>
</ol>
<h3 id="会下交流"><a href="#会下交流" class="headerlink" title="会下交流"></a>会下交流</h3><p>创业公司的合伙人需要分工明确。<br>创立公司之初的团队组成。<br>设计产品，要保持初心。<br>代码会写出 bug，产品需求也会有 bug，所以需求有变动其实是可以理解的。</p>
<h3 id="所思所得"><a href="#所思所得" class="headerlink" title="所思所得"></a>所思所得</h3><p>听完这次分享会之后，<br>感觉目前公司的项目还是有很多地方需要优化的。<br>至少很多细节地方都没有打磨。<br>单就目前的每个版本的流程来说，就是一个单向流，<br>从市场销售捕获客户痛点，产品转化为需求，设计出稿，需求评审，技术评审，正式开发，验收转测，最后提审上线。<br>然后这样就结束了。<br>这一套流程下来，最后到客户手里反馈如何，却不了了之。<br>如何改善，也都是自身在凭空想象。</p>
<p>同时，埋点是一个项目很必备的功能。<br>从代码层级上来看，<br>如果每个地方到处复制粘贴，以后管理必将是一件麻烦事。<br>那么如何优雅的实现这个功能，<br>也是需要我们去思量的。</p>
<p>再就是在版本迭代的过程中，<br>新增功能是一个很容易的事情，不过更多考虑的是如何提高体验。<br>同样都能解决客户的痛点，<br>一个方案需要点 3 次，一个方案只需要点 2 次。<br>这样给客户带来的体验是完全不同的。</p>
<p>另外，要善于做减法。<br>把每一个做出来的功能都当成个宝贝一样保留着，最后只会让项目臃肿不堪。<br>其实对于已经通过客户行为数据验证过，对客户没有太大帮助的功能，是完全可以下掉删除的，<br>好的功能就全力发扬，不好的功能果断放弃。<br>这样既可以避免分散客户的注意力，也能提高自身产品的性能，从而提高用户体验。</p>
]]></content>
      <tags>
        <tag>产品运营</tag>
      </tags>
  </entry>
  <entry>
    <title>23.macOS本地搭建gitlab服务</title>
    <url>/2021/01/23/23-macOS%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0gitlab/</url>
    <content><![CDATA[<h3 id="搭建背景"><a href="#搭建背景" class="headerlink" title="搭建背景"></a>搭建背景</h3><p>有时候想要调试一些公司的项目，<br>不过公司的项目是没有办法传到 github 上的。<br>以免有泄漏的风险。<br>可是还需要借助 git 来管理，<br>于是乎，就诞生了本地搭建 gitlab 的想法。</p>
<p>另外，gitlab 还是功能蛮强大的，<br>拥有完善的权限管理系统，<br>集成 wiki 等相关功能，<br>以及具备 CI 持续集成、CD 持续部署等功能。<br>正好也借此机会玩一玩 gitlab ，完善一下自身搭建团队的技能树。</p>
<a id="more"></a>

<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><p>由于 gitlab 只能在 Linux 内核环境下部署。<br>手上也只有一台 MacBook 老爷机，<br>只好在上面再按照一个沙盒（虚拟机）了。</p>
<ol>
<li><p>下载<code>Docker Desktop</code>。<br>市面上大部分教程都是推荐使用<code>Docker Desktop</code>。<br>页面集成化界面操作，已经相对之前部署容易了很多。<br>并且注册一个<code>Docker Hub</code>账号。</p>
</li>
<li><p>下载<code>gitlab-ce</code>。<br>在仓库找到 gitlab-ce 并下载。 <a href="https://hub.docker.com/r/gitlab/gitlab-ce" target="_blank" rel="noopener">https://hub.docker.com/r/gitlab/gitlab-ce</a><br>不过网上教程有一键下载的方式，不过我没有找到，最后还是通过命令行给安装上了。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>

<p>大概 800MB 大小，干脆挂机一宿下载完的。</p>
</li>
<li><p>配置<code>gitlab</code></p>
<p>一早起来，就看到<code>Docker Desktop</code>的<code>Containers</code>里面已经静静的躺着个<code>gitlab/gitlab-ce</code>。<br>接下来就是按照教程配置 gitlab。<br>自带的 UI 页面有配置，不过依旧没有搞懂。<br>还是用命令行配置最简单。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo docker run -d \</span><br><span class="line"> <span class="params">--hostname</span> xxx.gitlab.com \</span><br><span class="line"> <span class="params">--name</span> gitlab \</span><br><span class="line"> <span class="params">--restart</span> always \</span><br><span class="line"> <span class="params">--publish</span> 22<span class="function">:22</span> <span class="params">--publish</span> 80<span class="function">:80</span> <span class="params">--publish</span> 443<span class="function">:443</span> \</span><br><span class="line"> <span class="params">--volume</span> <span class="string">/Users/xxx/gitlab/config</span>:<span class="string">/etc/gitlab</span> \</span><br><span class="line"> <span class="params">--volume</span> <span class="string">/Users/xxx/gitlab/logs</span>:<span class="string">/var/log/gitlab</span> \</span><br><span class="line"> <span class="params">--volume</span> <span class="string">/Users/xxx/gitlab/data</span>:<span class="string">/var/opt/gitlab</span> \</span><br><span class="line"> gitlab/gitlab-ce<span class="function">:latest</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 gitlab<br>此刻通过浏览器输入：<a href="http://localhost:80/" target="_blank" rel="noopener">http://localhost:80/</a>，即可到登录页面。<br>第一次登录会让你输入超级管理员的密码。<br>账号：root。<br>这个账号是最高权限。可以通过这个账号对 gitlab 配置一切。</p>
</li>
<li><p>注册 gitlab 账号<br>不过我们也不能一直用着 root 就去开发。<br>那也也未免太过霸气侧漏了。<br>我们还是需要注册一个自己开发用的账号。<br>让我们退出登录。<br>在刚刚登录页面重新注册一个属于自己的账号、密码、邮箱。<br>此时这个账号注册还不能被使用登录。<br>我们需要通过 root 账户，对刚刚注册的账号进行授权通过，<br>这样新注册的账号才能被使用。</p>
</li>
<li><p>配置 SSH-KEY<br>新账号在登录之后，需要配置 git 公钥。<br>通过命令行</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"xxx@mail.com"</span></span><br></pre></td></tr></table></figure>

<p>在<code>.ssh/</code>目录下会生成两个文件<code>id_rsa.pub</code>和<code>id_rsa</code>，<br>我们需要将<code>id_rsa.pub</code>文件内的内容复制到 gitlab 中 <code>SSH-KEY</code>输入框中即可。</p>
</li>
<li><p>搭建仓库<br>新建仓库，然后本地代码跟仓库相关联，跟 github 很相似了。在这里就不再赘述了。</p>
</li>
</ol>
<h3 id="踩坑相关"><a href="#踩坑相关" class="headerlink" title="踩坑相关"></a>踩坑相关</h3><ol>
<li><p>下载<code>gitlab-ce</code>真的是太慢了。<br>估计镜像资源也不怎么好。</p>
</li>
<li><p>登录 gitlab 的时候报错 502。<br>这个问题纠结了好久。<br>网上说的大部分情况都是端口冲突。<br>又是杀进程，又是改配置的，结果并没起作用。</p>
<p>最后想到，可能我是通过 docker 配置的 gitlab。<br>应该是给 docker 分配的资源太少，导致的报错。<br>解决方法是：<br>在 docker 的<code>设置(Preferences)</code>-&gt;<code>Resource</code>-&gt;<code>ADVANCED</code>。<br>将<code>Swap</code>调整到了 <code>3GB</code>。<br>不过为了保险起见，其他硬件参数也都调高一些。<br>将<code>Memory</code>调整到了 <code>3.00GB</code></p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来以为是一个很简单的事情，<br>结果也折腾来折腾去的搞了大半天。<br>不过终于搭建好仓库的时候，<br>还是很嗨皮的。<br>接下来有时间的时候可以好好玩一玩 CI 了~</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://billqiu.github.io/2016/07/08/%E5%9C%A8mac%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2gitlab/" target="_blank" rel="noopener">在 mac 上使用 docker 部署 gitlab</a></li>
<li><a href="http://comdyn.hy.tsinghua.edu.cn/from-web/mac-os/570-docker-gitlat" target="_blank" rel="noopener">基于 Docker 在 Mac OS X 系统中的部署和设置 GitLab</a></li>
<li><a href="https://blog.csdn.net/rex1129/article/details/110119830" target="_blank" rel="noopener">Docker gitlab 502 解决办法</a></li>
<li><a href="https://blog.csdn.net/ianly123/article/details/82984736" target="_blank" rel="noopener">自建 gitlab 服务器以及出现 502 错误解决方案</a></li>
<li><a href="https://blog.csdn.net/top_code/article/details/50381432" target="_blank" rel="noopener">调整 git 仓库的连接地址</a></li>
<li><a href="https://www.cnblogs.com/micrari/p/5659036.html" target="_blank" rel="noopener">多个 git 账号的 SSH 配置</a></li>
</ol>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>3.关于Taro框架中Redux的使用方法</title>
    <url>/2020/06/20/3-%E5%85%B3%E4%BA%8ETaro%E6%A1%86%E6%9E%B6%E4%B8%ADRedux%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="关于Redux"><a href="#关于Redux" class="headerlink" title="关于Redux"></a>关于Redux</h3><p>个人认为，一些轻量级的项目是完全用不到Redux。<br>简单的单例出一个全局变量管理器，就可以满足项目的需要。<br>不过如果项目一旦沉重起来，需求逻辑繁琐，父子组件通讯错综复杂，<br>开发人员思路又不统一，<br>这个时候如果只是使用全局变量管理，<br>那么数据随时都可能被更改，全局变量将会成为一团乱麻，变得不可被信任。<br>项目的迭代和维护成本也将会迎来指数级的上升，<br>如果这个时候能有一个全局的对象，<br>可随时被观察状态，只能用特殊方式修改状态，<br>将会对项目的维护非常有帮助。<br>而这也就是Redux。  </p>
<a id="more"></a>

<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://taro-docs.jd.com/taro/docs/redux/" target="_blank" rel="noopener">Taro的Redux官方文档</a></p>
<h3 id="Redux数据流程图"><a href="#Redux数据流程图" class="headerlink" title="Redux数据流程图"></a>Redux数据流程图</h3><p>借用网上流传的图片，发现有个箭头的遗漏，<br>一切起源是因为组件触发了action，<br>才引发了这一系列的流程。<br><img src="/images/image_3_1.jpg" alt="Redux数据流程图"></p>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ol>
<li><p>准备好仓库state。（只操作一次，聚合所有数据）  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createLogger &#125; <span class="keyword">from</span> <span class="string">'redux-logger'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'../reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = [</span><br><span class="line">  thunkMiddleware,</span><br><span class="line">  createLogger()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configStore</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer, applyMiddleware(...middlewares));</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备一个数据对象。<br>举个例子，我准备将主页的相关信息都存储在仓库的这个对象里MainPageInfo。<br>所以我会创建3个文件。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../actions/MainPageInfo.ts    <span class="comment"># 做逻辑处理</span></span><br><span class="line">../constants/MainPageInfo.ts  <span class="comment"># 更新Redux标记</span></span><br><span class="line">../reducers/MainPageInfo.ts   <span class="comment"># 小片段的数据，处理数据，更新数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>准备好对这个对象操作的指令代号。<br>我会将指令代号以及类型声明存放在这个文件中。<br>../actions/MainPageInfo.ts  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切换主页底部导航</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_MAIN_PAGE_SELECT: <span class="built_in">string</span> = <span class="string">'SET_MAIN_PAGE_SELECT'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> MainPageInfoType = &#123;</span><br><span class="line">  nSelectIndex: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备对这个对象的行动。<br>我会将所需要的操作存放在这个文件中。<br>../actions/MainPageInfo.ts  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  SET_MAIN_PAGE_SELECT</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@/constants/MainPageInfo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setMainPageSelect</span> (<span class="params">nSelectIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: SET_MAIN_PAGE_SELECT,</span><br><span class="line">    nMainPageSelect: nSelectIndex</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setMainPageSelect,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备对这个对象数据的改动。<br>我会将操作之后的数据改动放在这个文件中。<br>../reducers/MainPageInfo.ts  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  SET_MAIN_PAGE_SELECT</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@/constants/MainPageInfo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INITIVAL_STATE = &#123;</span><br><span class="line">  nSelectIndex: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MainPageInfo</span> (<span class="params">state = INITIVAL_STATE, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_MAIN_PAGE_SELECT:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        nSelectIndex: action.nMainPageSelect</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备阶段完毕<br>那么准备阶段完毕，<br>我可以通过setMainPageSelect方法传入的参数，<br>来修改store.MainPageInfo.nSelectIndex<br>而此时我的期望数据结构就会是这样。  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">store = &#123;</span><br><span class="line">  MainPageInfo: &#123;</span><br><span class="line">    nSelectIndex: <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Taro中运用<br>其实TS近乎强迫症的语法，在这一步折腾了好久，不断的在语法错误提示中挣扎。<br>在参考了多方资料之后，总算摸索出来一套不再错误提示的写法。<br>示例是用最基本的方法来操作Redux。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; </span><br><span class="line">  connect </span><br><span class="line">&#125; from &#39;@tarojs&#x2F;redux&#39;;</span><br><span class="line">import &#123; </span><br><span class="line">  MainPageInfoType </span><br><span class="line">&#125; from &#39;@&#x2F;constants&#x2F;MainPageInfo&#39;;</span><br><span class="line">import &#123; </span><br><span class="line">  setMainPageSelect,</span><br><span class="line">&#125; from &#39;@&#x2F;actions&#x2F;MainPageInfo&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型声明：传递过来的变量</span><br><span class="line">type PageStateProps &#x3D; &#123;</span><br><span class="line">  MainPageInfo: MainPageInfoType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型声明：传递过来的dispatch方法</span><br><span class="line">type PageDispatchProps &#x3D; &#123;</span><br><span class="line">  setMainPageSelect: (nSelectIndex: number) &#x3D;&gt; any;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型声明：传递过来的普通方法</span><br><span class="line">type PageOwnProps &#x3D; &#123; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型声明：组件内变量</span><br><span class="line">type PageState &#x3D; &#123; &#125;;</span><br><span class="line"></span><br><span class="line">type IProps &#x3D; PageStateProps &amp; PageDispatchProps &amp; PageOwnProps;</span><br><span class="line"></span><br><span class="line">type IState &#x3D; PageState;</span><br><span class="line"></span><br><span class="line">@connect(</span><br><span class="line">  (&#123; MainPageInfo &#125;) &#x3D;&gt; (&#123;</span><br><span class="line">    MainPageInfo</span><br><span class="line">  &#125;),</span><br><span class="line">  dispatch &#x3D;&gt; (&#123;</span><br><span class="line">    setMainPageSelect (nSelectIndex: number) &#123;</span><br><span class="line">      dispatch(setMainPageSelect(nSelectIndex));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">export default class Main extends Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 测试按钮</span><br><span class="line">  handleTestClick () &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      MainPageInfo,</span><br><span class="line">      setMainPageSelect</span><br><span class="line">    &#125; &#x3D; this.props;</span><br><span class="line">    console.log(&#39;handleTestClick before.&#39;, MainPageInfo);</span><br><span class="line">    setMainPageSelect(9999);</span><br><span class="line">    console.log(&#39;handleTestClick after.&#39;, MainPageInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; </span><br><span class="line">  render () &#123;</span><br><span class="line">    (</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不能直接的去修改store中的数据，<br>我们可以触发handleTestClick，<br>通过dispatch，调用setMainPageSelect方法，<br>来对store.MainPageInfo.nSelectIndex的数值进行修改。  </p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>前端的框架语法更新很快，<br>React 16.8版本新增了React Hook的写法。<br>这也让操作Redux的方式更加灵活了。<br>我会在接下来的时间里研究一下Hook的写法，整理出来。  </p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>4.关于Taro框架中装饰器的使用方法</title>
    <url>/2020/06/21/4-%E5%85%B3%E4%BA%8ETaro%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="关于装饰器"><a href="#关于装饰器" class="headerlink" title="关于装饰器"></a>关于装饰器</h3><p>装饰器模式是在不影响原来的类/方法/属性的基础上，<br>增加的新功能的方式。<br>一般可以运用在权限校验、日志打印、性能测验、属性保护、节流防抖、耦合度低的重复性工作（加积分）等等……<br>或者说，你干脆不想动别人写的代码，免得背锅，<br>这个时候就可以通过装饰器模式进行改造。</p>
<a id="more"></a>

<h3 id="装饰器的几种模式"><a href="#装饰器的几种模式" class="headerlink" title="装饰器的几种模式"></a>装饰器的几种模式</h3><ol>
<li><p>对类进行的装饰<br>以类为单元，可以对类中的声明周期，以及所有类中的属性和方法进行装饰。<br>虽然都能够包括在内，不过以类为单元过于庞大，<br>需要做精准的筛选和操作。<br>而 Taro 可能是因为框架的原因，只能够修饰类，其他两种方式都不能被使用，所以只能硬着头皮去装饰类。</p>
</li>
<li><p>对方法进行的装饰<br>这个用起来比较精准，用起来比较顺眼，便于理解，<br>也是常用的装饰器模式。</p>
</li>
<li><p>对属性进行的装饰<br>同时，装饰器也能装饰一些变量，<br>比如给某个变量增加只读的属性，<br>这样如果无意间修改了变量，编译器也能做出对应的提示。</p>
</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>装饰模式装饰类的实现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Demo装饰器示例</span></span><br><span class="line"><span class="comment">// 功能在类中所有方法前后都打印Log，并且屏蔽指定的方法，替换成输出数字。</span></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="comment">// @Demo(['componentDidMount'], 123)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">arrFunc: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [], num: <span class="built_in">Number</span> = 9999</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Demo Params"</span>, &#123; target, key, descriptor, arrFunc, num &#125;);</span><br><span class="line">    <span class="keyword">if</span> (target.prototype) &#123;</span><br><span class="line">      <span class="comment">// 拷贝对象，获取类中的所有方法</span></span><br><span class="line">      <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(target.prototype);</span><br><span class="line">      <span class="comment">// 遍历该对象中所有方法</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key of <span class="built_in">Object</span>.keys(desc)) &#123;</span><br><span class="line">        <span class="keyword">const</span> func = desc[key].value;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> func === <span class="string">"function"</span>) &#123;</span><br><span class="line">          <span class="comment">// 修改对象的现有属性key，并且返回这个对象</span></span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(target.prototype, key, &#123;</span><br><span class="line">            value(...args: <span class="built_in">any</span>[]) &#123;</span><br><span class="line">              <span class="comment">// 指定方法则屏蔽原方法，打印个参数</span></span><br><span class="line">              <span class="keyword">if</span> (arrFunc &amp;&amp; arrFunc.indexOf(key) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> - <span class="subst">$&#123;num&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 其他方法 装饰前后log</span></span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> - before.`</span>);</span><br><span class="line">              <span class="keyword">const</span> res = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> - after.`</span>);</span><br><span class="line">              <span class="keyword">return</span> res;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Demo;</span><br></pre></td></tr></table></figure>

<p>Taro 的装饰器使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Throttle &#125; from &#39;@&#x2F;kits&#x2F;decorator&#x2F;index&#39;;</span><br><span class="line"></span><br><span class="line">@Demo([&#39;componentDidMount&#39;], 123)</span><br><span class="line">export default class AvatarModule extends Component &#123;</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  render () &#123;</span><br><span class="line">    (</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>话说，刚刚说过的 Redux 的 connect 其实也是装饰器的实现。<br>另外，装饰器其实也是高阶函数的一种实现，<br>那么通过 Hook 的方法也能够实现类似装饰器带来的效用。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>设计模式</tag>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title>5.阻止Taro框架中的事件冒泡</title>
    <url>/2020/06/22/5-%E9%98%BB%E6%AD%A2Taro%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h3 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h3><p>在书写Taro的一个弹窗组件的时候，<br>在弹窗按钮和蒙层分别绑定了点击事件。<br>结果点击按钮的时候，<br>蒙层事件也被触发了。<br>这个就是事件冒泡很正常的事情，  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.stopPropagation();</span><br></pre></td></tr></table></figure>
<p>本以为阻止一下就可以了，<br>结果发现并不好用。  </p>
<a id="more"></a>

<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>网上找了很多文档都是这么说的，<br>后来在一条评论下面找到了答案。<br>原因是我绑定事件的写法不对。<br>正确的写法应该是。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onClick&#x3D;&#123;this.handleMaskClick.bind(this)&#125;</span><br></pre></td></tr></table></figure>
<p>参考代码  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 点击蒙板</span><br><span class="line">handleMaskClick (e: Event) &#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  console.log(&#39;handleMaskClick&#39;);</span><br><span class="line">  this.setShow(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击登录按钮</span><br><span class="line">handleLoginClick (e: Event) &#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  console.log(&#39;handleLoginClick&#39;);</span><br><span class="line">  this.setShow(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      m_isShow</span><br><span class="line">    &#125; &#x3D; this.state;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;View className&#x3D;&#39;login-dialog-wrap&#39;&gt;</span><br><span class="line">        &lt;View </span><br><span class="line">          className&#x3D;&#39;login-dialog-mask&#39;</span><br><span class="line">          onClick&#x3D;&#123;this.handleMaskClick.bind(this)&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;View className&#x3D;&#123;classNames(m_isShow ? </span><br><span class="line">                                      &#39;fade-in-from-btottom login-dialog-content&#39; : </span><br><span class="line">                                      &#39;fade-out-from-btottom login-dialog-content&#39;)&#125;</span><br><span class="line">          &gt;</span><br><span class="line">              &lt;View className&#x3D;&#39;content-text&#39;&gt;</span><br><span class="line">                登录后即可体验更多服务</span><br><span class="line">              &lt;&#x2F;View&gt;</span><br><span class="line">              &lt;Button </span><br><span class="line">                className&#x3D;&#39;content-button&#39;</span><br><span class="line">                openType&#x3D;&#39;getUserInfo&#39;</span><br><span class="line">                onClick&#x3D;&#123;this.handleLoginClick.bind(this)&#125;</span><br><span class="line">              &gt;</span><br><span class="line">                微信登录</span><br><span class="line">              &lt;&#x2F;Button&gt;</span><br><span class="line">            &lt;&#x2F;View&gt;</span><br><span class="line">        &lt;&#x2F;View&gt;</span><br><span class="line">      &lt;&#x2F;View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>虽然Taro是一个能够多端开发，跨平台的优秀框架，<br>不过不知道是不是菜鸟手生的缘故，<br>总是感觉遇到了很多奇奇怪怪的坑。<br>比如这个阻止事件冒泡，<br>还有不能使用修饰方法的装饰器什么的，<br>反正踩着踩着，<br>也就习惯了。  </p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title>6.记录修改Redux后没有触发渲染的问题</title>
    <url>/2020/06/30/6-%E8%AE%B0%E5%BD%95%E4%BF%AE%E6%94%B9Redux%E5%90%8E%E6%B2%A1%E6%9C%89%E8%A7%A6%E5%8F%91%E6%B8%B2%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h3><p>由于刚开始熟悉Taro + Redux + Hook的技术栈，<br>开发过程中有时候用的还很蹩脚，<br>出现了很多问题，也踩了许多坑。<br>今天就遇到这么个问题，<br>页面是根据Redux中的数据来渲染的，<br>可是明明已经修改了Redux的数据，<br>而且redux-logger也打印出来日志了，<br>页面却没有重新刷新渲染。  </p>
<a id="more"></a>

<h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>由于技术栈的不熟悉，想过了很多可能性，<br>比如：需要主动触发刷新函数、Hook的底层实现不一样等等……<br>疯狂的确认constants、reducers、actions这一流程的书写方式。<br>也尝试调用其他可以实现渲染有效的actions来找异同点。<br>最终还是通过日志发现了一些端倪。  </p>
<p><strong>不渲染的日志</strong><br>本意是将两个数组长度从5,2 改变成4,3。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">action POP_MODULE_SETTING_INFO</span><br><span class="line">prev state</span><br><span class="line">ModuleSettingInfo: &#123;</span><br><span class="line">  ...</span><br><span class="line">  arrShowModuleInfo: <span class="built_in">Array</span>(<span class="number">4</span>), </span><br><span class="line">  arrHideModuleInfo: <span class="built_in">Array</span>(<span class="number">3</span>),</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">action</span><br><span class="line">type: <span class="string">"POP_MODULE_SETTING_INFO"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">next state</span><br><span class="line">ModuleSettingInfo: &#123;</span><br><span class="line">  ...</span><br><span class="line">  arrShowModuleInfo: <span class="built_in">Array</span>(<span class="number">4</span>), </span><br><span class="line">  arrHideModuleInfo: <span class="built_in">Array</span>(<span class="number">3</span>),</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可是日志记录的是从4,3 改变成4,3。<br>那么是不是因为数据没有变化，所以没有触发渲染。<br>可是数据又是什么时候被改成4,3了呢？  </p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>代码此处的逻辑是，<br>通过Hook的useSelector，<br>来获取到Redux中的ModuleSettingInfo。<br>对取到的ModuleSettingInfo直接修改后，<br>使之作为参数再执行了action。  </p>
<p>简单的来说，我修改了两次。<br>第一次是直接因为浅拷贝，引用到那块内存给修改了，<br>第二次是使用Redux的action，通过正规操作又修改一次。<br>也是因为这次action日志被打印出来了，<br>不过因为第二次修改的时候，数值已经被修改过了，<br>所以日志的prev state和next state数值是一样的。<br>这样即使执行了action，因为数值没有变化，所以就没有触发页面的渲染。  </p>
<p><strong>错误的代码</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 找到移出项将其剔除</span><br><span class="line">const arrItemTmp &#x3D; arrShowModuleInfo.splice(nModuleItemIndex, 1); </span><br><span class="line">&#x2F;&#x2F; 将移出项塞入隐藏列表数组</span><br><span class="line">arrHideModuleInfo.unshift(arrItemTmp[0]);</span><br><span class="line">&#x2F;&#x2F; 结果存入redux并渲染</span><br><span class="line">popModuleSettingInfo(&#123;</span><br><span class="line">  arrShowModuleInfo,</span><br><span class="line">  arrHideModuleInfo</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>修改后的代码</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将Redux取到的对象深拷贝</span><br><span class="line">const arrShowModuleInfoTmp &#x3D; JSON.parse(JSON.stringify(arrShowModuleInfo));</span><br><span class="line">const arrHideModuleInfoTmp &#x3D; JSON.parse(JSON.stringify(arrHideModuleInfo));</span><br><span class="line">&#x2F;&#x2F; 找到移出项将其剔除</span><br><span class="line">const arrItemTmp &#x3D; arrShowModuleInfoTmp.splice(nModuleItemIndex, 1); </span><br><span class="line">&#x2F;&#x2F; 将移出项塞入隐藏列表数组</span><br><span class="line">arrHideModuleInfoTmp.unshift(arrItemTmp[0]);</span><br><span class="line">&#x2F;&#x2F; 结果存入redux并渲染</span><br><span class="line">popModuleSettingInfo(&#123;</span><br><span class="line">  arrShowModuleInfo: arrShowModuleInfoTmp,</span><br><span class="line">  arrHideModuleInfo: arrHideModuleInfoTmp</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h3><p>今天在做代码review的时候，<br>发现了一个很好的办法，<br>就是通过引用 <strong>immer</strong> 这个库。<br>Immer是mobx的作者写的一个immutable库，<br>核心实现是利用ES6的proxy，<br>几乎以最小的成本实现了js的不可变数据结构。  </p>
<p>简单的来说就是，想要修改一个对象，<br>如果直接修改，就会修改对象本身，<br>如果深拷贝之后再修改，就比较影响性能。<br>那么Immer的神奇之处就是只会对有变化的数值做深拷贝，<br>而没有变的地方还依然保持旧的引用，<br>以这种巧妙的方式杜绝了修改引用的副作用。  </p>
<p>引用网上的一个很透彻的说法，<br>“immer的copy-on-write是一个非常有意思的技术。它的思想在于当某个资源被多个实例使用，仅仅在改变值的时候，才copy出一个副本，否则都引用原始对象。”  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i --save immer</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">'immer'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不影响原来obj对象，且还能返回修改后的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funTest</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> produce(obj, <span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">    draft.x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> draft</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这个问题，总得来说还是对Taro、Redux、Hook的一些东西不熟悉。<br>这就让在定位问题的时候比较浪费时间，<br>怀疑自身Hook的使用方法、怀疑Redux的写法、<br>怀疑Hook底层实现、怀疑小程序的实现机制、<br>怀疑Taro的版本更新不靠谱等等……<br>结果，却是因为自身的Redux用法错误。  </p>
<p>好在最后终于找到问题，并且解决了。<br>附上正确的日志做个纪念。  </p>
<p><strong>实现渲染的日志</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">action POP_MODULE_SETTING_INFO</span><br><span class="line">prev state</span><br><span class="line">ModuleSettingInfo: &#123;</span><br><span class="line">  ...</span><br><span class="line">  arrShowModuleInfo: Array(5), </span><br><span class="line">  arrHideModuleInfo: Array(2),</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">action</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"POP_MODULE_SETTING_INFO"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">next state</span><br><span class="line">ModuleSettingInfo: &#123;</span><br><span class="line">  ...</span><br><span class="line">  arrShowModuleInfo: Array(4), </span><br><span class="line">  arrHideModuleInfo: Array(3),</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
        <tag>Hook</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>7.通过Shell脚本实现本地自动打包上传</title>
    <url>/2020/07/05/7-%E9%80%9A%E8%BF%87Shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h3 id="背景痛点"><a href="#背景痛点" class="headerlink" title="背景痛点"></a>背景痛点</h3><p>在开发流程中的测试阶段，<br>当测试完一批bug单，就需要去打一个最新版的体验码，<br>来配合测试去检验新的一批bug单。<br>打体验码的话，需要那个人现将写到一半的代码git stash，<br>开始编译打包。（2次平台版、专属版）  </p>
<p>在持续集成系统没有搭建完毕的时候，<br>可以临时写一个脚本，来完成繁琐的打包上传工作。  </p>
<a id="more"></a>

<h3 id="脚本功能"><a href="#脚本功能" class="headerlink" title="脚本功能"></a>脚本功能</h3><p>通过shell脚本来实现平台版和专属版小程序自动打包的功能。<br>只需要在拉取最新代码后，执行脚本，输入版本号/版本备注，<br>即可实现一键对平台版/专属版，两套代码的自动编译，<br>利用微信cli接口来实现打包上传。<br>每次打体验码时间大概可以控制在5分钟以内。  </p>
<h3 id="脚本思路"><a href="#脚本思路" class="headerlink" title="脚本思路"></a>脚本思路</h3><ol>
<li>校验入参合法性。版本号的规则正则校验。  </li>
<li>兼容Window和mac系统，适配两个系统的路径。  </li>
<li>修改小程序标识位，设置为专属版标识。  </li>
<li>编译代码。  </li>
<li>修改开发者工具appid。  </li>
<li>上传代码</li>
<li>重复3-6步骤，将小程序标识位设置为平台版。  </li>
</ol>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ol>
<li><p>macOS:<br>&lt;安装路径&gt;/Contents/MacOS/cli  </p>
</li>
<li><p>Windows:<br>配置环境变量 WECHAT_DEVTOOL_PATH_CLI: &lt;安装路径&gt;/cli.bat<br>※ 确保安装路径不能有空格！<br>重启电脑以应用环境变量<br>配置nodejs / npm / wepy环境  </p>
</li>
<li><p>微信开发者工具配置:<br>设置 -&gt; 安全设置 -&gt; 服务端口<br>设置为：开启  </p>
</li>
</ol>
<h3 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h3><ol>
<li>目前脚本只是调用写死的APPID，未来可以优化动态读取ext.json内的APPID。  </li>
</ol>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="/assets/assets_7_1.sh">小程序本地自动打包脚本</a></p>
]]></content>
      <categories>
        <category>projects</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>Shell</tag>
        <tag>Wepy</tag>
      </tags>
  </entry>
  <entry>
    <title>8.解决Taro里面滚动穿透的问题</title>
    <url>/2020/07/05/8-%E8%A7%A3%E5%86%B3Taro%E9%87%8C%E9%9D%A2%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h3><p>最近的项目在用Taro重构代码，<br>接到个令人头秃的交互，通过拖拽栏目来改变排序顺序。<br>好在小程序和Taro框架，<br>已经封装了<strong>MovableArea</strong>和<strong>MovableView</strong>这俩标签，能降低点难度。<br>不过还是需要通过计算来定位位置，让我这个学酥瑟瑟发抖。  </p>
<p>结果实现到最后的时候，遇到了个大坑，<br>就是滚动穿透的问题。<br>效果就是，当这边拖拽着栏目的时候，结果页面也跟着一起滚动。<br>也是醉了。  </p>
<a id="more"></a>

<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>首先，想到的就是事件拦截，<br>比如阻止事件冒泡，结果拦截也木有用，<br>或者用原生小程序catchtouchmove来绑定事件，<br>结果直接语法报错，一脸懵逼。  </p>
<p>其次，就百度谷歌，<br>网上也有一些解决方法，<br>不过在我这里唯一生效的方法，就是靠样式生生阻止了滚动，<br>虽然感觉这个方法有些奇葩，<br>但是目前也就先采用这个方案了。  </p>
<p>最后，就是禁用iOS系统特有的屏幕滚动特效。<br>不禁用采取默认值的话，<br>iOS机型的屏幕依旧滚动的很魔性。  </p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>在最外层的View增加样式，<br>通过是否处于点击状态变量标识，来改变样式。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View className&#x3D;&#123;&#96;$&#123;isTouch ? &#39;scroll-lock&#39;: &#39;scroll-unlock&#39;&#125;&#96;&#125;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.scroll-lock</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>; </span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scroll-unlock</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>; </span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>禁用iOS系统特有的屏幕滚动特效。<br>页面级新建文件 ./index.config.ts  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  disableScroll: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>话说Taro论坛也没有相关的介绍，<br>感觉这个问题应该是比较常见啊。<br>不知道是不是我找错位置了。  </p>
<p>而且，另外有种感觉就是React系框架写东西很吃力，<br>也是自己不太熟悉的原因吧。  </p>
<p>如果让我比喻的话（狗头保命勿喷），<br>Vue系的框架，像是一盘快餐，像是自动挡的车，<br>可以快速的满足需求，很多都是傻瓜式操作，<br>框架默认帮助自己做了很多东西，<br>这样缺点就是会导致代码可优化空间也会很有限，<br>当项目做大会觉得后继无力。  </p>
<p>React系的框架，像是一顿正餐，像是手动挡的车，<br>煎炸烹煮都可以开发者自由的选择，<br>自由度高，可操作性比较复杂，<br>正因为如此，<br>导致项目差异会很大，想充分驾驭React就需要更多的知识储备，<br>高手和菜鸟写出来的东西完全是两种效果。  </p>
<p>前端就是一个这样的生态环境吧，<br>框架迭代频繁，<br>逆水行舟，不进则退。<br>每天只有不断地学习，才能不会被后浪拍在沙滩上吧。  </p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title>9.关于Taro中常用Hook的用法</title>
    <url>/2020/07/09/9-%E5%85%B3%E4%BA%8ETaro%E4%B8%AD%E5%B8%B8%E7%94%A8Hook%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="关于-Hook"><a href="#关于-Hook" class="headerlink" title="关于 Hook"></a>关于 Hook</h3><p>Hook 这个特性，是 React16.8 中新增的，<br>随着小程序框架 Taro 对 React 的支持，<br>让 Taro 也能开始使用，<br>甚至在 Taro3.0.0 开始，在底层 api 做了代理，<br>让 Hook 方法直接可以从 React 包中引用。<br>值得注意的是，<br>Hook 的方法，只能在函数组件的主体内部调用。</p>
<a id="more"></a>

<h3 id="React-系的-Hook"><a href="#React-系的-Hook" class="headerlink" title="React 系的 Hook"></a>React 系的 Hook</h3><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>由于函数式组件每次渲染都会执行一次函数，<br>那么函数内的变量是无法被保存住的。<br>所以如果想要将数据保存住的话，<br>需要使用这个 Hook，来将数据存储起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [nCount, setCount] &#x3D; useState&lt;number&gt;(0);</span><br><span class="line">&#x2F;&#x2F; 使用nCount</span><br><span class="line">console.log(&quot;nCount&quot;, nCount);</span><br><span class="line">&#x2F;&#x2F; 更新Count</span><br><span class="line">setCount(nCount++);</span><br></pre></td></tr></table></figure>

<h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>这个 Hook 可谓是最常用的方法，<br>同时也是一个很危险的 Hook，<br>因为他可以模拟出来 3 种以类方式 React 的声明周期。</p>
<ul>
<li>可以模拟刚加载页面或者组件的声明周期 <strong>componentsDidMount</strong></li>
<li>可以模拟销毁页面或者组件的声明周期 <strong>componentsWillUnmount</strong></li>
<li>如果有依赖项 <strong>deps</strong> 的时候，那么就会监听 <strong>deps</strong> 中的数据，一旦数据有变化，则也会执行一次函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; componentsDidMount</span><br><span class="line">  &#x2F;&#x2F; componentsDidUpdate</span><br><span class="line">  return () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; componentsWillUnmount</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [deps]);</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<br>正因为会检测数值变化，就会执行一次函数，<br>所以如果在函数内又修改了该数值，<br>就会很容易产生死循环，<br>所以要谨慎的对书写函数内的逻辑。</p>
<p>那么，你也应该发现了，<br>这个函数也是一个闭包，内部的数据存在于独立的存储空间，<br>内部的数据永远都只会是第一次创建时候的数据。<br>如果需要跟外接数据同步，就需要将想同步的变量加入依赖 <strong>deps</strong> 中，<br>这样变量发生变化一次之后，内部闭包函数重新调用一次以更新数据。</p>
<h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><h4 id="useCallBack"><a href="#useCallBack" class="headerlink" title="useCallBack"></a>useCallBack</h4><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>将数据绑定到页面节点之上，<br>该数据的范围提升到一个页面级的纬度。<br>同时也可以帮助父组件拿到子组件属性。</p>
<h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h4><p>父组件的数据传递给子组件。<br>先要 createContext,<br>通过 Provider 标签传递 value，<br>在子组件里 useContext 拿到传递下来的 value。</p>
<hr>
<h3 id="Taro-系（小程序专用）的-Hook"><a href="#Taro-系（小程序专用）的-Hook" class="headerlink" title="Taro 系（小程序专用）的 Hook"></a>Taro 系（小程序专用）的 Hook</h3><p>这些 Hook 对开发过小程序的小伙伴应该是非常友好的了。</p>
<h4 id="useDidShow"><a href="#useDidShow" class="headerlink" title="useDidShow"></a>useDidShow</h4><p>页面再度激活，<br>返回或者切回前台的生命周期，<br>等同于 <strong>onShow(componentDidShow)</strong></p>
<h4 id="useDidHide"><a href="#useDidHide" class="headerlink" title="useDidHide"></a>useDidHide</h4><p>切到后台，页面隐藏的生命周期，<br>等同于 <strong>onHide(componentDidHide)</strong></p>
<h4 id="usePullDownRefresh"><a href="#usePullDownRefresh" class="headerlink" title="usePullDownRefresh"></a>usePullDownRefresh</h4><p>下拉刷新的生命周期，<br>等同于 <strong>onPullDownRefresh</strong></p>
<h4 id="useReachBottom"><a href="#useReachBottom" class="headerlink" title="useReachBottom"></a>useReachBottom</h4><p>页面拉到底部的生命周期，<br>等同于 <strong>onReachBottom</strong></p>
<h4 id="usePageScroll"><a href="#usePageScroll" class="headerlink" title="usePageScroll"></a>usePageScroll</h4><p>页面发生滚动的生命周期，<br>等同于 <strong>onPageScroll</strong></p>
<h4 id="useResize"><a href="#useResize" class="headerlink" title="useResize"></a>useResize</h4><p>页面尺寸发生变化的生命周期，<br>等同于 <strong>onResize</strong></p>
<h4 id="useShareAppMessage"><a href="#useShareAppMessage" class="headerlink" title="useShareAppMessage"></a>useShareAppMessage</h4><p>分享的生命周期，<br>等同于 <strong>onShareAppMessage</strong></p>
<h4 id="useRouter"><a href="#useRouter" class="headerlink" title="useRouter"></a>useRouter</h4><p>获取路由信息。<br>等同于 <strong>getCurrentInstance().router</strong></p>
<h4 id="useReady"><a href="#useReady" class="headerlink" title="useReady"></a>useReady</h4><p>页面节点加载完毕的生命周期，<br>等同于 <strong>onReady</strong></p>
<h3 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h3><h4 id="useXXXX"><a href="#useXXXX" class="headerlink" title="useXXXX"></a>useXXXX</h4><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实，我自身对 Hook 的语法也是刚刚接触，<br>可能有些理解不是很深刻，也比较懵懂。<br>那么随着自身对这些 Hook 的理解，<br>我也会对这篇文章的内容不断更新。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>React</tag>
        <tag>Taro</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>21.自定义Hook分页加载的实现</title>
    <url>/2021/01/03/21-%E8%87%AA%E5%AE%9A%E4%B9%89Hook%E5%88%86%E9%A1%B5%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="痛点分析"><a href="#痛点分析" class="headerlink" title="痛点分析"></a>痛点分析</h3><p>在实际业务开发的过程中，<br>有很多关于长列表分页加载的场景。<br>比如 feed 信息流，数据统计，成员设置等等。<br>那么如果每个页面都单独写一套长列表分页加载的逻辑，<br>代码重复臃肿，且每个页面实现方式不一样。<br>很难统一管理。</p>
<p>而 Hook 的概念，可以使你在无需修改组件结构的情况下复用状态逻辑。<br>所以才有了封装分页加载 useQueryPageList 的想法。</p>
<a id="more"></a>

<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>那么封装一个功能，<code>入参</code>与<code>返回值</code>都是必要的。<br><code>入参</code>就是：<br>需要调用的接口函数、以及对应的传入参数。<br><code>返回值</code>就是：<br>用以展示的列表数据，以及总条数。</p>
<p>所以在 useQueryPageList 里面同时需要使用生命周期：<br><code>useEffect</code>监听 funFetchApi、param 其中之一发生变化：重新请求一次第一分页（第一次进入页面通过此处获取数据）<br><code>useEffect</code>监听 isUpdateList 变化：用于主动触发刷新的需求<br><code>useDidShow</code>onShow 生命周期：重新获取数据（注：第一次进入页面虽触发 onShow 不过不去执行获取数据操作）<br><code>useReachBottom</code>触底生命周期：加载下一分页数据<br><code>usePullDownRefresh</code>下拉刷新生命周期：重新加载第一分页数据</p>
<p>同时我们需要绑定变量保存当前加载情况：<br><code>nPageNum</code>当前加载的分页编号<br><code>nPageSize</code>每组分页加载多少条数据<br><code>arrPageList</code>目前已经加载的数据</p>
<p><code>isInitComplate</code>是否初始化完毕<br><code>funFetchApiTmp</code>接口 API 的备份，用以判断是否有变化<br><code>paramTmp</code>接口入参的备份，用以判断是否有变化</p>
<p>最后在之前的三个声明周期分别触发回调函数，将获取到的分页数据返回即可。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>useQueryPageList.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123;</span><br><span class="line">  useDidShow,</span><br><span class="line">  useReachBottom,</span><br><span class="line">  usePullDownRefresh,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"@tarojs/taro"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> useDebounce <span class="keyword">from</span> <span class="string">"@/hooks/useDebounce"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PAGE_NUM_LOCK = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> PAGE_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param callback 获取到的列表数据回调函数</span></span><br><span class="line"><span class="comment"> * @param funFetchApi 请求数据的接口函数</span></span><br><span class="line"><span class="comment"> * @param param 请求数据的必要参数</span></span><br><span class="line"><span class="comment"> * @param isUpdateList 修改则主动触发onShow刷新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useQueryPageList = (</span><br><span class="line">  callback: <span class="built_in">any</span>,</span><br><span class="line">  funFetchApi: <span class="built_in">any</span> = <span class="literal">null</span>,</span><br><span class="line">  param: <span class="built_in">any</span> = &#123;&#125;,</span><br><span class="line">  isUpdateList: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> nPageNum = useRef&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> nTotalCount = useRef&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> arrPageList = useRef&lt;<span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;&gt;([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isInitComplate = useRef&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> funFetchApiTmp = useRef(<span class="literal">undefined</span>);</span><br><span class="line">  <span class="keyword">const</span> paramTmp = useRef(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nPageSize = param.nPageSize ? param.nPageSize : PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 统一处理接口返回数据</span></span><br><span class="line"><span class="comment">   * @param res</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> dealFetchResult = <span class="function">(<span class="params">res: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> list = res?.data ? res.data : [];</span><br><span class="line">    <span class="keyword">const</span> totalCount =</span><br><span class="line">      res?.totalCount === <span class="literal">undefined</span></span><br><span class="line">        ? <span class="number">9999</span></span><br><span class="line">        : res?.totalCount</span><br><span class="line">        ? res?.totalCount</span><br><span class="line">        : <span class="number">0</span>;</span><br><span class="line">    nTotalCount.current = totalCount;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      list,</span><br><span class="line">      totalCount,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 统一返回结果数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> returnCallBack = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback &amp;&amp;</span><br><span class="line">      callback(&#123;</span><br><span class="line">        state: <span class="string">"RESULT"</span>,</span><br><span class="line">        list: arrPageList.current,</span><br><span class="line">        totalCount: nTotalCount.current,</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听funFetchApi、param其中之一发生变化：重新请求一次第一分页</span></span><br><span class="line"><span class="comment">   * 新增防抖操作，只取短时间内最后一次的请求结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useEffect(</span><br><span class="line">    useDebounce(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isNotUndefined =</span><br><span class="line">        !(funFetchApi === <span class="literal">undefined</span>) &amp;&amp; !(param === <span class="literal">undefined</span>);</span><br><span class="line">      <span class="keyword">const</span> isDiff =</span><br><span class="line">        funFetchApiTmp.current !== funFetchApi ||</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(paramTmp.current) !== <span class="built_in">JSON</span>.stringify(param);</span><br><span class="line">      <span class="keyword">if</span> (isNotUndefined &amp;&amp; isDiff) &#123;</span><br><span class="line">        funFetchApiTmp.current = funFetchApi;</span><br><span class="line">        paramTmp.current = param;</span><br><span class="line">        nPageNum.current = <span class="number">0</span>;</span><br><span class="line">        callback &amp;&amp; callback(&#123; state: <span class="string">"LOADING"</span> &#125;);</span><br><span class="line">        <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">          ...param,</span><br><span class="line">          nPageNum: nPageNum.current,</span><br><span class="line">          nPageSize: nPageSize,</span><br><span class="line">        &#125;;</span><br><span class="line">        funFetchApi &amp;&amp;</span><br><span class="line">          funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"useQueryPageList useUpdateApiOrParam"</span>, res);</span><br><span class="line">            <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">            arrPageList.current = list;</span><br><span class="line">            isInitComplate.current = <span class="literal">true</span>;</span><br><span class="line">            returnCallBack();</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    [funFetchApi, param]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听isUpdateList变化：用于主动触发刷新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback || !funFetchApi) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInitComplate.current) &#123;</span><br><span class="line">      callback(&#123; state: <span class="string">"LOADING"</span> &#125;);</span><br><span class="line">      <span class="comment">// 一次最多加载(PAGE_NUM_LOCK + 1) * PAGE_SIZE条数据</span></span><br><span class="line">      nPageNum.current =</span><br><span class="line">        nPageNum.current &gt;= PAGE_NUM_LOCK ? PAGE_NUM_LOCK : nPageNum.current;</span><br><span class="line">      <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">        ...param,</span><br><span class="line">        nPageNum: <span class="number">0</span>,</span><br><span class="line">        nPageSize: (nPageNum.current + <span class="number">1</span>) * nPageSize,</span><br><span class="line">      &#125;;</span><br><span class="line">      funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"useQueryPageList useUpdateList"</span>, res);</span><br><span class="line">        <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">        arrPageList.current = list;</span><br><span class="line">        returnCallBack();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [isUpdateList]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * onShow声明周期：重新获取数据（注：第一次进入页面虽触发onShow不过不执行获取数据操作）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useDidShow(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback || !funFetchApi) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInitComplate.current) &#123;</span><br><span class="line">      callback(&#123; state: <span class="string">"LOADING"</span> &#125;);</span><br><span class="line">      <span class="comment">// 一次最多加载PAGE_NUM_LOCK * PAGE_SIZE条数据</span></span><br><span class="line">      nPageNum.current =</span><br><span class="line">        nPageNum.current &gt;= PAGE_NUM_LOCK ? PAGE_NUM_LOCK : nPageNum.current;</span><br><span class="line">      <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">        ...param,</span><br><span class="line">        nPageNum: <span class="number">0</span>,</span><br><span class="line">        nPageSize: (nPageNum.current + <span class="number">1</span>) * nPageSize,</span><br><span class="line">      &#125;;</span><br><span class="line">      funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"useQueryPageList useDidShow"</span>, res);</span><br><span class="line">        <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">        arrPageList.current = list;</span><br><span class="line">        returnCallBack();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 触底生命周期：加载下一分页数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  useReachBottom(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback || !funFetchApi) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nPageNum.current * nPageSize &gt; nTotalCount.current) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    callback(&#123; state: <span class="string">"REACH_BOTTOM"</span> &#125;);</span><br><span class="line">    nPageNum.current++;</span><br><span class="line">    <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">      ...param,</span><br><span class="line">      nPageNum: nPageNum.current,</span><br><span class="line">      nPageSize: nPageSize,</span><br><span class="line">    &#125;;</span><br><span class="line">    funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"useQueryPageList useReachBottom"</span>, res);</span><br><span class="line">      <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">      arrPageList.current = arrPageList.current.concat(list);</span><br><span class="line">      returnCallBack();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下拉刷新生命周期：重新加载第一分页数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  usePullDownRefresh(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback || !funFetchApi) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"useQueryPageList usePullDownRefresh"</span>);</span><br><span class="line">    callback(&#123; state: <span class="string">"LOADING"</span> &#125;);</span><br><span class="line">    nPageNum.current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> paramReal = &#123;</span><br><span class="line">      ...param,</span><br><span class="line">      nPageNum: nPageNum.current,</span><br><span class="line">      nPageSize: nPageSize,</span><br><span class="line">    &#125;;</span><br><span class="line">    funFetchApi(paramReal).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"useQueryPageList usePullDownRefresh"</span>, res);</span><br><span class="line">      <span class="keyword">const</span> &#123; list &#125; = dealFetchResult(res);</span><br><span class="line">      arrPageList.current = list;</span><br><span class="line">      returnCallBack();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useQueryPageList;</span><br></pre></td></tr></table></figure>

<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>基本功能是已经实现了。<br>不过实际还有一些隐藏问题。</p>
<ol>
<li><p>不能在组件内使用。<br>因为如果该组件涉及到多次注册和销毁的逻辑。会导致组件内声明的<code>useReachBottom</code>等 Hook 不会销毁。就会多次注册这些 hook。<br>意味着组件销毁、创建 N 次，那么在下拉刷新或者触底的时候就会触发 N 次这些 Hook。</p>
</li>
<li><p>关于页面刷新的交互<br>比如有以下业务场景：列表中有点赞数，当通过列表进入详情，点赞后返回，列表中点赞数要+1。</p>
<p><code>方案 1</code>：列表页面 onShow 生命周期再次加载一次。<br>优点：onShow 操作简单，再次调取接口即可。<br>缺点：比如刚刚点赞的是第 1000 条。页面只会再次加载一次第一组分页数据，页面就会被强制拉上去。要是页面再次加载是将刚刚加载的数据再次请求一次，那么一次请求数据过于庞大也会有问题。且接口请求需要时间，点赞数更新需要等待。<br><code>方案 2</code>：本地数据管理，精准刷新。<br>列表页面 onShow 声明周期的时候，不做任何处理。<br>点赞评论等操作的时候，除了接口调用，同时也要将本地数据同步进行修改。<br>优点：减少接口调用，提升性能，优化体验。<br>缺点：需要跨组件甚至跨页面，精确管理本地数据，给点赞、评论等操作增加副作用冗余操作，逻辑复杂。后期维护增加困难。且如果是帖子取消置顶等交互操作无法判定帖子原来的位置，同样需要接口支持。<br><code>方案 3</code>：即为方案 1 的优化版本。<br>onShow 生命周期再次加载一次。不过设定一次加载最多条数。以防一次性加载数量过于庞大。</p>
<p>根据项目来决定使用哪种方案。相比之下，个人比较倾向于方案 3 的使用。</p>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>Hook 是一个非常好用的功能。<br>他类似于一种纬度，横向切片式的操作。<br>可以封装一些无需依赖状态的公共方法。</p>
<p>同样 Hook 也要时刻注意他的触发时机，<br>很容易就造成莫名其妙的多触发了很多次。<br>埋下了性能的深坑。</p>
]]></content>
      <tags>
        <tag>Hook</tag>
      </tags>
  </entry>
</search>
