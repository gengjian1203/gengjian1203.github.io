---
title: 26.深拷贝进坑小记
date: 2022-02-02 09:47:35
tags:
  - JS
---

### 进坑背景

长久以来，凡是涉及到深拷贝的地方基本都是 JSON 一把梭。

```js
const cloneData = JSON.parse(JSON.stringify(target));
```

用的久了已经觉得这一切都是顺理成章。  
直到最近终于是踩了一波坑。

<!-- more -->

### 情景复现

在做图表项目的时候，  
由于页面会用到很多类型的图表，  
每个类型的图表都要单独写一个 options 感觉非常冗余，  
于是将柱状图、饼图、折线图、面积图分别抽象出来模板，  
而在使用的时候，  
对这些模板进行深拷贝后，塞入对应的 data 即可使用，
这也为后续的悲剧埋入了隐患。

其他的都么有问题，直到遇到进行格式化坐标轴的展示格式的时候，  
formatter 字段是支持`字符串模板`和`回调函数`两种形式的。  
在模板中传入字符串模板是没有问题的，不过传入回调函数，始终不会生效。  
简直质疑人生，甚至怀疑项目引用的 ECharts 的版本是否是不支持回调函数。

### 解决方式

经过 debug 打印日志发现，  
深拷贝模板得到的对象，确实丢失了 formatter 字段。
而在得到的字段里面赋值 formatter 字段，  
即可以实现通过回调函数渲染坐标轴展示格式。  
于是就把目光落向了深拷贝的公共方法。  
果然，简单粗暴版本的深拷贝用多了，就忘记了无法拷贝函数的这个缺陷。  
于是，重新写了一个新的完整版深拷贝公共方法：

```js
// 完整版深拷贝方法
export const deepCloneFull = (target) => {
  // 定义一个变量
  let result;
  // 如果当前需要深拷贝的是一个对象的话
  if (typeof target === "object") {
    if (Array.isArray(target)) {
      // 如果是一个数组的话
      result = []; // 将result赋值为一个数组，并且执行遍历
      for (let i in target) {
        // 递归克隆数组中的每一项
        result.push(deepCloneFull(target[i]));
      }
    } else if (target === null) {
      // 判断如果当前的值是null的话；直接赋值为null
      result = null;
    } else if (target.constructor === RegExp) {
      // 判断如果当前的值是一个RegExp对象的话，直接赋值
      result = target;
    } else {
      // 否则是普通对象，直接for in循环，递归赋值对象的所有值
      result = {};
      for (let i in target) {
        result[i] = deepCloneFull(target[i]);
      }
    }
    // 如果不是对象的话，就是基本数据类型，那么直接赋值
  } else {
    result = target;
  }
  // 返回最终结果
  return result;
};
```

果然，使用了这个完整版的深拷贝公共方法，  
再次深拷贝模板 options 的时候，  
formatter 字段即使是函数也可以携带过来了~

### 后记

这个其实本来最初设计的时候，应该就是偷懒了一下。  
导致一直都是问题被埋藏着，  
直到遇到深拷贝`带函数的字段`才爆发出来。  
其实，如果早些遇到，定位问题也不至于会这么慢，  
主要是这个深拷贝公共方法被用过太多次，  
潜意识之下，最初一点都没有怀疑是深拷贝的问题。  
（用的地方太多也导致不敢直接改原来的公共方法，只好新写一个方法，然后通知团队小伙伴以后深拷贝就使用新的深拷贝方法吧，略尴尬 =。=!）
这也是个教训，有些懒是偷不得的，  
出来混，早晚都是要还的。
