---
title: 20.前端开发规范
date: 2021-01-03 09:21:51
tags:
  - 代码规范
---

### 规范背景

随着市面上的需求越来越复杂。
个人开发者已无法满足项目版本的开发速度。  
那么团队开发是复杂项目的必然选择。  
不过如何管理研发团队的开发风格，
确保每一行代码都像是`同一个人`编写的。
从而减少团队中代码的沟通成本。  
这是团队开发中重要的一环。

<!-- more -->

### 目录结构规范

```js
.
└── src
    ├── api                   // 调用接口api
    ├── components            // 公共组件
    ├── config                // 配置环境等
    ├── hooks                 // 公共Hooks
    ├── images                // 本地资源
    ├── less                  // 公共样式
    ├── pages                 // 页面文件夹
    │   └── Home              // 首页
    │       ├── components    // 首页用局部组件
    │       ├── data          // 首页用局部数据
    │       └── utils         // 首页用局部方法
    ├── redux                 // Redux
    │       ├── actions       // 业务代码可调用的方法
    │       ├── constants     // 消息枚举
    │       ├── reducers      // 对redux操作的实现
    │       └── store         // 唯一仓库
    ├── service               // 封装管理器（接口请求管理器、缓存管理器等）
    └── utils                 // 公共方法（计算时间、格式化文本等）
```

1. 组件设计

   每个组件都是一个文件夹。组件名即为文件夹名。  
   文件夹内包括 index.tsx 以及 index.less。  
   组件内尽量不要使用 redux。  
   所有依赖数据尽量使用 props 传值。  
   内部逻辑实现尽量抽象，不要依赖业务元素。  
   这样以保证其复用性。
   组建内部尽量不要使用页面级生命周期。（待实践）

   组件传入的每个参数都要注释其意义，以及是否必传。  
   `公共组件`放到./client/src/components  
   `局部组件`放到对应页面下的 components 文件夹内

2. 页面设计

   每个页面都是一个文件夹。页面名即为文件夹名。  
   文件夹内包括 components、index.tsx 、 index.less、 index.config.ts

   页面传入的每个参数都要注释其意义，以及是否必传。

### git 管理规范

1. 保证 master 分支代码，是没有风险的，随时可以打包上线。
2. 创建分支的时候，同时绑定该分支的版本号。同步书写该版本的文档。
3. 可通过 gitlab runner 搭建 CI 持续集成。
4. 按照一定语法去 commit，每一条 commit 由以下几部分构成。

```
  修改类型+(影响模块)+:+[bug单号]+问题描述
  如：fix(会员购买页面):[7405-7405]会员等级购买ios购买规避政策
  修改类型分为以下几种：
  feat: 开发新功能
  style: 调整样式
  fix: bug修复
  refactor: 代码重构
  merge: 代码合并
  doc: 书写文档
  config: 调整配置
```

PS:  
 定制版本过多的话，不建议以分支去隔离。  
 随着业务分叉严重，版本更迭时间过长。  
 合代码的时候，任务重，风险大。  
 可考虑通过 webpack 打包不同文件后缀名，进行文件隔离。（待实践）

### 代码编写规范

1. 统一开发环境  
   建议 `VSCode` + `Prettier` + `ESLint`
   建议开启保存即自动格式化代码，失去焦点则自动保存文件,setting.json 设置如下。

```json
{
  "editor.formatOnSave": true,
  "files.autoSave": "onFocusChange"
}
```

2. 事件绑定函数命名规范  
   采用小驼峰命名法。

   - 开头：自身实现前缀 handle，组件暴露出来的前缀 on
   - 中间模块名称：如：Cell、Item、Title 等
   - 尾部事件名称：如：Click、TouchMove、Change 等

```jsx
const handleCellClick = () => {
   console.log("handleCellClick");
};

render() {
   <ListCell onCellClick={handleCellClick} />
}
```

3. 自定义函数命名规范
   采用小驼峰命名法，见名知意，通过函数名来知道意义。

   - 校验类：check 开头
   - 处理类：deal 开头
   - 方法类：process 开头
   - 格式化类：format 开头
   - 渲染类： render 开头

4. 组件命名规范
   采用大驼峰命名法。使用名词开头，后接形容词。如：

   - ListSelect（实现可选择的列表）
   - ModuleTitle（拥有标题的模块）
   - PanelBottom（位于底部的面板）

5. 样式命名规范
   采用小驼峰命名法。方便鼠标双击即可全部选中，而且动态引用类名的时候，不用方括号，直接用点即可引用到，如：

```less
// good
.pageWrap {
}
.pageContent {
}
// bad
.page-wrap {
}
.page-content {
}
```

6. 路由传值
   由于路由传值都被转为 string 类型。传值 undefined，false，true 等歧义变量，很容易引发隐蔽性 bug。

```js
`/pages/Index/index?isAdmin=false&isOwner=true` // bad
`/pages/Index/index?role=owner`; // good
```

7. 封装方法传入的参数尽量是对象

```js
// bad
dealDateInfo(data, show, tip, success);

// good
const params = {
  data: "1",
  show: true,
  tip: 99,
  success: () => {},
};
dealDateInfo(params);
```

如果一个函数需要多个参数实现其逻辑，尽量将这些参数组成一个对象。
这样的好处在于：

a) 方便定义类型。
b) 如果部分参数是非必传的情况，方便处理。
c) 对于编译器减少 push 函数参数的操作

不过要注意，通过对象入参，会让参数变为引用传参，
在函数内切记不要直接修改入参的值，否则会改变入参的原数据，以免引发其他问题。

### 开发规范

1. import 书写顺序

a) 首先引入第三方库
b) 次之引入设置别名的绝对路径
c) 最后引入相对路径

而同级则以引入库的字母顺序排列。

2. 类开发内书写顺序

   1. 优先书写变量相关

      1. 优先书写 构造函数：自定义变量
      2. 其次书写 state、data 的定义
      3. 次之书写 computed
      4. 最后书写 watch

   2. 次之书写函数相关

      1. 优先书写 methods
      2. 其次书写 events 等自定义事件
      3. 次之书写 生命周期
      4. 最后书写自定义函数

   3. 如为 tsx 文件

      1. 自定义 render 函数
      2. 返回的 render 函数

3. TSX 文件书写顺序（待实践）
   思想：

   1. 自定义变量
   2. 自定义函数
   3. 生命周期
   4. 绑定事件函数
   5. 渲染函数
   6. 主渲染函数

   详细：

   1. useRouter
   2. useRef
   3. useState
   4. useMemo
   5. 自定义变量
   6. 自定义方法
   7. useDidShow
   8. useEffect
   9. usePullDownRefresh
   10. useReachBottom
   11. handleXXX 绑定事件
   12. renderXXX 渲染函数
   13. render return() 主渲染函数

4. 善用 CSS 变量

   颜色、字号、边距、边角已经有规定尺寸，常规情况下，不要直接去写数值。会造成 UI 风格不一致。

5. 数据管理

   前端要有自己的数据管理能力。  
   由于组件设计过程中，组件内的变量命名应该是抽象的。  
   那么在接口获取数据之后，  
   都需要将得到的数据，转换为组件内对应的变量位置装好。
   这样，数据处理位置比较居中，同时也能倒逼设计组件更加抽象化。

6. 多条件判断情况

   以`[].includes('')`处理为宜，方便其拓展性。

7. 生命周期的运用(仅参考，根据具体业务来运用)

   1. `useEffect`，只用来处理变量
   2. `useDidShow`，用来请求接口数据

8. 组件抽象化
   在组件的设计过程中，组件内的变量命名应该是抽象的。不要把轻易业务变量丢到组件内部。（除非放弃该组件的复用性）

```jsx
// 业务需求：处于某某身份则展示编辑按钮
// 组件内的展示逻辑：纯粹跟他是否应当展示有关，而不是在组件内部还去关注他是什么身份。

// bad
<Header isGM={true} isAM={false} isBM={false} isCM={true} >

// good
<Header isShowEdit={true} />
```

9. 可自闭合标签，采取自闭合方式书写

为防止标签内的内容过多时，闭合标签匹配混乱的问题。

```jsx
// bad
<Video></Video>

// good
<Video />
```

10. 标签属性书写顺序

应当按照以下给出的顺序依次排列，确保代码的易读性
a) class
b) id, name
c) data-_
d) src, for, type, href, value
e) title, alt
f) role, aria-_

```js
<img
  className="imgContent"
  id="img_apple"
  data-info="aaa"
  src="../aa/bb/cc/dd.jpg"
  title="图片"
/>
```

### 套路场景

1. 多条件判断场景

```js
// bad
if (
  strMySelfRole === "GM" ||
  strMySelfRole === "DM" ||
  strMySelfRole === "AM"
) {
}

// good
if (["GM", "DM", "AM"].includes(strMySelfRole)) {
}
```

后期只需要维护数组，即可清晰应对新增的需求，提高其拓展性和可维护性。

2. 复杂条件渲染场景

通过抽象枚举值，善用表驱动法，实现条件渲染。
不过要注意的是，key 值要保证是已有字段，不然无法渲染。

3. 复杂场景权限校验

简单逻辑情况，可以通过“与”运算符实现。
复杂逻辑的情况，可通过装饰器模式、高阶函数或者 hook，对业务逻辑进行装饰。
达成目的是，降低耦合，校验逻辑、业务逻辑互相不会污染。

```js
<Permission strCheckPosition={"LEADER"}>
  <View>Leader Content</View>
</Permission>
```

4. 常量的可配置化

一般不要在带代码中直接去使用常量。
建议将所有的常量抽出来，统一整理到一个 config.js 文件中，
遵循`开闭原则`，对于功能的扩展是开放的，对功能的修改是关闭的。
即使新增需求，也不需要去改动老代码。
方便需求变动的时候，能够快捷找到对应的位置，方便日后维护。

5. 减少冗余的变量声明

对变量的声明尽量精简。
不要多个变量去控制一个事物的状态，
声明越多的变量，需要维护的成本就会越大。

6. 组件的抽象实现

为保证组件的复用性，对暴露出来的方法要遵循`单一职责原则`
保证方法的高内聚，不要携带其他副作用。
比如，tab 切换组件返回的事件，应当只是纯粹的告诉调用者（父组件）， tab 的哪一项被点击，
至于被点击之后的处理逻辑，应由调用者（父组件）去实现。
业务逻辑不在组件内实现的好处，在于方便在其他位置复用该组件样式。

### 代码优化

1. 慎用 redux。由于每次变化会触发全局刷新。建议只存储唯一性的值。
   a) redux 是响应式，每次更新都会触发 diff 算法，全局刷新渲染 DOM，影响性能。
   b) redux 是全局纬度，其生命周期很难把握。
   如果不做处理，只是一味的存储，不去主动销毁，最终就会内存泄漏。
   建议只存储全局唯一状态性的值。如：品牌、菜单列表等。

   搞清楚数据纬度：组件纬度、页面纬度、全局纬度。
   各自纬度的数据，存储到各自纬度中，方便代码维护。

2. 与渲染无关的数据尽量不要放在 state 中，可以放在 useRef 中。
   与渲染无关的数据尽量不要放在 state 中，可以考虑放在 useRef 或 this 中。
   每次渲染会对 state 对象进行遍历 diff 算法。减少 state 的内容，可提升渲染效率。
   且对 useRef 和 this 的修改是同步的，能处理一些需要属性及时生效的业务场景。

3. 善用节流、防抖。
   可对 usePageScroll 等场景装饰节流、对 input 的 value 变化场景装饰防抖。

4. 封装组件的时候，留意不要套多余无意义 View 。以免页面 DOM 层级太深，影响渲染性能。
   可适当用`<Block>`或者`<Fragment>`代替

5. Input 输入框跳位问题。尽量不要对 Input 的 value 二次 setState。
6. 尽量减少页面的跳转交互。
   页面跳转体验奇差。会有白屏闪现。
   在业务能满足的情况下，尽量单页去实现功能。
   可提出建议反馈产品设计。

7. 尝试页面处于 loading 状态时候使用骨架屏。
8. Input 的输入内容要进行 trim()处理

### 项目管理

1. 通过 jsDoc 完善 api 文档
2. 通过 jscpd 判断代码重复率
3. 工具化代码 review 平台
4. 项目管理系统平台
5. 自动化测试

### 后记

本篇部分内容为实际项目已经用到且取得相应成效的方法。  
部分内容为个人见解尚在理论部分，待实践。  
项目规范是一个不断优化、不断完善的长期过程。  
要做到因地制宜，慢慢尝试，找到最适合自己团队的方式，  
这样才能真正提升团队开发效率。  
我也会不断更新该篇文章。
